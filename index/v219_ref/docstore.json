{"docstore/metadata": {"ee8c1bea-b1cd-4fac-b9c4-9abe2fc7180a": {"doc_hash": "1c00ad3af0149b0cabba753360daf30ae727aa7052c6a69e02ee82d0f74f540d"}, "908670da-f9ca-45f4-9c87-18f5a25f1c50": {"doc_hash": "cd47f931768321c55338deda36f2d691c4b2dd8ea575b2110969738a85dabfe0"}, "39782762-0920-4ecf-8385-840e2a25cf4b": {"doc_hash": "f994149bf66e0c07a66388f5c182b1a517db9ebc67865cc36d9f0de3851b8965"}, "443f616f-d00e-4fce-9d52-2f82b3787301": {"doc_hash": "17cd4ffa976395a166f978daf104773098be331796da8b244bdef440f19f8c86"}, "c6039319-063d-4f6c-bd97-c2a6f8f29be3": {"doc_hash": "e556f18bd418f88f747beef0984c0628969eb983b7e00766e3995e213ecfbf40"}, "90438811-6318-45c6-8a9b-31a4dda94448": {"doc_hash": "00bbe8bc33a1e303a7f3252e31deb6a05a51bdddc14f97da16f0194b986f5603"}, "1500300c-2874-4b87-8451-6e42a046b04c": {"doc_hash": "851941caef6493e1abb0049a210fb0440febb412ea4720158fe6165b6df8de62"}, "c2f15d98-332a-4ac4-84c6-2e069e9c4d2b": {"doc_hash": "0c0969716e8061659a84ba9af02fe51af8a85f28b59123f0f50c1c31d9267d00"}, "cda8dcad-3165-4e73-8ef9-913cccf2a532": {"doc_hash": "382c14d34909b6353f49e0b14ced5d4b8827d1858d02e590272b0da8fb1b1b05"}, "f12b1ab6-bf1d-4a1f-bb32-08050ed7ffd4": {"doc_hash": "0f8bb430645a63de78b35721d3c69789c924764c3215cc8b647bbae1ed8a7edc"}, "2cd0d4ec-de93-4c86-8e23-2301b9df028a": {"doc_hash": "d3ed12185cc3bbfc7c730cb2ce394b2d6b8141f33bd3a485a3efddf0dae296b2"}, "e05e5cb6-514b-4eb3-aeb9-fa3339907cfa": {"doc_hash": "ae13d0ad8ad477b56ba80671a46ec6da2581c0622accde9a1e348f7ede01db57"}, "86c4df41-67bc-4b18-9531-991ec39cdeb4": {"doc_hash": "57641084a3c696a4d1aae74a296bed6a7f44e58e452e886e708727203a405594"}, "6bb64722-3854-4de2-bf50-7316a8a7a149": {"doc_hash": "f52057c4b52be056363c0faa1f686beaeced59d42c82e0cae06e804c2e4d2816"}, "1bb4c179-ec9b-47a4-85c5-3d787bf7001b": {"doc_hash": "763f3378a0d9c2dc9f4839a8db20d7d70cfb8e048824d480311f7a44ae211c30"}, "07dc62f5-fff0-49d2-bdcb-0b4caa795372": {"doc_hash": "8849eeae9574ea581d1d499a4f032a8ad55b54084302403b417b8bb417acc8d9"}, "d63598fb-e347-4caf-8874-4ea073ff89a8": {"doc_hash": "c335e7033effd0df8b27233b701a75a4a06998d146bda7235aa83e85b1b16f52"}, "2af8bedc-9d1c-45ac-9d9f-5674e6253616": {"doc_hash": "0d965771123e907eea2be70e3433edea0808dd57387aca037ce8bdd89642d7f7"}, "21660e10-5ec6-4d81-af4d-b8fa01baf94c": {"doc_hash": "570a1d118ace75a8b9fbad82537549fea30295f81d2c163c90eeb38a618749db"}, "a90ea0d4-c27a-46de-8738-36937bacf466": {"doc_hash": "64d6702cf7212549762970306f98517ec4a3512e30bb48ae385e9ec7b5368462"}, "884e2dd3-ea7a-4e36-8ae2-8f62bf050531": {"doc_hash": "1c2d978182e66442331e073c32b5fe86638e5d89c7ce0d85ed4db7aa0f4899be"}, "7b7763bd-1f87-4b28-b172-88434a0a738d": {"doc_hash": "704749c4aa2b08f9598744761907dcaf03f019460db438b4d82191b7e28ccada"}, "93f63f91-a2cf-4c98-b1a2-af9134983d98": {"doc_hash": "ba114f418e563db902bd475a0c2c25040ab7e3ab99970a3e77a32e53c118a40f"}, "4958c287-f737-46f2-97ef-bc6944efaed9": {"doc_hash": "59bba534751e43f62abcd3467b4e7933169f70c8be68b734b1d05ce2c6201960"}, "b5ab2401-83c5-464c-862f-fa9f6fa74f56": {"doc_hash": "dff92c63dbfcac389cdf557b9b6ddc66e099933686e48e435f1283f9fcce7706"}, "0227c4aa-7239-4e62-bcc9-8e90f5b2d44d": {"doc_hash": "01bc36f8bb8557fe87be755b03c12b88f0b8bd793855442f7724e7b145b578a8"}, "62a8b884-ade8-4a27-b6a8-c125f915b95d": {"doc_hash": "92906ee56485b5757e5ff4991aa2a7cee1284e13a214f34bbdc89b263a2a92e0"}, "9d2dc5ed-5e92-475b-82b6-56268780b21d": {"doc_hash": "b33ee6ee2d86cda85f8cefd8789289ad29eb420ca213aa6f7c64166370a358db"}, "ec91b65d-e280-46b5-a777-e84d83560d98": {"doc_hash": "2832d6c95d88b0e55d63f9577a0f36afee19decb84b94dffeebe08c27f680dfc"}, "d47ef1f0-3a24-4e62-98eb-f2d4f4e64515": {"doc_hash": "e12d9375bbff5c6a63d9808ecec5bcfae9c3b0e7d4d834465b4031a032a9df8b"}, "1067516d-07d0-42fc-a9e2-b5cc0de4fe9a": {"doc_hash": "657331dfba7cd7a88619bc3202ee7ad53cc18b9ed876a11071078cfbf36a3945"}, "5048901c-dd23-4034-b49a-059813f62608": {"doc_hash": "5ba9882352295359dbd443dbbd87908c53dbfbb002fb75274c2027c6f68b2009"}, "13f2e3fd-a955-4360-acd1-9761ef014aec": {"doc_hash": "c22040a288456498e64d7f724e70497ec664f92a56ea3689c748ccb7963109b8"}, "5f65fa5a-be1c-4d4c-841d-71826c3097e8": {"doc_hash": "6aff1701e8e9d4c4fe2d3e0d077201619b1ae87be66a4bb737b1435411c8b18a"}, "3b6461a1-c383-4500-a9e6-43f39b6458ac": {"doc_hash": "c10fb731f015aa7171e3b3c8f68edabe7181dc72f686b63b16d583691d4196bc"}, "1299ce80-d804-4efe-bd44-49226ac327f8": {"doc_hash": "d3c41640df2ea01e926eff798011ea8b9cc2968710458cb0638587f30443b6e2"}, "9f33c3e1-1e3d-40bb-9815-0ab96dee0e26": {"doc_hash": "e924a3cac67a0f661e968dddf10b80bff9431cae163bc82f872c8ab5b6b11b55"}, "6fafa2db-d580-4bd6-bf08-2f3b424d1c97": {"doc_hash": "3e5519d1820bf23726ff00d00d932aee406523e0d050ad34399ed5d0d708cdd3"}, "94eee232-a3ad-4b0f-85ec-afbdc0d5d33a": {"doc_hash": "cc48c95dfeb8ebec710a7b5b94a77a85203c2efb20970425a915a600bb9a5db5"}, "202afc63-7d82-488a-9137-97ceabee5814": {"doc_hash": "58908fe55605eaaa80d050c1b0d3c8bc21244744b83f205b2b9be02b8f5a66b3"}, "d33a7aa3-a7c9-4dd3-9912-e6e18ed4ca90": {"doc_hash": "2d9ae1b4ea4a7c5adf248573462efd8e10bc8588ad33b9d4e0dfaf10924b7514"}, "b0a92881-a03c-4afd-8067-ad2ec5a13701": {"doc_hash": "7cdcd5bda005a3edffd54abb59137415466ebe467aa6da9697031456089de6a9"}, "579f3294-8ab7-4e22-9588-33471c4a708e": {"doc_hash": "24c72b2e062dd5694cd381f425592e64e69b3d49c43833c4d290e2abbced57bd"}, "ac29e2b5-71ce-4c38-a656-c33875238965": {"doc_hash": "2f45107302c9c6f46336758b48d32f32f8dc49a0575a51c463c60a419315bff5"}, "a84485c9-b380-493a-b067-094fdd376094": {"doc_hash": "e1b81cc6b3fb0981dcf450e4de799a69e3dee73bbc96b4d262bf7eb7582076ca"}, "756f8435-bab7-4990-938d-0a5c79c41202": {"doc_hash": "22991bf0dcc79e14d529f8aca8c3ac6ed78621824af0a954c65b772f2e3f4b07"}, "a7566768-83eb-430b-8927-cf27b0116b87": {"doc_hash": "223aa027a3719b847d7073d828c80813b030c17a85403e688b81caeada7ba11f"}, "947440ab-25f3-4da8-8d46-0b6010cf4c1d": {"doc_hash": "2fdddc394608b5ad87223efbac68eebc542f9896108a11241781d68c8250963e"}, "11392ab1-c733-4b0e-a3b4-51b914143cd2": {"doc_hash": "33f1cbe30588d63a6869f6ee4337ae27ce1b651f8b035c786d350045add5e0a6"}, "677686d6-dcff-4e7e-aa22-8aab50d5c9d5": {"doc_hash": "4b5aa71553276801fe40a5e11c2d8fce0d6401512128cc802b31c52bda1eeb47"}, "282ac654-91de-4776-80e2-e59a4f83193d": {"doc_hash": "9a69aba484fd23c0469eeb0941d579bbb793bc301525b663867af5e4d3f93b73"}, "31631f53-39eb-4bab-a03d-f24041756d15": {"doc_hash": "eb37c3f4a19eb5f7cedcf5f7bb99f3b18999829410789cca8526456d03b16284"}, "c4ff6a2c-3797-4ee0-bbf5-5b1849d8c328": {"doc_hash": "e747b25f0bddbe0d43999ce0d04c2137d1da402c92bf2d816a24d6c4f6071f3f"}, "b20bab95-1850-421a-a785-1f6b1665520d": {"doc_hash": "640145ad9ae74332ac695c84d2a79b282db396e311960cff872d093357bffd05"}, "2eec6d88-96a5-4ebf-80ae-3084489084c6": {"doc_hash": "5c1639d79bf88b6045011d78b6689b707af76169e896d27889975dce9a3472ec"}, "88dc04a6-a0a0-43fb-8661-a06c018980f5": {"doc_hash": "530ca137fce27df8c80c6a3e0d746976aea70e802cc0554a4ffbe3a8f8f691d3"}, "6d13b8ba-18bd-490f-9c2d-9d549550d782": {"doc_hash": "b4019291c957a200abaebd0b21fb497fe711200fb1bdbd3dab163a2dc642558b"}, "205d6cb1-d53d-4cb4-bfee-6d7cb87d2c02": {"doc_hash": "6aa5df57405d3d694a2b2eb4aba2bc98fcbd3b5d0b91add7219c8d83997fbcab"}, "6c369cc3-8892-4b09-a524-b043d002b7a1": {"doc_hash": "2eb68fd069aa0a351df6ac566533d31d1d15df138ba0d3ae4df2d804f61908d1"}, "6306ae25-5d84-4f9b-b0d8-b5c649ac9a23": {"doc_hash": "8a2aea80861798cbe2ea4f26af49f579707c32d134c995bebc42b9baf18a6b41"}, "04c427d9-e2fa-41bd-baec-a4a7a317660b": {"doc_hash": "32cb225619d5ae73006c67f79dc6f850cd10ab5cd5272730ce4fc448b62c68ae"}, "aab510f8-68e5-4a6b-9dfc-bc62ea31bd0e": {"doc_hash": "fceb19012133938bff7274c61a272131cc0be8ede311873a71327d62d52561a3"}, "6ef1cfef-1436-4538-bdbf-ab280b7e469a": {"doc_hash": "996fe8a957f952f67ad0f20e42c3def59258bc073ee379d6116a24215551f35d"}, "f72abc19-8b18-4335-8881-c297dc1163f2": {"doc_hash": "50fcc66c01bced7be3948af152a92d3bb472d422d5f228c329b8c7e30fc931f3"}, "0cae6ee2-b850-44c1-bf99-694cee68a4b6": {"doc_hash": "c9f7f14f8b79ff7ae0b29ee66a43cac4df0883b99b5787b5cc1c3a4dcbdd2648"}, "e2716b63-d299-4465-8e6e-d976bf37e9d0": {"doc_hash": "668af6fbf34e65ec32694ba06d83b8c672a8fca41ef7f47d302687b8003deea5"}, "6bb63a31-b4ce-4b00-8efd-307768f04424": {"doc_hash": "0ae7f7eb46f711969cae986331bc01ebea75f119330c37bc16d888aa4ff7995e"}, "e3796c9c-ffdd-423d-8b76-118a05663bb5": {"doc_hash": "a9c851a563b282a648a0db1ec7fe0c15b67dd99bb65d7b0ff3ce76b86afaa31f"}, "2a55f44f-4fbf-499d-b815-f9c2877a8d0e": {"doc_hash": "09d9025ef903ca77fe1d45d632a888b35d5f48294e86aa0a743c18bfddfd1004"}, "7361c261-b009-427a-81ba-edcfdda667e6": {"doc_hash": "f96bc55ffa259d9d67e448124a27722f9829cf0b2d3b9a112ad2f7574775f70f"}, "e47aa32b-4c2b-455f-a134-d242e27199ed": {"doc_hash": "2a6b2480e01ba5a0a76042a6f2b2f7fba2962416a1caf6cf18caf38c71bf02a8"}, "00d870b8-cbb0-4d7d-a350-496c3e19a1bd": {"doc_hash": "07d0b9f27f4bbe7e0ef87fa28fab775fc38287dd69bdd2d59046b928159da20e"}, "11382185-80cf-4e29-9b32-e96ab039e973": {"doc_hash": "100549f8788c74d369ef4f969d4d2486ff9df3b536ccdaf3756c1f908fbf3502"}, "6c334337-2220-4f84-a1ff-d0d977582906": {"doc_hash": "987312c509b1f4a85da0397a57e8e4d727cc881a298931b81eb3a027b84f4279"}, "0b0fe093-dce4-4605-9bee-82c42074f1eb": {"doc_hash": "238e24fafb1a0855040c43e3adb87cbc6c85cbd5d73af5572079293040ade16f"}, "8f18e61c-5f3d-499b-8a20-e029fb61b208": {"doc_hash": "08be2c33d2330a2e09d71f027d9d639e00f7fd3011cb1891b60a873b96cbe61e"}, "c62e1dee-ebc0-4f4f-98cc-5c99dac80529": {"doc_hash": "a62cd229a1f683b6dd3124ff7a266e32f798b1907d2cf5abb4d7be33fcf0823d"}, "2be3e37e-fb2a-4504-a589-8c14055853ef": {"doc_hash": "83407e5157d08d3ac53347363d9ab8f944218bb592f2804afd205f46f2a02a82"}, "a3f10417-72a7-4462-8ee0-440e39a24ab2": {"doc_hash": "7ed84b07a4f626ea14cbd4735651f33fbe82de158ee9dd264d631ac51e8ca81e"}, "f95d67bd-6c0d-479a-a872-3674377bca97": {"doc_hash": "3e79cc3220dc67f26b754f64be50f2e8f4c5fda59f5f72936418501578c374a8"}, "8c6dd48a-7701-46a7-95ab-162bb819468f": {"doc_hash": "30be8048d8e760ee9b6159c911dbccea25d1579fd0968f66d3ec86a1ece4d7a0"}, "bc6e6f88-5eb1-408e-8ad7-6da71f6f1d38": {"doc_hash": "2440b4b983a752097febb57cd334ad7f8ece737c7ae42b71bdee01d9052ad2eb"}, "d1a63777-02d6-4af8-a809-2f8ae6e6475d": {"doc_hash": "350eb7bbde5b650422abdce2fa48b589f2f623da75f87ed458d9762291d8e0b9"}, "3b458459-4dd9-4848-9549-85e9a77fecab": {"doc_hash": "4ed0f646f770604caadd7747189995a460b7a16b69be166ebbe809032b9ae7d6"}, "51ba3d9f-a608-42da-8e73-50f9815acc58": {"doc_hash": "07b2e034fb317cd1b9cff1ddf0c76135b501192f05f31cf6a77e2be1b5d062dc"}, "7aa44a91-4a05-4638-b083-d7b567e074fd": {"doc_hash": "a1da1e0451a5c3aa3602ca8546b32abfa43ac5f68a2754b975be8f3258859754"}, "d69fed16-ef9c-477b-8162-5398ec0becec": {"doc_hash": "819383e8bfc0ebda3841e1bf45034a8d27bf06afaea424182fbaadac3b36f89a"}, "1e28e0d8-a45a-4ecd-8fc6-3ed34c463e4c": {"doc_hash": "a6127b917d39ca1701bf4494a46b11faee017510b7c095af826dcad13a50e0ab"}, "2385bce1-9781-40a9-bc5f-babc5758b8a8": {"doc_hash": "e7f3a7b9c251970796b396bf230c38db0b9be5d9d2668149a7ac57e0478d36d9"}, "917359d2-353c-445f-b663-2fc3df9b4709": {"doc_hash": "830244d8f47c14c46023a1fc8bd7f29f1e7fe7e6ccbbe1eac544d90a23f6ad63"}, "94e300b3-0998-4e9f-8198-6c6f820d2e82": {"doc_hash": "7e751e7df393e5f45d5597a830950f45654466e9abae3de69be21bada11c2a8d"}, "cfcc63a6-d0c1-4c7b-8a51-557bc0dc565e": {"doc_hash": "3c7344245458a311f61338bf96e7edd85674ac62cab444da8fc4e2c111668828"}, "4f20e1b9-764d-4ffe-801a-19a51b1058b0": {"doc_hash": "530e581562b9864df702942bd1e6f63eb955c792607213387ab4c92716bfa60f"}, "9858a4df-7f4b-42c3-b033-6606454404e6": {"doc_hash": "c16628b7621111d77cd958894a7b3127e9cfb1258ef16349c848f9c8d7bf26ec"}, "c4fd46da-c327-4201-bcc8-65ff4895ba5b": {"doc_hash": "88a11d77bbc719085572d9a1730ea45bd2977e88b37b7b94ff817ab806fdda06"}, "7c151f85-8ba8-4b98-a167-a53fde012914": {"doc_hash": "09c4e50be96e89e090e5efdad58e08543c6fa15f9957a19d929090fa733de4e5"}, "19ae540e-1254-4853-b078-e61060a4a0ed": {"doc_hash": "ffc6f66af0e497fa19be876a6506eeac8b9f7d9b2b6b6e7557901e000af5dfbd"}, "e635531f-c20b-4860-8dfb-420b960c5f8e": {"doc_hash": "1af2fa9f1a295c4426cd18618148eb95c07d3f7e18c2a1f6bd61ff26d8887b28"}, "cccc5fb8-ddbf-42d8-99bf-3d47d736af84": {"doc_hash": "0c616f5a5bc948d0d6eb9990a5835db00ababa280db3edecce055a6908db9574"}, "9769d996-c1b4-4dd9-8234-fe2515e80255": {"doc_hash": "08c833352fa26c900b21b59b57ce2c16a134ce053fbc9dc1b29e48711f41fc74"}, "f055d117-26de-4aa7-8381-a2a3550eacc2": {"doc_hash": "448a694a521cdaf2b7c4561eaf1e3a7523092b48af7c41848f15a8a6d4b10d1e"}, "ac98703e-178c-4344-a053-9adda47dcd16": {"doc_hash": "da3fdc5a1b0547ac4ac3f00b86654520a0b65ece9ef0153d30a4c47ceb2d37dd"}, "4e01c364-e826-4134-a736-fba73609950d": {"doc_hash": "c22d0e64bd39a41bf2ee4bbfadc9cf3f6aeb877bae1349446dd024de7b5c0954"}, "95463265-4f6f-4c31-8d48-990df80674af": {"doc_hash": "be646d16797a08c46710bade7cc6b227de7e3d12d3966457baa27958aebc6e74"}, "7a1867b0-ab52-48f8-951b-fc43bd32f774": {"doc_hash": "35605c5473640e03d85a44713c2397b95e1a4e497913c6d28321c121ec4b24c8"}, "cf77a9ff-f7c7-4593-a369-cd4fcec74f2e": {"doc_hash": "dd9c4b375f49494ba8d5ae624e6234afcdcb9499bcf93817a43e5dde87fb223b"}, "2998f37a-c9ce-4c33-bf4e-52eebed61bb6": {"doc_hash": "ce96543206b3a4b5dd06a434e8f2ec0488e7775b4f5cd26e58497b4495c8ab4c"}, "5da6ead4-b24f-43e3-bedc-9a77b862fc9e": {"doc_hash": "b953a11e5f4b844f5c40f9d9c38727efb0d8f678e071645087ac103bebb620b5"}, "c99c0473-2ee3-4626-a83c-889903223a8d": {"doc_hash": "3cc5522614ace6c31db35681e75179b71b9b672d8ec14537767663934695d542"}, "e1730e91-dc77-4608-9b00-c63130efd0f6": {"doc_hash": "1d49010f8b6769fa6f98effffaa457ab49380fede7534e975c54a82b495e08bd"}, "623359d1-b398-4a1f-bbed-a2188f071c4f": {"doc_hash": "03c499612360562defa34aa154fc5917aa709e99a40a28647ee03b0015aea1d1"}, "c7fc7ded-4162-42fc-89f0-25bebb2072f7": {"doc_hash": "b72eee81145aaa6e78afd9aeac82e5932a0e3b907f2c4dec0f27dfacb8b47eea"}, "cae08c35-58df-4cf0-9034-118be5bbfe65": {"doc_hash": "597f6f57a123220a784c3a8e0bba900677c563bb7dc1eb434ac470d50e2c8ac9"}, "f8790928-f542-4321-b081-e518644dc5b6": {"doc_hash": "1ecc55e3485dedd5315f44c0984790e7a30c9f7bddccdf7a112acf3934450762"}, "83b2eff1-167f-4ecb-8fea-bc10ab4531af": {"doc_hash": "c806387d6dcc958e43e0d2da8de99cf9268ca40fce719eb869f8cc7fc00517d9"}, "b7d86710-14f3-4128-9055-d2f74d49704f": {"doc_hash": "77622e36750ff0d90b4cec3f8a004c7077411444b56ab85775ddd0d530f34820"}, "9efe19e9-92a3-42f7-a2fc-591df5e1f4cc": {"doc_hash": "4eabbc52f2f65daa7a00797a78a7d64763271978cd9c1840313a57bc136a3bd9"}, "bb774b2c-b190-424c-8f29-da6e433a7ed6": {"doc_hash": "9fcd2abee3368e5881c3753377c8c02bc92475e8278b95eced37b27fce7ba6de"}, "03c17ce7-f7a9-4af4-bbda-4ef034c1775e": {"doc_hash": "4d5093fa8fc8d02319ded15c12c5b4265ef3261ee36c5ab4e8b4e135bcbfd7ed"}, "8c47a83a-cece-4eed-9754-e87cfa1311fb": {"doc_hash": "008f4a06d2ca3b4c082a175e5ae84990cdb7af9848c82c92653900dc84465a11"}, "7c325cb2-4c75-4937-b03b-0621439135e5": {"doc_hash": "3966a50d4a5a90840532226991de33855ab9fbd464afc48702824d29f960da01"}, "b8310bbb-c7ee-4550-875c-c54c445580d8": {"doc_hash": "83138f33147e050b599a711f5b401d404c60dd15cf58e8964a2196100324589a"}, "a1e3b10e-6074-4a02-b32e-9d69f689ab63": {"doc_hash": "4933aa97be1bcd25b35c3b4c9a0b15955265863ebeb28e14edf8703409d527c5"}, "befa605f-8e9c-4682-905d-bb77f58d0fbb": {"doc_hash": "94f48aeac66451c578f9818c01243b85fedfab47a6ff177d86e3d25554841634"}, "d74a49ec-52f8-43a0-bbdf-8b110eae4626": {"doc_hash": "22de98ac1ad09226fcd9459db4bb662b523e238bf088a4b1511447617915155e"}, "d1445793-9701-4b67-836d-6945c31b6fab": {"doc_hash": "908cb9a1f7432fff199b6fe85e271cdc943914d87134cae0aa033f78db2ea915"}, "208c29fa-b14d-4b20-8c2e-4cfbc76658c1": {"doc_hash": "ad7f39acd0c4fc35fc51118c8ae367954a1fa58dd03a51f39f83031657171305"}, "c58902b7-d175-49cc-b12e-e5d57bb46c0a": {"doc_hash": "b10d835e199e86e2dbfe314d0dc42245960e23269a6e55489d0e3920e0feedb4"}, "5acc5950-7cb8-4531-910f-c539038168b4": {"doc_hash": "68332fc36802759fafef539edce44186f083b307db0e60adda9aefabf7e6be26"}, "a94512db-7ba1-4546-96c5-46c118179f66": {"doc_hash": "2f00c11b1341312198787db239d24633c2e95670a02b1e0202c692b5dbc2d435"}, "42247bef-29bf-488e-9c35-cfbde445f7c2": {"doc_hash": "aedc412596aa893d6a1cb46588f882d9f4bed77c0f7a647f32d8d9d7fe7342e8"}, "7a5223ad-8618-4c77-8174-a0aa8c67cbad": {"doc_hash": "eaf89a063aff9373faeb73942b6b383bd9cfc9d51682028fa26d448da6f2b1fa"}, "9198039c-fe34-4d2d-90c9-dc39b8a80fc4": {"doc_hash": "3f0a94710655fe62d5a1a2f1ecaf5a107eda1f0ca40a5b713405655d1d574c4f"}, "91ea4229-4514-4e32-9db5-c1b1c4643864": {"doc_hash": "5acb38cb9d979f5d06fa3bcfd0de158562a3fa040f4a3850b0195db1a9b520e7"}, "8b4d949b-1c03-4f6d-b762-181d5bb8aaee": {"doc_hash": "93953926eba1308cd3a2b92d06e7f0fdb66378494dc0b2d7fd972e51e6281020"}, "7b31efe2-ee89-4579-b759-61dbb22030a7": {"doc_hash": "8d90b0af8d5c4c15f7bca1ce8737f67c3536ec2b9d46945f6c0e4a5681c049b8"}, "6c261d99-e848-4553-920f-ba01e4a108ab": {"doc_hash": "f6dfcdff9281abd0d277ac5e6e75e7a784a5c5e2997c70f2568edae4448aad36"}, "490a1ee7-85e9-4f30-b09a-3b5156bde184": {"doc_hash": "d0f0c5c31704c02c3118a0c8756a4bb67337199b6c3c18a5859769b71b684300"}, "c0b93724-2c51-48ea-881d-a675e7b84f73": {"doc_hash": "5d82a20d18494f63ea947574b63a6b835c56ed318cf133e23b50234ecf806903"}, "80cfdd44-fcd3-4767-9605-e28c5672c4ac": {"doc_hash": "5dc1caadc8b72e868753cb2b5069ccabd03c6681d8ffe5303da273d25493f3e7"}, "5ec31165-dffd-4cf1-a2d8-43fc9def9a40": {"doc_hash": "488fc07d59174a3ba619d643717eae7c06f5f63dc799a8a2d1d3d463318d7615"}, "9767c140-225f-4161-a0f6-2009754c94c8": {"doc_hash": "a99b37dd12a772a1655d09351df60a192b1e8db34a0e7b235b3dc55a66a48c56"}, "947c0910-1b00-4ba5-9046-be95eb1f44b0": {"doc_hash": "28684a7bb3e6e42b058ac975150aad22bab7dded6616aab626cb44d3fcfd64fb"}, "87f281d4-5221-4688-91fd-022e020b9131": {"doc_hash": "738d8a8f7d9f42d9df88b045fdd9468f093f760a89f206994ae1324aad3a3b21"}, "7afba3f6-4616-4a9f-a8dc-77603366355a": {"doc_hash": "54ba93b4cc21e03e110833dd5adff0bede3c14ea5794bd265b4b8ed1f11bd811"}, "275b9a1c-df4e-4a13-b66d-aa0d91623187": {"doc_hash": "fc5054a9434c7af06abc8d57de99bb3fe5188ba55933177956021049b43446e7"}, "7030ba58-c661-4098-a404-e8982afc283f": {"doc_hash": "8b81eb36061fe528a67b7629bf4915b653da03899aae0af4d63abe233a396068"}, "dfdf4f76-0f19-41fc-ac76-c1885dba6401": {"doc_hash": "f461991db9b6bf0b0e896c6a97941dadec441b2156b3a8efcb5aa38b21ee5f61"}, "9cd1c731-02a5-4eb9-a77a-c2c47a97fde0": {"doc_hash": "a9dc918a713d4fda513dc93713455aadd384b0e65129b18f8c9154d44d3530db"}, "2fb81f50-58ea-4f20-9d89-f9b46d015d60": {"doc_hash": "aa1b8b9239af6e0942a9c501ffca70d7d1c05ef722c31d4e669e55e89c1abb25"}, "0f9e27a5-ff6c-4fc2-aa7f-7fee480f1057": {"doc_hash": "5225d2548a58bba4752c4fe826ba6e715fb3e2c05215501da9a2b235921cc4ce"}, "738137b4-f8a0-4cf8-93ca-a82448c99510": {"doc_hash": "8d2570364e2a92205b130376200d683d44108c84401a35658eabbed3e53777bd"}, "1bf1a1eb-4f3a-43bf-bc0d-eeec6740e5b6": {"doc_hash": "574f427b14265184c6090778a671e6fe65c4e423821ef2b56f37a3617a4e8994"}, "dd468da5-f245-409c-925a-5fcf27cf380e": {"doc_hash": "610c2866f7b03bdf74b6f645513faae231d97b0a30b65d1a1eb6da34139f623c"}, "26406906-933e-4c1d-95d3-e9ed1e19e876": {"doc_hash": "139728a05a8ba761e38b5f9e6fe6af01a8cfa542423cb983693ea25aa8e0a729"}, "7ee82b10-a89f-43b8-8114-aa631e2d60bd": {"doc_hash": "6728585e408efb5ba8dac9275ce4aab672607533459610ae6ee630cdfc6b31c4"}, "de3923b4-ebd1-447c-8bca-07ac4828682d": {"doc_hash": "ba500d057340d6a9f077449eb43af701129de88c2ef5d56185b55d7cce791fee"}, "ee18039d-52dc-45e9-a0b4-ead228bdff51": {"doc_hash": "b037204ffdb00c2830745475180b9c9221640a9047fa5b632291c8168bb363d4"}, "70c76525-7e7d-4049-b5d8-3f63a012f784": {"doc_hash": "0aee4937a8779a497ff0097a8bc28896cf1385823c1f22275b849fb720dc601e"}, "85fcb5e9-b1d9-4123-82e6-2817dc6ffc41": {"doc_hash": "d6a13fab23f0ad49831231fc94e60089f2f9140ae2a1fb7d7da22fedfeb9aaab"}, "ad85347d-56b3-4b9e-b525-1c68bb3af2b4": {"doc_hash": "61dc0c0ed8801d6a9de329779fa1bafd57a22fc02a82b35c28eb8d5c14f482dc"}, "056228b5-64c0-406c-a793-4a764ea7c966": {"doc_hash": "ce235cb9c8f1c54b82a495b0d79891e3953505d52d511421e0bd0c9210aec161"}, "433c2ddc-f2fc-4fe6-81bc-857d2c867fbb": {"doc_hash": "66e2ff5409721882ba7ad558323fd246804e2f5e4c9890e1783ae280c10dd817"}, "93449ef4-22f0-4dd2-b16c-4eff22225a23": {"doc_hash": "957ee4c39ae3932546e139ef3d574a3db06d6a5f26e1f2cc4b29d82c8b846313"}, "39e04556-8133-46da-82af-b94eaaf9246c": {"doc_hash": "165cc071eb5fc261bdb161651f413971109c69bab5e566546697a995fe233d6a"}, "62b84c1a-fc21-4f5a-9a62-3c2112825822": {"doc_hash": "9e30ae8a45d3dd0fb1a2e2077cdd7856b3b44fbdbcc6837c9c682e033ea07139"}, "71f82895-2605-4b82-95f3-b5868d02c89a": {"doc_hash": "bc04c684a9499dd8ec706bcddd24488db5f27c92f302bbc584e1bc6016b7bc97"}, "9d95ad51-9696-49da-a394-e7c7ba6a42cd": {"doc_hash": "72bf29dba3918cc203795b76b875c2157dac97ee6362b0628792fd32f57ef721"}, "6ef4f03a-25c7-42ed-832e-f02835e75036": {"doc_hash": "a8c502b2b9080c8b6bf55fd17efc65d2bc9c5c27fca0b9d2d7a9bfaa5c8c2acd"}, "8a74fd72-a112-47ff-b2b4-c9b2234f04e2": {"doc_hash": "bc3d345b2fc0f8fc120d24bdc73c9d2932edadecec8a4b314a26c41eeb59a017"}, "2f04de43-4fc8-4069-8263-547ae79352ce": {"doc_hash": "806ea853ce43c7137bf890959278ea26c4fdf7aac9291c14fc9ca8344f666f3c"}, "c0559dd5-4c70-4267-8023-0d08aad51e56": {"doc_hash": "a99d5b765b3b9901bbe4d175de0441ba344b6bf0850b18949280326ff30c2e8d"}, "2c076cb7-fcef-430c-8641-30f6ed41c927": {"doc_hash": "d5f6c6fadb52c83b1520ab271d60f27705994a698915d5d727fd016c0c7274f7"}, "fa6bc619-a56b-43fd-865c-6472c19bc6ba": {"doc_hash": "ec8d1dcedfe4c200deb1920bd0b003a41b8503dd3a45b765d0e371fa0e278f7e"}, "b1f77d73-ca31-4d05-886d-1ac6a8d9b504": {"doc_hash": "e9fe8bdd4367444bc482a2c8b38dee9799a080ad1b0e8d46518b4535e2612498"}, "b970750f-1675-40ba-b19d-4d2f957a5c50": {"doc_hash": "75b253cf2f17851e713cb8afdfb3489b97b3d8a6f30400a435bd21d71318f465"}, "8e44d0f1-9c4b-411a-8fbe-5bc482d4d881": {"doc_hash": "f85092971ebb30748320a0d9b3b9186bee34856f20f68766df21306a52dadd13"}, "02190c46-16c5-40a9-a186-d5a23f7b61da": {"doc_hash": "c1f5e8541a14b349ee12553e09f121903132dfa8165a540d51a5ea1865fbfe5a"}, "98dce572-7468-41d5-addb-f2a32905a70a": {"doc_hash": "13a8d45142f3266c2a410d74402a8286be1a3fb40350553efc763e5c997f9bfd"}, "b8cbd1c3-2bf7-4f46-ad77-ca7a8303e3be": {"doc_hash": "442ba27a47bb69f6c2fc850a3e35ffdacee9e89e703e39fa5636951291f16ae6"}, "81341fc4-5c06-4e33-a5b8-7c2e955c5caf": {"doc_hash": "bbedf81fccf34d015ce11f9ff05a3d5795de6e02cb413a8d4fb81871fe5a81de"}, "3cc395af-f75c-4492-a756-c967a6b6284b": {"doc_hash": "b358064d33dacaee3359a8d8ff547a905780107af3ac6be9819662807ebcf7d2"}, "b84ad7be-dc5a-42d0-9a66-24f4f26179fb": {"doc_hash": "cbfd64ac05f83b4adb27d89510e52fb3dbfa06c6a91971fa7f9c3ac52fc80af6"}, "c9c4d5ce-90db-4058-a256-709bfd81e7fa": {"doc_hash": "8091ed68ab3fecc636c683f45f6075af90543f95626f7ccbfba5a8723f4e9ef3"}, "4a354c2f-6277-44de-98c5-e384b3ae276a": {"doc_hash": "97e01198a6e81350d1c6155a52cdf99af068ed8185a3f69225c51bddb7db783a"}, "786e4627-7138-4261-abf2-d6e78d2eb035": {"doc_hash": "8a61ada08593b531afc1b55244a0f680ed5e04c1f988e89257613a50116bdac4"}, "65b12f50-b533-45c2-bca4-b35ff946d9a6": {"doc_hash": "21bd7ec4adc9ae0df8a567791e28ccae150691f934c6e66a5084299bd3170917"}, "44935100-ebd2-4717-a006-836d1d4588a5": {"doc_hash": "97229f1e4f1953588ff5d095dc1b891f72336cee138fdb0a318985da6264a3da"}, "d0918ce4-809f-4013-a000-a014386408d3": {"doc_hash": "0486fff6a7fa650f0786ffd39d091616f2d601a2db0f07f4b65620716cfba58a"}, "a76f9c33-a3e3-4d08-8f60-36cdc658e598": {"doc_hash": "a240431dc1d69e68db901474f230ef27d0315ec494d24387dae2a2bef82fc97f"}, "b2470960-5eca-4cc8-97e1-50f28c3bed68": {"doc_hash": "4712b1eccba9e053fb7a36337aabe3d7f608fd19c6a688197d5f8a38269449ae"}, "3c378130-152a-4b34-b40c-2c5f5ff5fcfb": {"doc_hash": "8efa656e947dcee1e9d95b632e6c0590aa3ba6bb879c6f6a104a939537ebaada"}, "d4c1d5b3-4e70-47a6-8200-e01c1da468cc": {"doc_hash": "c1a43b92709df650ea2f1c965060d93d4cbf4a783f3638c73ce08123e8007cbe"}, "7502d682-0968-41fa-b55d-5819eacd8d62": {"doc_hash": "f9abc2b23629740c093c1dd66b3a0872ece7e194400fe2a85a5f383e828668a8"}, "054a4d03-49f9-488e-a175-d02a58d43684": {"doc_hash": "0d08225769ac76a13d84a371f390d1ec1d6b5f23848ec9ff806441101a607ee0"}, "19b4116c-3dcd-4ac5-b3cc-1698f683978c": {"doc_hash": "5ec942d98249f5124ef76fc1706815d7be5cf7bcc46dd30ce5ef27f9fb37eb64"}, "22e1b81d-b8ab-445f-a1dc-cdb48180e8d0": {"doc_hash": "d8839fde88c1688aa3a481e02bd3e47f1b07330a48fd8930687fddc24b3e3e98"}, "c3a5fde2-555a-4d11-8ebc-a55b5a25bf74": {"doc_hash": "4660814a84c95b61aaf30ca60679452fe9a51c9639b03c90ecfb67823c1c347c"}, "1313a23b-3cfe-46aa-a8c0-b25a18daf5d4": {"doc_hash": "1083b8dcc8a85022447ea8993662c87a911160427b4e542844eecdee79f40a9e"}, "0602591e-396f-465a-9c22-d5c36a90d6cc": {"doc_hash": "6663f5882057b7c96b3ae869405096318ede3240b60ec9396bc133cef7d8ac18"}, "ebc0feff-aaf6-4ffc-ac64-2982fef76e83": {"doc_hash": "f1b861db7863cce4b0705da13c34623e556a138cc85016e92a816bbcc4e9a718"}, "31a4e240-38b8-456d-a455-3d5248c6e1a0": {"doc_hash": "aaa95b549565b9deca03ee9a6d9ae125c022679bf802982cb7ba9e9b22099796"}, "b7f5453b-2915-46a6-ae88-7942b1b94adf": {"doc_hash": "ff9bbb1cd7dfa70fb2e3748f6231aa644b2a326925208200c6e9ea7022b758d2"}, "2e42ee72-4454-4064-a16a-2eba745e40d8": {"doc_hash": "f76e1e192bc16142b1dc66de71e41cfdafe450642ab5a57338677ba29af37314"}, "cb272b09-7494-49ae-9d3d-1bd5094576ea": {"doc_hash": "ec10efcf81f370c7fb7c801142b0a7da9ad772f394948632d5353e25a54510b8"}, "74a1f56a-7bcb-4762-85ac-f6af487535ea": {"doc_hash": "79330dd3518991feaf21ce37c67383bcc0fcddaa1da1830e380c4e88e6c7adbb"}, "de0fa9ea-7a5d-4b63-bbbe-1a31b5f1985a": {"doc_hash": "bf4530913e79b7b9891399d65adab1fde6b523db5c19e890b88e45ba6b1a6cce"}, "a21839e3-b820-439b-b5da-b5d43688d75d": {"doc_hash": "38be6536575ca35435fc4cf1a6a1a04037844b85c13f11c3d1fda1b394f286e2"}, "0ee51a65-8fcc-4525-9c0c-78d5067a5322": {"doc_hash": "126012edb30cdc14fd82639cf3bf13366deaa827b51753453c548d799f7dfb0b"}, "125e959a-cb4b-4a7c-9b73-5f80b61a74ca": {"doc_hash": "4130c618058b210e0166fe65d43673489c11cc16e0286c0bd628da83d3772b71"}, "2047cd2d-605a-40ce-8b89-ec793a70d05b": {"doc_hash": "b7ff0d9dd8ff9d08c2a77ef46b880919e89a3603579465b651fb932033bb5a31"}, "54eb0dd2-0372-4480-8700-2b2ab5e05d29": {"doc_hash": "389ac6a8ae1076818d871dddbd3aab5cbbfe1da17caa843f9c099a7315c967f6"}, "4467e687-5999-4b63-9101-fe9d307cfc80": {"doc_hash": "d2b09b8c892cac76d62cb1bb7df8ad201f0537ce0c4b8145b60a8f2a60f260dc"}, "6b6772b3-9022-4a46-bc80-adfe89c9accb": {"doc_hash": "2301bc89b7be7760daf436fbccb239c4d68bacf017786cf65509d52e8d29cfec"}, "40fbc029-2ad0-402e-81cd-8c0efe287788": {"doc_hash": "0585e95a99d872137412e0505501b191d426d9a5649958b827627dd4b5fac464"}, "58c66e14-f22b-4a36-ab1f-9f57d4b818f9": {"doc_hash": "549f6ef2cd987ac2734452afa0537d82ce07ee872232c79de3ccc2ec79d051d2"}, "30483c99-d763-4ad5-b049-71ea752763cd": {"doc_hash": "833e8a4578d69aa43ba7adbd4ef4fd00e9ec2ba16e566f3c645e838259322220"}, "6a51f9e0-f740-49ba-a5fb-21f5a4664960": {"doc_hash": "4a10a0d5b33eea9f285904611cd5aed99ae146889c91e9c6acbb82a5b9c76eb0"}, "bd21fc9f-2e9d-4dae-9aa1-0127bd7991b0": {"doc_hash": "218cf4866011d196a83c7edaf8f387cacde411318819bef300fc37abf7b39221"}, "ed55d837-9d25-42b2-9f2f-0988305f31b9": {"doc_hash": "057de893b8d46eb78027e43f30ecc081544c4a7b16c1b66a0cbd667dee8d053e"}, "4669cc34-fabd-4371-afd9-07fc961fb99c": {"doc_hash": "0542e5b68245da149ecb00527d76fff38db5f968620af95095bcc1caec7b3ee1"}, "0c453eb8-561b-4931-abe3-ea257e314b77": {"doc_hash": "cd1b6f876999622d3df707769d14c4037cf2b6f4e583f40898474b1092905935"}, "a5eb5759-6fcd-4fba-a0ce-2d697baf268d": {"doc_hash": "bc1beb563952301be3534766a5201c1110b6cf5651496950fba41d046ba9f8a3"}, "4a760229-465c-427e-aa06-ee9c11b9d741": {"doc_hash": "f9821f4dbae9b998daf5431ed7f1080f0fefb8901e2b54eaeb9f21c777e1f7d9"}, "5fa5cbaf-0f35-4b9d-adff-e85c226123ee": {"doc_hash": "ad03d881a38faabf604fac07d14645f814796790837f25c85bd6acbf8f1d7898"}, "47fea022-bdde-408e-884b-15d4b71026b9": {"doc_hash": "0f2c471f349296e90c89c0c70b16890e881a203cb1a902945b49fc5267878dc1"}, "801c7121-6498-45f9-9982-5ac4493b7d5c": {"doc_hash": "a012e70ec7d969f854a561ac9e36422cff3aa2e740d9d3ae4c02e5f8b77f32f2"}, "7770cd55-5f3b-4e8e-aee9-ecf39b046832": {"doc_hash": "a3644b8cefceed6ec9f7f173407b54b8218c190a54b39ef05f93939abc5226bb"}, "2de75324-dbdf-4dfd-b349-8d4646785a32": {"doc_hash": "703354e3699707a253938e44028b22d13caf251a4d7de66ec7002fcfc8231876"}, "771c14ae-b222-4117-b39d-2faea750ee5c": {"doc_hash": "d7adf863256be61bbcc8cc5c8d3153bbc2f76dd1c7d2f8bba60539af5bd2a4b8"}, "fdabded4-fe83-400b-bec1-ce4c30cf9b1f": {"doc_hash": "78a8f3cb6310ea6f1c4b793605a4c6237a434fd4309897e3f9b3f3a06d048775"}, "6505cecf-677c-4d91-bc21-4c3a911f2ac0": {"doc_hash": "04f843bd6e6feb8e708ec3f62bc80a6bef2d0ea01bc8b95167f64723ba9a5b88"}, "453763d3-5a2c-4186-8f6a-d9f423a3c22e": {"doc_hash": "070246027df44d6566f28cfbd8dff1c033bf36e368524e981a7c9660fc49d10f"}, "dcc12e56-bbb1-48dd-90f1-330686f8779d": {"doc_hash": "eccc10d69d04dd0d402228df59c4019bbce270da7c34f8a5d9e7ec94832c03ca"}, "2228b889-4a61-4d0e-ba33-07c97eed0389": {"doc_hash": "318c45904750e3580b904e8efb4c8e84551b17302035050386482224baf12546"}, "78c46e43-b93a-4000-991b-de6110b1ed12": {"doc_hash": "542f8012ef4d9c2c873866d937375b092e7e14e9f309ef76b27fdae653dcf9f5"}, "e9f123f7-660d-4d8d-95f8-5e0bd024443c": {"doc_hash": "3cca960fc3db5eba702a4e74c0d62f1b81cc6c3471c067a4987e961ad37ab414"}, "abf11ad1-2619-4914-abcd-4ecc455d6b8c": {"doc_hash": "81d281abf8d11060774312b4769475486027c0e653bee18ce50a81d557d98a1b"}, "5044523e-0216-4f21-8097-9a0e34005ebc": {"doc_hash": "3bf74cf9cc933e3dc581635ddc1b7e164e24c64733c8caae56376bfcdf53f6d6"}, "ff71afa6-6817-4c42-ab3e-c84632ee6845": {"doc_hash": "ba91f30caff14af6bbc551dcc14d507e5bf0523382dd3b035a31614848d301f9"}, "b373300d-6b21-4b71-ba8b-5169cd22a3c3": {"doc_hash": "d0c1bd5e6c0ac385fd1c3483c9d4f52a751827cebd4bd4f78caec1541d07131d"}, "43561dff-5a70-44c5-b85c-6b103665a579": {"doc_hash": "70a8bf5f99747417628f60047a9e25046e6a77095aa012214c0ec235a5474829"}, "006e6506-be88-4e19-b0f1-9558e4ad6ade": {"doc_hash": "722140cb6a3ce4edd634042892d031b8ff9502aeff9b92873dfef4a4aaf80a24"}, "219da5b9-f055-48e9-92b4-22fdcb947390": {"doc_hash": "ce7583eea92f46d523f5b40e10f008023371fa23e00929712610e6b64e795d44"}, "9b86a7d9-96a2-4e58-8f7b-c20667c1ab1c": {"doc_hash": "6839a3d96fac4434b327f1793637eb0e7d4f503053c7985a8292c47b945ae314"}, "5e5970cc-055f-4ad8-8118-51172040cc69": {"doc_hash": "16c430638d3a0544627e01b36a75a777042a9287f19fc1b8068e40eccad9348b"}, "65049405-5ee7-41a3-8f7e-1f4afd67da15": {"doc_hash": "f3c8c689bedfa7af6aa8018fbbe8b0f5fa604edbc7635624bd9128a8942af4d6"}, "16ec0902-93f5-4310-af1b-cd584e6ededb": {"doc_hash": "03c90687116b8ac3d4fa4038e95513525c3876f34161a69e6887b10e954069dd"}, "82077a3f-5db0-4220-969c-766bfbb80958": {"doc_hash": "7a529ed43d8eb253c689e482c1eefc8d793f6daa13a00f16fe020e232cbe0c46"}, "2e04468b-1a5f-41cb-870d-d63002ee17b0": {"doc_hash": "56ea910611e7496cad4ba590fc7add35d3a0cdbd21c302cecf9fd8b68d73fae1"}, "0f936c7f-ea99-4cfd-b7a7-b526a15c0154": {"doc_hash": "1e02564f14794913d15e4d05bc42843c480c121a210cee053e3629b4a0c68318"}, "cc638242-a014-4e20-8438-82fe9a902629": {"doc_hash": "d33bd4ebb05eee9f7bbab6b506c2ba0e723223c48519d607bdc40449cb5ea49d"}, "d1bf8d3f-e168-4b22-9b78-5697e1d92ff0": {"doc_hash": "c8a8df235f410d35badaeb2cd2138f805e9047f5afd7b2bb8ee4cd1f144c5046"}, "dcfe059d-adf4-4efe-8a11-0f5df04bf137": {"doc_hash": "b39b948fe752c3d69627a80eb316b286a088a9c6dff19ca05468a957779f5cca"}, "4827f7da-38d2-48b3-a83b-74a0ae6b0dc1": {"doc_hash": "8e7e671373bf25e926c43ab2db7f27d81e8438f2741f6c823da90eda7f5e54ae"}, "a8b9a87d-c8c2-48bb-8c79-a7e914af3279": {"doc_hash": "cb324d099071be2155869275417aa321741c48f9b63805286b8c12d57815ea02"}, "1c34a6ee-41fb-4374-bddc-50a460a096bd": {"doc_hash": "9171e0eb52e05db814a877362e7ff4a950861fe4101526d631a6d85754343d69"}, "d7cd9798-cf09-4395-ad0c-405565c47cf3": {"doc_hash": "a9961b7e2769c4fa95ed273702a4f668ec6293eb206d144c0681013d7e257749"}, "dac92a66-6742-42fa-9bc8-7aba5d6e50fe": {"doc_hash": "42238beff82abdc00b85e2598350302a6b17edd7d2336ff59fa8aa56790ffec7"}, "c619de16-f76a-405a-b8f5-a3ffbd2dc920": {"doc_hash": "fcf8d2f4ce0940c444787c836272ca05a04432b9d3bb76de523345c162fc9b27"}, "ba32a073-fa17-4a8c-a508-de75fbbeb558": {"doc_hash": "027f62eb75349c967a58b395c4ee493d281b0fe658833234a5b8f504b5584121"}, "53f8a2c4-7e3e-4024-994f-05438c19456f": {"doc_hash": "56b372e32ea7ae43d3d30fd38d30f9cd7116f2ec6627fdb3e87a295c9c2f1ad8"}, "c504291f-7c6d-44d7-9988-612a6d4258f9": {"doc_hash": "2a8d86d9f6cd20a1028251b31008d8608de7f1e1ced9cf5f1e982389f6a01b62"}, "2118b02b-9f5f-4dd7-9770-dadd54219e2c": {"doc_hash": "5d38e432e8a74471890f22a5ae828bd44715e10e1ddd7be98451b53df38140ee"}, "79714208-495e-475b-82be-9cfb3eb94965": {"doc_hash": "f261fd63a52dae72ed32e1ea0cce487c3000e0db4ae140e06a445f2aac8ff4c8"}, "ec9808bd-3e73-4956-a1ac-0c8c8a442f16": {"doc_hash": "665aede2ef3cb57443068dfb7b00ce75ce345181a7b084ecd53a41d0fed374b3"}, "6a35332e-c12b-4487-89cd-76da8b0f779b": {"doc_hash": "667d6be65647c5c50031838cb0f9cb05e8e3cb50f0d937791eefcf3f5c3d3529"}, "1f82455d-8268-49b3-857e-ddabce1c25f3": {"doc_hash": "8e66f27e73f8b637313be3cd621b75827c531be4b76a805e53b9c2bd9674ec52"}, "6c29536f-9969-4ac8-bac4-763b731a23dc": {"doc_hash": "70fe88d6d5b8bc08110d6bdb3050437c1aa461803a80ecd5d411fe2e7c29ddca"}, "506d8c87-e9c3-44ca-8327-d43785ff89cb": {"doc_hash": "629a444c3bce07deddf219feb4459d88fae5b77557c8796e7f98547ff5851f64"}, "e86330df-b5ff-4404-83f7-a532df4a699b": {"doc_hash": "2cf27147274a87374275273e477f02fc94b3f2fc77aa1a3200008cec8d392d64"}, "93744a9c-4c8e-4e45-9656-52c8de55e605": {"doc_hash": "352a026f5b538d5b1baefb40b6146189621816f76885bc8c711d4c6d5eb6e6dc"}, "9b5fa849-f425-4f79-b3e3-398d7afaaad9": {"doc_hash": "48588b363fc65c7cdaa575b46286fbeb0b70e863cf5c6b4917027d7f71f84745"}, "a65e5de8-a726-46de-97d1-d345af0493a5": {"doc_hash": "80f8c3b98c9f23b102d9f345d856abbbed952a7e4b65b0b9f43a3e5af3191b6c"}, "2eac5e37-3290-42aa-afea-3f7b49c5c4ef": {"doc_hash": "9991892d2129766f2a53a15443af2bf2a8819bfbffddb1a02075d4283bc86f4a"}, "1b37e028-4d89-4dc9-acda-2c74831dfb45": {"doc_hash": "2c48e2e8fcffec25a5daa9594ac2be269fbddae1e59103a374f15b9e9a7a195a"}, "6fbcc5a1-f232-4cc2-829a-ceec375b222e": {"doc_hash": "17bc8cd3c65579eb5307ffaf2910dbf62e0ae7d0e2497e9dd83dd0a7475cbd69"}, "1d433be7-3fee-40ad-9096-0cd30d082d5b": {"doc_hash": "7303613d6c4c235a2844ee5609b017cc8552d932c4bb38df4b34c431a31989fe"}, "3c19b45c-0bb6-41a7-a513-2779f900200d": {"doc_hash": "d82da1b38f60be153fb779ed9ec70ee6e0c3ce591433c11aa25f7c73bdf70933"}, "bd4dfd55-fd52-4ad4-8f18-cd0eb92628bc": {"doc_hash": "2972c876d4b380d79f4f1faffb8092ba13210d2d120e12ca15166542be994908"}, "a65c6650-1424-4f55-aa5c-4fd7d807d0d0": {"doc_hash": "648634bd86b6fd20fbf7ff8ce305ebf3c0e4b5f7c2e89b365027d200b6aac893"}, "ca0210a6-bad3-4baa-9c51-0358f67c1f53": {"doc_hash": "2ac7b2341f60a70485701f647218b252f21959e20a09096358f92cf530f88dd7"}, "612883d9-9db4-48e7-9fac-2123087fa821": {"doc_hash": "be1bb97b4ec9d7cbad8b841ff08a5c889061213dbab3e667cffa2a2d22f6ca71"}, "bb180876-b6e2-43a5-bcd4-0a64793d24f9": {"doc_hash": "505979c28cd88823456e526720f594add108f2fe7667fc05fd20ca47bafece6d"}, "c624a7a2-6d17-4bc8-b14b-41fdb271454b": {"doc_hash": "b22f3007c2e407df634f7fe8537d1d5cb2257c58fd9cbf5196403aca280d2753"}, "bc0eff0a-682f-40a9-8944-28d0548166ef": {"doc_hash": "26211da61e240278afa0d45a5ae21c6426204a86df75f303455b581acab33e00"}, "8babc670-40c0-456e-a794-1e2adf262c9a": {"doc_hash": "c073be412cbdb16d94011a7ecd477ce7eab14baa79441326e731c2277457e673"}, "164a7700-9271-4c3d-8044-44e3699e41d0": {"doc_hash": "5ab85e5013180f48749accce02705747f6ba34ee0581413ea04df0ac269c240c"}, "d724225e-4bc5-47dd-9c3b-2dc28ed0a986": {"doc_hash": "91960ef6d07120503cfe8a227bcb6dfff24705cd5c13d75972c5eb1b4c0879cc"}, "f850c619-c7d4-4836-9993-fdebbdbc4e72": {"doc_hash": "df668b41421590519955a4b79b472bf0d96cb5e5c8785346d425febc0eb20e5f"}, "5447f475-1492-43a8-93d3-515de254e4b9": {"doc_hash": "46be03f22e4af10a3cb37198365e5ec82f3fbd9d7dee1fcad8f3ead3496d4522"}, "e50b4eae-c4b7-4d03-8794-6590c6f9515a": {"doc_hash": "b7bb2015a5362e52e54857f3912642be2fea8b0120c7bc58f7ed3b344e9c7e52"}, "89c0f327-0181-4262-961c-712fa3bd3f5a": {"doc_hash": "c16706256eddbcd6350b4b899bd86f3c5f83d2dee5e27c96816f791add2c838e"}, "bed8baab-41ea-443b-8c2a-2472e90c7933": {"doc_hash": "dfb1f684c1f40c86a8c5b71c2d7126fc656877942234efa3913987c6f4d5804b"}, "ed184b12-df96-457d-830a-cfbc3c39dc36": {"doc_hash": "4281ea40d8e38724bd13c8d62b7a4170769c3efc76e406d02b8cd0e98afbebe6"}, "f9207ce3-2046-43ee-b074-875e1aec2213": {"doc_hash": "98ab2b2f1bd46c4ec99f44ca9e3ec7dbedc74acb46b4aac631e1a5b578c00064"}, "e195a8b7-9bd6-4243-b50e-99822347643e": {"doc_hash": "457856840d75bef755c8347a51fcff3c718963336ae71207ef2610c556c14f78"}, "a79b72e8-af14-404f-ba34-9b8740f8428d": {"doc_hash": "7e07fcb0a6703ea0b6eac3cb85c752a25369127c3a489fc5640949a1ac385dc8"}, "6418bd1d-1814-45de-88d7-f307c2bd82ff": {"doc_hash": "246e2b521a44c4ff9ec917194a4a8004ebdde2356db341c74861565d34002b64"}, "e2b5a1f2-ca1d-4174-bf53-0fbf97b69197": {"doc_hash": "bebd3d321a1c5825113f6bfa8aaf33cf5215ecb0ac81b9db86b86d908b4cb6fa"}, "25ce72e4-5cad-4303-9831-a1dbb3eb2339": {"doc_hash": "bbf62110a5c2be4938f4235860c98775d6dbbe68052e95b68ebb23d41b19694b"}, "8d9bfff5-1578-4007-b762-1832b4a0c23b": {"doc_hash": "c236160797ede09cbe88fe7bc62afb62b43c427b1002969b33cf0cfd192cec48"}, "394a4f45-1d99-4702-9dc6-c9b89e15ec30": {"doc_hash": "ea3a6e9cefb9821cbf8bcde1cdf2c329b71f1106688569d1d974296c51064e4c"}, "09c08890-5471-4e32-baa2-4ec0d3faf3f8": {"doc_hash": "a10ebac3750a3bc48cee936055ab6dc4307d8962b63f8351ac46ec1bb4bb71d1"}, "fc26abac-1325-4bd1-af3b-2facd5b378f5": {"doc_hash": "592f1c267b08cb8e6363db97eb5c0515d17d22f9dacee20167305da1f90337ce"}, "6aa69ebc-45f2-435e-bb1b-cad241b4fa23": {"doc_hash": "b6a97c149411124adff4112d2eab3f20c01770ba645efd2fac71f44b3b2bc996"}, "c1abcc7f-2a36-4100-b728-fa8f385ba7dd": {"doc_hash": "84a89956e0decf42c5a11a84bdfb30ce582ec5759c863cbc4306362808cd5a7f"}, "a701e63b-aa68-4f04-bba9-c33ba763d6d5": {"doc_hash": "d497f9565be1b01ab6a0d33499448e60f737de4ad5e543d8064bca0c93da1bfd"}, "420c3b95-a64c-4c5a-af4a-709f7826fc14": {"doc_hash": "694f1ff009f923e5ad9244ec8c7aece7b1e1f81e1ae74153007c1be9989e6ce9"}, "4751bee8-539f-4dfb-9718-f789534598d4": {"doc_hash": "afa16fb37752f0695b254a16a652ba042e4f4787b5acaa7f283da2108aac367d"}, "46eb1b61-a236-4070-b02d-965650d9309b": {"doc_hash": "dfc1ef28727296b4709b22ade9da506fc64e08e41c2a1e2a68137100bc9741ba"}, "00cf25b1-8a6a-4f6f-a217-5e8331c3ff61": {"doc_hash": "ef202bb9af34036977f34478c374f5c376e9dab4d568c62503a23cd1c83eb077"}, "7e5af48d-f5ff-4b60-b450-6aa543a5a171": {"doc_hash": "8dec7dd4939e7a385eb3b873d0a6eaea80efb8840f3d573eb291f7945719d38c"}, "9a04f9f7-e932-4822-8df6-ee97d6abb2b8": {"doc_hash": "9e1aab0d6b76eb42a4fad8832f2cf9139f6717d81ef118398ef30100c1022762"}, "5847202a-71f8-44f2-abde-5792dcab65e9": {"doc_hash": "e3cf12803d6123883eaa6a7f085c6ae5258295c9d7adfd5b2a7f8baca9b6c253"}, "03671864-c2be-42ec-87da-4d24b70c26ab": {"doc_hash": "626c4c6bdf71f3e019b0eb331fc9dd7346cd1e4e39dced46419ad978ec9b190e"}, "5fd6a050-23f3-4e8f-bba0-71fa5e7cc222": {"doc_hash": "feabd62abbd7359bfd17c84ff02a65d7f2f45b56ce83decb299a696a8967bfa6", "ref_doc_id": "ee8c1bea-b1cd-4fac-b9c4-9abe2fc7180a"}, "fb72f441-a712-4d13-85be-497de0ea4a6d": {"doc_hash": "ca864de7512af8a11bf850465c16b1a3ac776eb50613d1004acc56c7fe64e5a1", "ref_doc_id": "908670da-f9ca-45f4-9c87-18f5a25f1c50"}, "5c43cac6-cbd5-4310-8d7e-644c79ea84e3": {"doc_hash": "849cdffdcde446dc1fc46f51fea23f1f9cf2826f2748f9303299d2706d08ce93", "ref_doc_id": "39782762-0920-4ecf-8385-840e2a25cf4b"}, "ff004526-704c-4adf-ba86-191b44bee19c": {"doc_hash": "ef6f3073d21f8bd227247e501fac1b026a6b88d282fee34efc67556491775237", "ref_doc_id": "443f616f-d00e-4fce-9d52-2f82b3787301"}, "90fed81b-994e-447f-bb57-a58434d07c40": {"doc_hash": "99ca50f38c6bd4159067f6b1ad6ee20018d462155b172134a6416ac22a156f73", "ref_doc_id": "c6039319-063d-4f6c-bd97-c2a6f8f29be3"}, "7d19dd1f-4d1d-45bd-97b3-213043675326": {"doc_hash": "ff8306aac08755c342d042df6a4195bce9a6152df785aeef879a16cc36ae8ff8", "ref_doc_id": "90438811-6318-45c6-8a9b-31a4dda94448"}, "0ca2eafd-f502-4632-bebc-2a9004268225": {"doc_hash": "353b4827799c0780f74f429b13f6aeb2845acc9b51b0613d3bc5852d0fca270b", "ref_doc_id": "1500300c-2874-4b87-8451-6e42a046b04c"}, "148b6c1e-85d2-4094-a823-08943ef9ef10": {"doc_hash": "b51b12a0306d18a4416c4e772b4db3928da10ac7b4a389d72fb1e844aa95a4de", "ref_doc_id": "c2f15d98-332a-4ac4-84c6-2e069e9c4d2b"}, "bf194c77-94d6-468b-9dca-33b4a00b4341": {"doc_hash": "f46324a840230141708807326c2208898d8393d2d0e2925ef5e735cc62778353", "ref_doc_id": "cda8dcad-3165-4e73-8ef9-913cccf2a532"}, "7d5f954a-001c-4940-aae0-e524882b0dae": {"doc_hash": "f5c11883cab4bad0548bca319bee073ac235d8a2e996c5836f642c6075559b58", "ref_doc_id": "f12b1ab6-bf1d-4a1f-bb32-08050ed7ffd4"}, "618e1434-de1b-4c78-aaa3-ecde2504bcdf": {"doc_hash": "06d0d29a06b9e3b026481f23f9df8bc0d3f6469e6a12fb17a35f8091bc79bd60", "ref_doc_id": "2cd0d4ec-de93-4c86-8e23-2301b9df028a"}, "f93e4978-3efc-45f3-bf8b-3c250e6867ec": {"doc_hash": "196359a0b840f3bbcb5855f5fd72b7e4d2b17b5707afa32ee46dbb9b9d76200d", "ref_doc_id": "e05e5cb6-514b-4eb3-aeb9-fa3339907cfa"}, "ed204267-d82b-4dc2-8b63-c2808d43a436": {"doc_hash": "944aedc192a0657d3e165cca1ffaaf0e19a9f622bad80eee434643cf6cafbd15", "ref_doc_id": "86c4df41-67bc-4b18-9531-991ec39cdeb4"}, "edf53007-1498-457f-95bc-41dd176e8e3e": {"doc_hash": "3361abf5b0958d745b04d601b424c33eb1791975454ecba48fb714fab203afcb", "ref_doc_id": "6bb64722-3854-4de2-bf50-7316a8a7a149"}, "74c99f97-26f7-43a6-89f6-4fbf174fad47": {"doc_hash": "1ec8f6701508011861644a9f481cca0e6ad911a8c294709a541825c78586a2c4", "ref_doc_id": "1bb4c179-ec9b-47a4-85c5-3d787bf7001b"}, "ba8a6241-8f23-4f5d-8ff1-97e13b7dfafd": {"doc_hash": "fe0f5a948d9027918949cbbfb03ebc0c83956f9a4e806a4bd30dd46d185fbb6a", "ref_doc_id": "07dc62f5-fff0-49d2-bdcb-0b4caa795372"}, "9aa01e0c-b6eb-4167-b102-d2a752dd3ab5": {"doc_hash": "df6785a61e2e628086ce1af33b6d04628c55afad3c5132e0db105187162a9e26", "ref_doc_id": "d63598fb-e347-4caf-8874-4ea073ff89a8"}, "6046a625-2392-424d-a51b-7200fd7c676b": {"doc_hash": "639ae309bce0afee3c7b7aeda0b981b6d800284a941f332736f800d72e42d88e", "ref_doc_id": "2af8bedc-9d1c-45ac-9d9f-5674e6253616"}, "fb05732f-c330-4e38-8be4-afd27dd0d467": {"doc_hash": "c7b4f5dfe4bedf1c920424c3e26a1545c71d4223ec17c11dc20d8d78ec26d602", "ref_doc_id": "21660e10-5ec6-4d81-af4d-b8fa01baf94c"}, "7ea28507-8d34-4264-9ec3-e83c3cad6fb6": {"doc_hash": "c1c642372533e6c1f8deef87300e6d5a702fdd02ee5f2cf3fae98ceaf56138ed", "ref_doc_id": "21660e10-5ec6-4d81-af4d-b8fa01baf94c"}, "90119cef-21c5-4c91-a649-5d34c669eac8": {"doc_hash": "983f202aa6aa08617ad0fc34802e4c45d6fc7a7d6119f93e68e664685f0052fc", "ref_doc_id": "a90ea0d4-c27a-46de-8738-36937bacf466"}, "8c1900a7-2428-4b2e-9813-b0d9d95d16aa": {"doc_hash": "d051bc11df28d4a2039ae965a85af396c6c3119fb615f15335443f0c064768e4", "ref_doc_id": "884e2dd3-ea7a-4e36-8ae2-8f62bf050531"}, "a9e68bf4-38b4-499e-b31c-49260b0f25e8": {"doc_hash": "eadd7744d74bd7aa752d1baee05473cf5da9ec0eb646cae4710212509202c3f0", "ref_doc_id": "7b7763bd-1f87-4b28-b172-88434a0a738d"}, "016f74e6-4cdd-4908-a670-9ce88db38ac8": {"doc_hash": "6a3625ab934e81f81b5a70286af7ef39a415b991d0a4aa55cb83f502bc843ab0", "ref_doc_id": "93f63f91-a2cf-4c98-b1a2-af9134983d98"}, "637df4d8-3bb4-4e1e-b56b-a672fb78cfb3": {"doc_hash": "7f3643e6b27df7d4df7a7a96bfea656484ceb9a88431d43d8b7fc243d014e043", "ref_doc_id": "4958c287-f737-46f2-97ef-bc6944efaed9"}, "ff91cb92-24c1-422a-ad85-3083e163098a": {"doc_hash": "10c6e59d4e5d90f1b19e2b58727d9061ea2ac94c7964d64e7ebe00546cbc905d", "ref_doc_id": "b5ab2401-83c5-464c-862f-fa9f6fa74f56"}, "32016a56-9bad-4a2c-a89b-f65bd22ed4d3": {"doc_hash": "b30f59bf8ce5878590136e1a72a0e5e4083163df2d13975cd6dbea11181cd429", "ref_doc_id": "0227c4aa-7239-4e62-bcc9-8e90f5b2d44d"}, "a91527a1-0c42-46fc-a00d-51e48e160a99": {"doc_hash": "5c7091ec31d32925a41e98f73192b7c61618f0894d6fc2dbb40581a748b14630", "ref_doc_id": "62a8b884-ade8-4a27-b6a8-c125f915b95d"}, "ca903758-010a-47e1-acce-16a4043df791": {"doc_hash": "a1de1364729f4a91e0fc78a64776b2c134e2cefd0dbe4296f4601eac62742e13", "ref_doc_id": "9d2dc5ed-5e92-475b-82b6-56268780b21d"}, "591cba89-9e7a-4331-9799-e9b3e319fa38": {"doc_hash": "6be9b5b5a5837a74d05266407c3ee78355d0088cdd52908f77896eb4c8813862", "ref_doc_id": "ec91b65d-e280-46b5-a777-e84d83560d98"}, "70ad93a9-8073-4e58-8868-d8e7559ea8b9": {"doc_hash": "d3add560c9cd876df04aa45463bc1923e9319db5d846861d3ead577749b0f658", "ref_doc_id": "d47ef1f0-3a24-4e62-98eb-f2d4f4e64515"}, "447bc559-f776-42b6-8228-7e330d6aaac3": {"doc_hash": "8c2b6117d252339cd35bfda71942b1e9ec4bf3f62697995d3ef19d4957c9784e", "ref_doc_id": "1067516d-07d0-42fc-a9e2-b5cc0de4fe9a"}, "212eb7f4-b59c-45b9-a864-ddbb25f66fa3": {"doc_hash": "85c9b88f4aeb6686e0c6f338edc3bae15ec7c9e1e793a3d164ec86142f5f008c", "ref_doc_id": "5048901c-dd23-4034-b49a-059813f62608"}, "3c076ce3-5021-413d-b07e-b3da4772a6f2": {"doc_hash": "d7b8aa4a7abd2500892a89a83f4697f0ac94c43edad8dcd8720e53caef732300", "ref_doc_id": "13f2e3fd-a955-4360-acd1-9761ef014aec"}, "a7a68eab-bb2c-4505-9414-26af70c11169": {"doc_hash": "1387bb6b79d422a9f97b8ebab3223c8083175a58a6c19b73231c06411367c849", "ref_doc_id": "5f65fa5a-be1c-4d4c-841d-71826c3097e8"}, "77695f86-93ab-4b06-83d1-2e9f653d542d": {"doc_hash": "44484fed01e7f407b410acd6a1307e6f680a349d1c5c5fe9d4021741e39b3c5c", "ref_doc_id": "3b6461a1-c383-4500-a9e6-43f39b6458ac"}, "6c6f7fdb-ca10-4a39-be7f-0e905c74f8e5": {"doc_hash": "2c555544378d5254e59f5c7cc2fa3d3d52d26d36d320d75c586abd1c6e7cdccd", "ref_doc_id": "1299ce80-d804-4efe-bd44-49226ac327f8"}, "c4a68a3f-5adc-454c-9329-d04beb315b66": {"doc_hash": "1c01045e97b1eb43d40f86769cd842aa4564843a733dee703764c3c2b6750d1e", "ref_doc_id": "9f33c3e1-1e3d-40bb-9815-0ab96dee0e26"}, "dd007594-e618-4623-8115-5975ec5a9c56": {"doc_hash": "42ed7f13b95431171914e148851e32d08f3d660ce9493529f6e0f766bc0ee1ca", "ref_doc_id": "6fafa2db-d580-4bd6-bf08-2f3b424d1c97"}, "2693d643-cade-446b-b4d9-b42ad94fc62e": {"doc_hash": "1870692b70f5d96b08a1efb8b39bc8502d84c66fd4b662cc362521be066c7696", "ref_doc_id": "94eee232-a3ad-4b0f-85ec-afbdc0d5d33a"}, "f459b952-d907-4aad-a92c-b71613ff6a4a": {"doc_hash": "07253bf825fdb9a20be45130b1a62a3de210f78183f3d118b6ec47ef3ebaeff6", "ref_doc_id": "202afc63-7d82-488a-9137-97ceabee5814"}, "8b50f6ed-9ce3-4b2d-9c21-aa7aa9122050": {"doc_hash": "0e3369d806c9e963bc977392c2c21a464cc1280cec24a0b87ead1162dee9efed", "ref_doc_id": "d33a7aa3-a7c9-4dd3-9912-e6e18ed4ca90"}, "e66d3f9b-af1d-40b4-99a2-21fa95e2f55c": {"doc_hash": "e5101016ea38a9ed6b87fb4ac70b89f2e3dea664f1d7cb5a22a194f3d651a665", "ref_doc_id": "b0a92881-a03c-4afd-8067-ad2ec5a13701"}, "57091c68-9147-4261-86b7-9c91562b01ed": {"doc_hash": "f57eae88164c360d6d4fda11e1c903732743447ad6c6403e9c1e6526d71abf6f", "ref_doc_id": "579f3294-8ab7-4e22-9588-33471c4a708e"}, "c63bac2c-818a-4f66-ae06-44032bde8628": {"doc_hash": "a03c03d33f18870393734a6a5da70f092e78b2b099a764e41d480072af21ba23", "ref_doc_id": "ac29e2b5-71ce-4c38-a656-c33875238965"}, "200ce9dd-cd00-4851-a923-7824a527cf44": {"doc_hash": "63f2c6a329432518e5e3617c8b451ef57e2ab05e01c915bd1aabc4c8eb5bd89e", "ref_doc_id": "a84485c9-b380-493a-b067-094fdd376094"}, "9918a549-33d8-4cc3-8582-0b6258c2cdda": {"doc_hash": "f4a3f02db1ce66a363084e83f618cc4bfaaa0424cd363efdfecf7bef409b3371", "ref_doc_id": "756f8435-bab7-4990-938d-0a5c79c41202"}, "61111df3-ee09-4924-88bd-a283ae67baa3": {"doc_hash": "a4657554b83ab82dae9947c8361073fab760ed6bb6511c9b4316a93810cc6fa3", "ref_doc_id": "a7566768-83eb-430b-8927-cf27b0116b87"}, "38186da5-60a4-45a8-838e-ae5dd6b24b89": {"doc_hash": "0a3af4b341de0d036db9b2945886a89da03dbd288dd369ae2bfb61cbedd7472f", "ref_doc_id": "947440ab-25f3-4da8-8d46-0b6010cf4c1d"}, "215b168b-72e7-444b-93c7-933264a3875a": {"doc_hash": "93f5d46ab6eb5ea1c618dae9c633bc3c00b716d75ba384caadc2b11b390c342b", "ref_doc_id": "11392ab1-c733-4b0e-a3b4-51b914143cd2"}, "4b8efd40-5180-4c76-b048-33e6a84cf9eb": {"doc_hash": "b2f1a1ca46b100000c3dc0ec149f08efdb0bd19504ce15c625215a3dc62ed46e", "ref_doc_id": "677686d6-dcff-4e7e-aa22-8aab50d5c9d5"}, "6d498364-56fb-49a3-92d2-30f2838277de": {"doc_hash": "39b54a8cfd61751072a1ce0988b51b2b05196d69a726f3603071fdb24674c15f", "ref_doc_id": "282ac654-91de-4776-80e2-e59a4f83193d"}, "344aec64-60fe-407b-ae79-06d2111587c0": {"doc_hash": "5eb08348596185d8f5aac1492f193a569d7f6db729df4d31b9c73d0c020112c4", "ref_doc_id": "31631f53-39eb-4bab-a03d-f24041756d15"}, "6027dcb1-2584-4d20-be83-dddf8b581639": {"doc_hash": "b64a94b3a6ca029cbadf6cef39dae2699785adfeba0e57061399589199252c44", "ref_doc_id": "c4ff6a2c-3797-4ee0-bbf5-5b1849d8c328"}, "57ad1753-d494-445f-b1be-3187ea8a43ba": {"doc_hash": "92fb7e2e4de59250dcf6cdba501b0709c7573d0b35840b0a382247013d7633d6", "ref_doc_id": "b20bab95-1850-421a-a785-1f6b1665520d"}, "9abf3c38-9bb4-49c9-abea-0bfd7aaf0920": {"doc_hash": "5f924614aa5b964d9c661d0e3b5ca1225d93fc37418dac11aa90a6a269269f20", "ref_doc_id": "2eec6d88-96a5-4ebf-80ae-3084489084c6"}, "9a4d4676-2fbf-4d82-8233-21eaa4bd674c": {"doc_hash": "e5309ead1ca590df86c9a6787b790e7d30cacb76e65dabb345b7ab94d50cb780", "ref_doc_id": "88dc04a6-a0a0-43fb-8661-a06c018980f5"}, "7add000c-a7f1-44eb-b8c3-e658482e13ba": {"doc_hash": "51be0a95d468e1f5c1ac24955b2161d076de8ef4cd6edaa8625d4bc570f74377", "ref_doc_id": "6d13b8ba-18bd-490f-9c2d-9d549550d782"}, "a4513569-7d04-4939-9534-49c886c375b2": {"doc_hash": "0eccb1e22692ba5b3dd669bd0887bcb6d50e95fc5cc7e9fecd0094e4dd5b71e0", "ref_doc_id": "205d6cb1-d53d-4cb4-bfee-6d7cb87d2c02"}, "45483488-f867-487e-bb35-5614a6143edb": {"doc_hash": "ef35bf921cdfa40277390cf00a18693aee0832b663d62cdd5247e819416b8bce", "ref_doc_id": "6c369cc3-8892-4b09-a524-b043d002b7a1"}, "a5ed50da-540b-42b4-8a51-03e1b47f79ba": {"doc_hash": "bf284550b6a15a19f5d3302dbd05e78c2d58cd409229aa94e63be80d51927e55", "ref_doc_id": "6306ae25-5d84-4f9b-b0d8-b5c649ac9a23"}, "7b3d3d1e-1041-48f6-a443-50b76cfacd71": {"doc_hash": "059dff54965faa1b64cc0e8e2867e531c6a9715fc3814b96a0624310991485f3", "ref_doc_id": "04c427d9-e2fa-41bd-baec-a4a7a317660b"}, "28726f90-f670-4016-bff0-fd983af10963": {"doc_hash": "c94541c393e9c5d78400c100806649891c263c89527456bee11e3423d7eea621", "ref_doc_id": "aab510f8-68e5-4a6b-9dfc-bc62ea31bd0e"}, "28a2bfc9-b7ba-4b20-bf32-12e69a7d5117": {"doc_hash": "86b2e2a4ce770463d625d67f1ea352e1273bab2b07b3407ec368f09bc251bac0", "ref_doc_id": "6ef1cfef-1436-4538-bdbf-ab280b7e469a"}, "88966cf8-3991-4ddf-81e1-962fcbae103e": {"doc_hash": "3dcda19cb7c6c55805ef3168dfdc6a7091524d728d9010be59b380b10044b9a3", "ref_doc_id": "f72abc19-8b18-4335-8881-c297dc1163f2"}, "d0ef0f79-241d-415f-8ac2-2541f79d1f1a": {"doc_hash": "718762089585c1bfd68cd9e3ef55f8bfd3f404114c67347d36d51a27406e2ad4", "ref_doc_id": "0cae6ee2-b850-44c1-bf99-694cee68a4b6"}, "fbf33eaf-9f7b-4509-b47a-611f4d7a50aa": {"doc_hash": "823e152fe9477d87fb5d142b93b24489dd51bf8110d0077b97a162dee034dff3", "ref_doc_id": "e2716b63-d299-4465-8e6e-d976bf37e9d0"}, "57b62286-fd01-47f0-8674-2b80a9fee898": {"doc_hash": "d2bf689b618c9b0905df2a69e19b7e6e30ca2c98b6e665e6ba4f973461ca88e4", "ref_doc_id": "6bb63a31-b4ce-4b00-8efd-307768f04424"}, "4b27a462-6514-4a2e-9d97-0bbd7039f65a": {"doc_hash": "4780ac4b07bdc42e92c9477c0fca92cd5778b102d7fdc2243900d9b4822dbf9a", "ref_doc_id": "e3796c9c-ffdd-423d-8b76-118a05663bb5"}, "7c5075f5-b0a0-4bf2-8a6e-9e429113717b": {"doc_hash": "74da0444d1aee825c502f1f94914daffb09ede7cf5576ad926de9d81d068fb46", "ref_doc_id": "2a55f44f-4fbf-499d-b815-f9c2877a8d0e"}, "5a2a09af-531c-4eaf-a0cf-72b66d0392ef": {"doc_hash": "26c658974ea255c3e10529c952858ec388d7e5e9e71d551a8ba266a44a5ab720", "ref_doc_id": "7361c261-b009-427a-81ba-edcfdda667e6"}, "ace66c16-e8e3-44c4-adff-1260bfe4f840": {"doc_hash": "85b3f24f494d0abac44055feb37ba7cbdb373e6a5e3cd63d6d258cda1aae177c", "ref_doc_id": "e47aa32b-4c2b-455f-a134-d242e27199ed"}, "1801eede-81f2-4a73-8714-3929e604cea9": {"doc_hash": "058c3c916e3f4f5a71c3d69d138557c4aa8a8f8bea05c8581ac86251afe82ec7", "ref_doc_id": "00d870b8-cbb0-4d7d-a350-496c3e19a1bd"}, "1c749976-1c14-436c-9927-d5418b73805b": {"doc_hash": "7314d3fa13e85a6b1e9d96d9a058c8f3bde0cd3d81dc0d16709452ba6211e550", "ref_doc_id": "11382185-80cf-4e29-9b32-e96ab039e973"}, "64fd41b5-bf91-40ef-9675-a2b23bfee199": {"doc_hash": "258f45e3aa416cebcec1348e412b5f8d6ec81a8d992743dc09477a78a4ac4bee", "ref_doc_id": "6c334337-2220-4f84-a1ff-d0d977582906"}, "257afe00-9c68-43ce-bb95-d0cbca2e23d7": {"doc_hash": "d17e6f1dae77f9289d139eb3225c2073ed5a80393eed713e59447768d95d1bb1", "ref_doc_id": "0b0fe093-dce4-4605-9bee-82c42074f1eb"}, "f6fd86de-3321-464e-9e49-b7875248ed94": {"doc_hash": "e7bee5378648dabc4d392b47cf0e9d1aad890a0f8bf9a6832fd9cd696f083fb2", "ref_doc_id": "8f18e61c-5f3d-499b-8a20-e029fb61b208"}, "b86c41ed-f1fc-4f91-b92d-74ec2c7034bf": {"doc_hash": "8ca2480524282b871613fad90b32d4275cffb9e96fbdd55af4b1ca658032abb4", "ref_doc_id": "c62e1dee-ebc0-4f4f-98cc-5c99dac80529"}, "026546e7-181a-4206-90ed-120461f65c38": {"doc_hash": "2719727bd197901d35632338933c2f2d93e5521cc0cc3dcea34454ea005e60ce", "ref_doc_id": "2be3e37e-fb2a-4504-a589-8c14055853ef"}, "c3b6ca63-6d23-4976-94cd-8580e6503e61": {"doc_hash": "44785b28297e425efeaacbfc5f5d1fa3d56098695a30041f1972435c28206d70", "ref_doc_id": "a3f10417-72a7-4462-8ee0-440e39a24ab2"}, "9bef5dc4-21d0-4a5c-ad87-6e432cb56ace": {"doc_hash": "74772995820a5332530d9a854b856539cede919b3a930fd2023497dbcfc6f209", "ref_doc_id": "f95d67bd-6c0d-479a-a872-3674377bca97"}, "e4b5304b-823e-4445-a1ea-c0cc4cd38fca": {"doc_hash": "699caa39a95c9cca77aca85e32f80a0636c4155a2736a4131e099c79e6156a8c", "ref_doc_id": "8c6dd48a-7701-46a7-95ab-162bb819468f"}, "910cf0de-fab0-477c-b7a4-d647114bbb11": {"doc_hash": "8ae7237eef46e3a6382a538fdf39d93f22ab187d3ec504f5562da9e51099c5ca", "ref_doc_id": "bc6e6f88-5eb1-408e-8ad7-6da71f6f1d38"}, "a13e8beb-1ae1-40b7-ad66-8d2e8ea13cf5": {"doc_hash": "e13318f07888b53a0ff69820bdebeb5a97badad622f394ebccdc02f304fc48b2", "ref_doc_id": "d1a63777-02d6-4af8-a809-2f8ae6e6475d"}, "c75ac5eb-5803-4ea7-8192-05ce627f6249": {"doc_hash": "80a0b4056526d8532ae996182bda28a0eda799310a8b41ba86718aaf81aa0721", "ref_doc_id": "3b458459-4dd9-4848-9549-85e9a77fecab"}, "dc21147f-8e07-4809-bbb4-8792f4b5088a": {"doc_hash": "6e1c2a97c505547f066494b518e3e5b8bafc181a31989a05ee7e70abfde35d72", "ref_doc_id": "51ba3d9f-a608-42da-8e73-50f9815acc58"}, "70b61591-5818-4d13-94e9-62d98f34ad86": {"doc_hash": "3f0f5d0dc55d54b6505c4790eebbdc8d14511f511d23cec569e433207429a090", "ref_doc_id": "7aa44a91-4a05-4638-b083-d7b567e074fd"}, "308ac43a-fba8-466d-84cd-9f9786d45512": {"doc_hash": "42a083e97f5d9fa0ce706677f8fee1f0ac8736120dfe4a914495ada91f345ea0", "ref_doc_id": "d69fed16-ef9c-477b-8162-5398ec0becec"}, "fe3a5b11-1735-4d81-80bb-c036ba11cd84": {"doc_hash": "3de2ba2934d4b656af309879506ba4582f811eb16f369e15919bb44d6cb834b9", "ref_doc_id": "1e28e0d8-a45a-4ecd-8fc6-3ed34c463e4c"}, "47b56d4a-735d-48a2-af71-73aa8af48557": {"doc_hash": "c0f1b8901d2fefd8d2438f2fa4e3567683bbfe4e7c5023f4462221ff82f274fb", "ref_doc_id": "2385bce1-9781-40a9-bc5f-babc5758b8a8"}, "3add3fdb-f4da-465d-9169-f29febbf1824": {"doc_hash": "69a5994ad8b4d84e6f077781b7c8d6a0deada6b5c3260ade724bc6915b2f0478", "ref_doc_id": "917359d2-353c-445f-b663-2fc3df9b4709"}, "38b29421-6026-4c4c-b185-215d46bb154b": {"doc_hash": "2925582d0ede86556ad31fb8df24a657181da3aacc660bc8505bf0364eff41f5", "ref_doc_id": "94e300b3-0998-4e9f-8198-6c6f820d2e82"}, "41398e86-5b6e-46bb-9a65-40961ace4da2": {"doc_hash": "11e572e35166ce91a0b2d0fe6c4f25deeacda1b7760ef7f345483c84ae21b30f", "ref_doc_id": "cfcc63a6-d0c1-4c7b-8a51-557bc0dc565e"}, "1d4a1982-5b0b-45be-ac4f-83d439dc303d": {"doc_hash": "719b8d0eff8b81936b39b201657a59dafb2f09f5514a51e88d1c149d47821cf1", "ref_doc_id": "4f20e1b9-764d-4ffe-801a-19a51b1058b0"}, "7c64cfd5-b8e5-47b3-84fa-baf21fe1e41c": {"doc_hash": "143eb55c76f4df4b949eef19bbbbcdb38b823d1e8363405fd8b33791d8444216", "ref_doc_id": "9858a4df-7f4b-42c3-b033-6606454404e6"}, "1a367c53-3325-4cd9-b266-96204893392d": {"doc_hash": "791eb89f812f148d1a53d6f150a6a2e248c24f8927f22a052e8fb6752afba278", "ref_doc_id": "c4fd46da-c327-4201-bcc8-65ff4895ba5b"}, "e26bb185-e570-47be-a374-daba5dbb7c3e": {"doc_hash": "035932d8f7560a88006a5bb403091a864ada87a8106d19beb690ceb09861e431", "ref_doc_id": "7c151f85-8ba8-4b98-a167-a53fde012914"}, "b8fc69cc-e537-4446-8f33-b45ca411d031": {"doc_hash": "830be97883f29e8055bcd258695729aed0b33f9237d22272629f2c0c44e43aed", "ref_doc_id": "19ae540e-1254-4853-b078-e61060a4a0ed"}, "d4efc45a-8e92-4637-a8ee-bf6e15e1ad60": {"doc_hash": "101d80acc6ba34d95c2e56fff025f65905497db42550536ae607494a9798cca2", "ref_doc_id": "e635531f-c20b-4860-8dfb-420b960c5f8e"}, "fedf6bff-f687-4b6d-9dc0-7008c00d49f8": {"doc_hash": "ed0c9f30e6b3675f78ebc630676ef275958f7585b620ef9beb1026a14479bad9", "ref_doc_id": "cccc5fb8-ddbf-42d8-99bf-3d47d736af84"}, "811695ee-2228-4c8f-951a-82d7f4f45c3f": {"doc_hash": "4e7ccd1cc1504db558044f53b7fe125f2eb29c4f4803d90ac1ef208409d57279", "ref_doc_id": "9769d996-c1b4-4dd9-8234-fe2515e80255"}, "55922c6e-79a7-40a3-94a5-c57015dc53af": {"doc_hash": "a6b094a6770272e7cc1734b63e9576f31c8f89ebc2f50470788793c023f8256a", "ref_doc_id": "f055d117-26de-4aa7-8381-a2a3550eacc2"}, "cc0292fe-89e4-4ed0-88a8-8bf84434944a": {"doc_hash": "24332b8d22ac7e7f7a8f4e26bb8539968773e054c82fe42f6ad208503383c502", "ref_doc_id": "ac98703e-178c-4344-a053-9adda47dcd16"}, "2a4423e3-72a1-4253-84e0-2cd14733e5ca": {"doc_hash": "7e766ad19ab62ec23bff22644ad2c148e47d6d5ba815e87b5a83efdac828d7c9", "ref_doc_id": "4e01c364-e826-4134-a736-fba73609950d"}, "7a9b4fa2-7c27-40f1-bc48-435ddf6117cd": {"doc_hash": "ef7916ca0b5d1fd77ae69316d1012361da0b57ea896e80a101be6ce12f3b625f", "ref_doc_id": "95463265-4f6f-4c31-8d48-990df80674af"}, "de7a313b-87dc-4714-8e67-8cf20017a4cb": {"doc_hash": "984f2823b97fa8ad666ea580bac2b011b087e289539aa6965ab21de118557256", "ref_doc_id": "7a1867b0-ab52-48f8-951b-fc43bd32f774"}, "7d0b50a0-ea1e-4a94-a0ec-8d3673980d30": {"doc_hash": "d468dd00e74edf89990d09868c988eef7514f4299db7eea17bbae73e7abf8ba7", "ref_doc_id": "cf77a9ff-f7c7-4593-a369-cd4fcec74f2e"}, "9bee9f1a-6dbc-4059-936e-45558667d141": {"doc_hash": "a5ac7ed2039eb13265964d3fe2907ea052c70447f9ec1ef50078b4108ed7d75e", "ref_doc_id": "2998f37a-c9ce-4c33-bf4e-52eebed61bb6"}, "f7f3b1bd-ec07-41a7-a936-404f27f1fd59": {"doc_hash": "809c7664df7e80ec6333eecbd7bb33ace8ea9dff227ff967ae93421aed0ff56e", "ref_doc_id": "5da6ead4-b24f-43e3-bedc-9a77b862fc9e"}, "50083219-d212-497c-b454-93b2d826fccc": {"doc_hash": "2addd6402f305120777124872314ef274333d47b511fa5085fdbd3e50500dce1", "ref_doc_id": "c99c0473-2ee3-4626-a83c-889903223a8d"}, "19f48a1b-65d0-44a2-a1fd-a556bb4a4104": {"doc_hash": "34518027d00c14a02b8f91328cfe75cd7b55e85d264e22e3b67ceada1da65300", "ref_doc_id": "e1730e91-dc77-4608-9b00-c63130efd0f6"}, "0dfedaa9-28bb-4e38-8a0f-c221bbadde41": {"doc_hash": "4de0a2ba73f00436246c28b4dfc0bfceddc4b7f46372409df666c04f12fd4208", "ref_doc_id": "623359d1-b398-4a1f-bbed-a2188f071c4f"}, "d30f5461-bfe9-419a-b9e5-13e7f817d3eb": {"doc_hash": "fe3bbadc48773661a09034f5ef93b9c22206a77863d1fcb8d7c5eb460cdba037", "ref_doc_id": "c7fc7ded-4162-42fc-89f0-25bebb2072f7"}, "a4a4c01d-1d77-499c-a26e-93f5724f836a": {"doc_hash": "605bf36d1990e1fb9f9bbccf35b10f202ef9d831243f6dfbb0ad36bdc26d3383", "ref_doc_id": "cae08c35-58df-4cf0-9034-118be5bbfe65"}, "cefe593e-4bce-4336-a105-086bc6a1b89d": {"doc_hash": "374ace0dab40bdf87ecd1d357d42925195fcf45641c20027788e9d96e576a61c", "ref_doc_id": "f8790928-f542-4321-b081-e518644dc5b6"}, "50b1a5fc-76fd-43ae-8d2c-5b3d523b43ff": {"doc_hash": "652434c9958ef2b08fe89044c1be83accbc7ba817e65171a9cf5f96bf7b84603", "ref_doc_id": "83b2eff1-167f-4ecb-8fea-bc10ab4531af"}, "fbb6629d-83f6-40c4-a33b-90071643c471": {"doc_hash": "751266b1b079761dc8f4650179326d22bdfd6a1c0b28d4d4e8f1b7a873e2e7db", "ref_doc_id": "b7d86710-14f3-4128-9055-d2f74d49704f"}, "5ebf07e2-6f73-45de-8193-13b4a5849c97": {"doc_hash": "233821abb9d31a1757a05d65cc07c98be514fe9092d11a27073bc9144a2f71d7", "ref_doc_id": "9efe19e9-92a3-42f7-a2fc-591df5e1f4cc"}, "23efc760-5dd5-464e-96d9-55018af5a877": {"doc_hash": "85ba8467bbe66eec591f5cdd04c2830e1374dae30d9f0ce5fb7bab3c0173e0aa", "ref_doc_id": "bb774b2c-b190-424c-8f29-da6e433a7ed6"}, "fef84c92-5054-4ef0-98e0-b7ad804f8ec7": {"doc_hash": "03708043ae218c644a74ff0752d677e58a3308d675060e249dbed3920dea9490", "ref_doc_id": "03c17ce7-f7a9-4af4-bbda-4ef034c1775e"}, "432a45aa-48e5-4043-98da-b8ae68632fa1": {"doc_hash": "1372f304df69199391e4a4fdc5645d8fb26097fc6227e586f98508750424f235", "ref_doc_id": "8c47a83a-cece-4eed-9754-e87cfa1311fb"}, "28e15324-5851-42c0-b1f2-0a1e1ed4cdac": {"doc_hash": "f28117e80bba1a02f45eefe41f27d2ebc9d51808c858d357bae834101b61396c", "ref_doc_id": "7c325cb2-4c75-4937-b03b-0621439135e5"}, "03bc875a-d6e8-455d-b9f1-86e01d0d4765": {"doc_hash": "ab419e1cf7c8155374256b7fda77c10c5ac523a68c41f71410cf58652e3e0d8c", "ref_doc_id": "b8310bbb-c7ee-4550-875c-c54c445580d8"}, "60458e4e-0c67-42c2-8310-81e5d8f132f1": {"doc_hash": "86e0fe2d6e79c4d2ea0bf40a4220d8c48b8fb7f1b5469ba6125b950075e67d80", "ref_doc_id": "a1e3b10e-6074-4a02-b32e-9d69f689ab63"}, "58a8ba9a-b614-4721-b5af-93142e365307": {"doc_hash": "8966bfbc73b09c28568b759342e7dc703d5f2dba2c85418cf0c8bf72fccf4d82", "ref_doc_id": "befa605f-8e9c-4682-905d-bb77f58d0fbb"}, "cf70cbfd-5bf7-4388-9cae-eab7d813a45b": {"doc_hash": "0e005134d435bf92cf47df10bc1b9db604d0bec4e7c82473bb42a096735d4e26", "ref_doc_id": "d74a49ec-52f8-43a0-bbdf-8b110eae4626"}, "1d73b0c5-6806-4d5b-a54f-52874070537a": {"doc_hash": "917d1bbae924cfdf4bf0681ec7f1fa0ed657b8e95c3fd6b63ba4d996170cc98b", "ref_doc_id": "d1445793-9701-4b67-836d-6945c31b6fab"}, "78962a20-8d36-4f05-8fd0-b886d95a1ab1": {"doc_hash": "c1cddcb58872ccb1b31df5696ad1376bd2bbd46189609553a9b6066e2e05e101", "ref_doc_id": "208c29fa-b14d-4b20-8c2e-4cfbc76658c1"}, "1a164fab-96ca-46eb-9814-08452d18b867": {"doc_hash": "5a79c7808fba34adde4320aab54585ea5cdbf6ccab69b52cb273e09c52ad3c31", "ref_doc_id": "c58902b7-d175-49cc-b12e-e5d57bb46c0a"}, "e63d0cfd-7b4b-4a0a-b5b1-1a3f856b75d5": {"doc_hash": "13d659e7b8e62f3c5d07ef2d5dd3db5e4495fb9d6a4c470d3ec72dcf166ed33a", "ref_doc_id": "5acc5950-7cb8-4531-910f-c539038168b4"}, "6ff857f1-973d-43dd-8b89-960224fdb0d1": {"doc_hash": "9ede982dc20846841702564662173f3e0ee2b4899192d467556d6b4dd6528a89", "ref_doc_id": "a94512db-7ba1-4546-96c5-46c118179f66"}, "bebea504-4f0c-43b7-9b4a-7ae822f8033b": {"doc_hash": "4677523c3411b52ea5fdedbf5cc89038986a5cda4c309597b6d2b73859ac7139", "ref_doc_id": "42247bef-29bf-488e-9c35-cfbde445f7c2"}, "722b1b8b-a4c6-4266-bd9b-adb38c05e779": {"doc_hash": "bdddb00bf00f3777b886bc0dc0b873e3a6479646af7478da2afe2795603eccc1", "ref_doc_id": "7a5223ad-8618-4c77-8174-a0aa8c67cbad"}, "ebb78474-a429-4968-9c44-9ffd62980a32": {"doc_hash": "bcbdc7e4d7f1aaa88b8a544ed645a8c73722e0e6f807782fc1f5a1fa8d1c68bd", "ref_doc_id": "9198039c-fe34-4d2d-90c9-dc39b8a80fc4"}, "6129bcca-6dca-4c47-9abe-fef3ad391a92": {"doc_hash": "5682f83ef8b65ecaabbbe3437f0fcb08934c33c9c8020713641538b567efa009", "ref_doc_id": "91ea4229-4514-4e32-9db5-c1b1c4643864"}, "8585ac52-3bee-4b6e-ad4e-42950a64eac3": {"doc_hash": "4c422cf0a85c0ada7584d042d0039eedece568b6b31641cd93801b1131c62109", "ref_doc_id": "8b4d949b-1c03-4f6d-b762-181d5bb8aaee"}, "46a697fe-c86c-47dc-8671-bbf42a63fd10": {"doc_hash": "938d83e5d502bab411e782942dab0faedf6821477231b7570636a811843bbc42", "ref_doc_id": "7b31efe2-ee89-4579-b759-61dbb22030a7"}, "b45d6705-cd5a-46b6-95bf-fc2590ceae85": {"doc_hash": "506fc411518b9754a30d644f14f50324b611a9870d5a9b909beab30b69166e96", "ref_doc_id": "6c261d99-e848-4553-920f-ba01e4a108ab"}, "455bda67-681a-4c2c-b3f1-a46656284212": {"doc_hash": "14f61c0bcfdb710c076f99631e4774b143c480106fe4c4341776f2842b0880af", "ref_doc_id": "490a1ee7-85e9-4f30-b09a-3b5156bde184"}, "eaa38dc3-16d5-4fc1-bfc4-8bc5201ef35a": {"doc_hash": "9cb5fae4ba60353b6ec6155be356eb1ef8b8793e482c447a2670efec9e3501bf", "ref_doc_id": "c0b93724-2c51-48ea-881d-a675e7b84f73"}, "e4397436-7339-45ad-b584-1eaafff7c407": {"doc_hash": "db0aac84d7ad7390009d8c4cec9a4cd3b1abd4a277400434a748c063932336db", "ref_doc_id": "80cfdd44-fcd3-4767-9605-e28c5672c4ac"}, "eb86d96f-7552-402f-9542-3eaad70ad36e": {"doc_hash": "8ac300004f748b18f5fe9a27b3a5dc2a850985cf0a15f4e32621764772a86bee", "ref_doc_id": "5ec31165-dffd-4cf1-a2d8-43fc9def9a40"}, "eba67ed7-ccd8-454e-950d-0b2daf8be6ce": {"doc_hash": "f00ff83c72b7afd2ad215ae1855fa2837202a089e9c8edb476ad60ff13ed701e", "ref_doc_id": "9767c140-225f-4161-a0f6-2009754c94c8"}, "1b154b3f-58e2-48d9-bb8b-072729a01454": {"doc_hash": "e3b7c3b784117517d4b8a1e2b83a339241fb7d41d66b60841b3dec1058f56266", "ref_doc_id": "947c0910-1b00-4ba5-9046-be95eb1f44b0"}, "9b8022da-08b4-4471-bcba-100c6996adea": {"doc_hash": "2c13302b475d96e485372a5a81e4295847cfa6825795286735a60f6be608ae01", "ref_doc_id": "87f281d4-5221-4688-91fd-022e020b9131"}, "9e49aa4f-872f-4e52-b4d8-2d427dd64a6a": {"doc_hash": "de2ab164afe3780701b30a1375ef8816558394aa03332b1a2c85ac39c374ec43", "ref_doc_id": "7afba3f6-4616-4a9f-a8dc-77603366355a"}, "5cf4292a-f5f9-4d89-954f-d622498eb7c8": {"doc_hash": "d9ba706192b7aa5066c2e029319de552f596af5b726d2bbbd659306aaa4530f1", "ref_doc_id": "275b9a1c-df4e-4a13-b66d-aa0d91623187"}, "a5e7ea33-3ab1-40d6-bd11-65f09aee9b12": {"doc_hash": "9d55a6baa36b78113ada7cf3b8621a12f6928f96a7503530b292316d8fc3ef45", "ref_doc_id": "7030ba58-c661-4098-a404-e8982afc283f"}, "7696e8f3-bd2b-4bee-8522-e042718e1223": {"doc_hash": "3c264b4078261d7b4f1ae2bb233bd642c35cbf9cf592c99c98644d35c07100df", "ref_doc_id": "dfdf4f76-0f19-41fc-ac76-c1885dba6401"}, "1b4e2318-b2e7-49fe-8557-fd1eb3335a2d": {"doc_hash": "5319bdcef8c72432af922f600339ea7ba4ac2c4c89ac35321fa0e91951f98fb1", "ref_doc_id": "9cd1c731-02a5-4eb9-a77a-c2c47a97fde0"}, "f74db465-fd34-4fbf-8c47-54ebe58055bd": {"doc_hash": "f379f00b3ac4786296fc1c6e9507fd8a8e11a81b81b4ac7e58e0bcb057625b3f", "ref_doc_id": "2fb81f50-58ea-4f20-9d89-f9b46d015d60"}, "e256bf26-9f69-4769-9b27-936bc70c69f6": {"doc_hash": "23362827890ccfd30bbe47161d4f84cc018c16ac29741fe65cb9eca6bb2a1f5a", "ref_doc_id": "0f9e27a5-ff6c-4fc2-aa7f-7fee480f1057"}, "39e5dd2f-279d-4c90-92ee-31588e96d480": {"doc_hash": "69dd95ca408ba53973582d06f887492a227bbb36a8d5b3a073fac33fd3fbf29c", "ref_doc_id": "738137b4-f8a0-4cf8-93ca-a82448c99510"}, "e48ede79-a022-4c5f-be16-db06f3238807": {"doc_hash": "d79b2ce41952c3636dcf93ecf659cea8ad78fba2262a81a8b43dd63426b5a365", "ref_doc_id": "1bf1a1eb-4f3a-43bf-bc0d-eeec6740e5b6"}, "3f2092cf-0e96-43d8-97eb-48a58384e898": {"doc_hash": "02f4eed563dfae385543c088d02f1f011c3b711d3689152960b0c2a1d06618b5", "ref_doc_id": "dd468da5-f245-409c-925a-5fcf27cf380e"}, "8ec4eccb-5a2d-453d-bc1e-f9f5d9d33d4f": {"doc_hash": "9bd96b94c61cff5cbe3db749c9dcc7ac3c8720794ee22ae051714bea45f8d2a0", "ref_doc_id": "26406906-933e-4c1d-95d3-e9ed1e19e876"}, "735fba49-276e-4e4e-83ea-4ab6bcd8a376": {"doc_hash": "ee5b1ac93e3d5ccf8ca5d80156802c89ac2497c9c1005ade103d0d17068f783e", "ref_doc_id": "7ee82b10-a89f-43b8-8114-aa631e2d60bd"}, "ae9188c0-56fb-4efb-9736-b8f2e655514d": {"doc_hash": "29271859d95da9460915c498ff0bfd55aad94104f80b90761482fd0d29bf597e", "ref_doc_id": "de3923b4-ebd1-447c-8bca-07ac4828682d"}, "f58d65a3-c321-4cc5-93aa-8755f30356a3": {"doc_hash": "b0a07ad651c9ecb7ac2e35ab0b9aa4ff3b8a4dd2dc017f7622fc80800a3c29a6", "ref_doc_id": "ee18039d-52dc-45e9-a0b4-ead228bdff51"}, "a368c95a-3a65-4ab4-83cc-6fdcbe6aa03a": {"doc_hash": "2dad9999cd3e52db0b07bd75a45cd4fd06f0ea3ce774bbd1e9eda35696c2ad58", "ref_doc_id": "70c76525-7e7d-4049-b5d8-3f63a012f784"}, "7ee064be-b859-467d-81ec-33fdfc3b1016": {"doc_hash": "1d01464d8dc8804627b44a740250cc4f3f5c699b9561d80e3b81910ddc63fa5e", "ref_doc_id": "85fcb5e9-b1d9-4123-82e6-2817dc6ffc41"}, "8ae7c165-538d-433e-accb-f72376223d00": {"doc_hash": "3c816b8a9f122023d1442bab22df95931a3b296c7036def3f1c6400e1dbdacd9", "ref_doc_id": "ad85347d-56b3-4b9e-b525-1c68bb3af2b4"}, "35dbef31-7560-4bb0-ab3f-c4d089df63a1": {"doc_hash": "d11fddbd932ad54b716fc98518965542c94727a974d3fdc48ca7cd8adaa39dec", "ref_doc_id": "056228b5-64c0-406c-a793-4a764ea7c966"}, "274c2e90-294f-4632-9529-8d1bd8dc38f5": {"doc_hash": "08ffb96b0d3cfb11e52ff03f5deeeb257c784142f9ce6c2759447b285e29bfe4", "ref_doc_id": "433c2ddc-f2fc-4fe6-81bc-857d2c867fbb"}, "a7cd0404-ee8f-413a-9f2e-9fd9a855cd2b": {"doc_hash": "d96aef5a43510146fe670c5c0a47dbb86fbcfe1b8c54aed959db9901d8a49a12", "ref_doc_id": "93449ef4-22f0-4dd2-b16c-4eff22225a23"}, "1c4e4b47-60d0-4d35-9030-d35f408ecd8a": {"doc_hash": "569cb66a6191b50ba018e2971bff0667a420ee9fafec058d31830f7d7d6de062", "ref_doc_id": "39e04556-8133-46da-82af-b94eaaf9246c"}, "bb15903b-c9ed-411a-abd0-37decf346589": {"doc_hash": "36a7590c071914190da1c9386065df2903595ca2d8c1f5060393844483e4f37e", "ref_doc_id": "62b84c1a-fc21-4f5a-9a62-3c2112825822"}, "9f318eb7-ae4a-4c0b-bf22-060331433447": {"doc_hash": "207a6e55235e30ab796774212b590ee0c46b1e8573bde7412beb7fd52cd76cf7", "ref_doc_id": "71f82895-2605-4b82-95f3-b5868d02c89a"}, "36d84cd6-4742-4b94-b645-8ca424991552": {"doc_hash": "11278c3fdbd7cc2f65c92b197bf77297c080c1a4ea63ca87917fc205ddfa3c97", "ref_doc_id": "9d95ad51-9696-49da-a394-e7c7ba6a42cd"}, "08668273-877f-4994-85a5-08c17e6dd48e": {"doc_hash": "f0ed457f449c3aacf564e41a7f276ff3c2135fa4dddafa1d7da45e2087088535", "ref_doc_id": "6ef4f03a-25c7-42ed-832e-f02835e75036"}, "7e80d414-ee7e-4470-97b7-d57a69c98c1a": {"doc_hash": "b213103a4b35ffbb662ba9aeb5b75c16be275f0cfff6bcdd82e34f689f53190d", "ref_doc_id": "8a74fd72-a112-47ff-b2b4-c9b2234f04e2"}, "fa263542-a122-4cef-bd74-22d3f1420fd0": {"doc_hash": "cb8f0d0610bb82dafec30702c310010703136abeeec5f449d92e18e5faf8d911", "ref_doc_id": "2f04de43-4fc8-4069-8263-547ae79352ce"}, "20908338-4015-4269-832f-e3e1dcf71509": {"doc_hash": "996775627dc681a4633ef2a86bfe63506af88367022b4d6ce1f0a1d1d0d6c88f", "ref_doc_id": "c0559dd5-4c70-4267-8023-0d08aad51e56"}, "943bae3c-558e-443b-b22b-86c12dbe2d23": {"doc_hash": "243ef81737f1396adb2b834e5849ac53adcd8e13adf88960bb2eae5ca21845a6", "ref_doc_id": "2c076cb7-fcef-430c-8641-30f6ed41c927"}, "25b03630-eb7c-4900-93a9-4cc07507cb3a": {"doc_hash": "e1c17f221a1bb27d2a2210f86f5752c312f67882d75ee5a0a334acf5dfa824a9", "ref_doc_id": "fa6bc619-a56b-43fd-865c-6472c19bc6ba"}, "2cdc37cd-553d-49d6-b41b-8b244d45b0f0": {"doc_hash": "d3352a8157d82c475e4055dfad17a62d3a192659289a8d41354d21643c58feb6", "ref_doc_id": "b1f77d73-ca31-4d05-886d-1ac6a8d9b504"}, "4761f7e5-b053-4411-b9e2-7ba8378c77d7": {"doc_hash": "5276fa7dc18e94be55664d4287f6e59446742b37b49822c941f5bf844fc05f2d", "ref_doc_id": "b970750f-1675-40ba-b19d-4d2f957a5c50"}, "447ce0d5-b648-48c4-9ced-6122888a42c3": {"doc_hash": "278f59830e9be1f98cf40c2118261581ca8a0f7aea309271fcb4d253d2f2cc73", "ref_doc_id": "8e44d0f1-9c4b-411a-8fbe-5bc482d4d881"}, "6edaf77a-8894-4be9-9942-1a1015d8b7f3": {"doc_hash": "561e4bfae721fa23f965bf0f8b6b627dfd439bee9fc8318558ccdff95aaf4f21", "ref_doc_id": "02190c46-16c5-40a9-a186-d5a23f7b61da"}, "6e0158cf-eced-4e52-8cf0-6241543215cc": {"doc_hash": "2c4e9288c07139ba665f0132b4498da620fb6a40738b81491f48848a6337f093", "ref_doc_id": "98dce572-7468-41d5-addb-f2a32905a70a"}, "f788c73e-fc82-41f7-a154-785bc298ed01": {"doc_hash": "21006dbe7cedc23aba5d739c7a5fec0857ee171eafeda8ae54336c97387aac55", "ref_doc_id": "b8cbd1c3-2bf7-4f46-ad77-ca7a8303e3be"}, "a02eecf2-3ca5-4f3c-a71d-b33c01f5ce9e": {"doc_hash": "0f8e7e8f5b77c375ec928356a1286828be3412a0f6c569df63cf1a94130815fd", "ref_doc_id": "81341fc4-5c06-4e33-a5b8-7c2e955c5caf"}, "bfe37647-1bd7-4ac1-b6da-c1ef5086a9bc": {"doc_hash": "a52b06f256add67ebe009ba7a3ba6abe6133f459c8034a6e3c5429129139f8c8", "ref_doc_id": "3cc395af-f75c-4492-a756-c967a6b6284b"}, "9391479d-6527-4890-8bab-ecffb1ce806b": {"doc_hash": "94107dc10f7cb6915a80b812484b712be06b6af287d35e23e8c91f6b759141e7", "ref_doc_id": "b84ad7be-dc5a-42d0-9a66-24f4f26179fb"}, "987c20df-db1d-448f-9db4-24ea8d0f5d77": {"doc_hash": "10443208c74e72043b28f123b9c62a4907b46d0b72d59f66745505d59d749094", "ref_doc_id": "c9c4d5ce-90db-4058-a256-709bfd81e7fa"}, "958e505b-c16c-4776-bd32-24d1724a1fb2": {"doc_hash": "91318a30eab122ed9db6b158e76b57d1b8e56fb7f25761258924ecca917dc305", "ref_doc_id": "4a354c2f-6277-44de-98c5-e384b3ae276a"}, "e94b0750-5dfb-482f-82d7-9f1b5715c82c": {"doc_hash": "9a7b7e3c2cb13a1779a472b8f160355977d56ddeba86b576383c37f0d35e6183", "ref_doc_id": "786e4627-7138-4261-abf2-d6e78d2eb035"}, "89e965f1-da2d-4990-8fe5-c8cbbb6af07e": {"doc_hash": "1fea191132cb4058f0469df273401f11e2ac2b8679f0c03a993f8df6c3ff79b4", "ref_doc_id": "65b12f50-b533-45c2-bca4-b35ff946d9a6"}, "760edde3-6283-4fe1-bf3f-de2b24d32a08": {"doc_hash": "9d874dba76bf4ce0e622368c78b882d8e47d71647bbbcfb515a4186b0492a1ba", "ref_doc_id": "44935100-ebd2-4717-a006-836d1d4588a5"}, "4d32fa53-2eda-4b24-8864-169bed3f4d4d": {"doc_hash": "d1ebaea0156b484beda7c4d5d245ee6ad2cbb88da87dce2b87682f2313f982e5", "ref_doc_id": "d0918ce4-809f-4013-a000-a014386408d3"}, "9f1d5414-b59d-45b5-a11f-d0aaa4c9cb05": {"doc_hash": "8b1947cf2b8ecea9fc294fa5a5c4d8d048120d499a73bfd44ac41fab282d76af", "ref_doc_id": "a76f9c33-a3e3-4d08-8f60-36cdc658e598"}, "1e57889f-94f4-4957-8032-01b263707951": {"doc_hash": "77019a57d6ceaf3800a335f2aa02448a23f851d124697cbbb0a633a792785e63", "ref_doc_id": "b2470960-5eca-4cc8-97e1-50f28c3bed68"}, "8d2a4862-6f0f-417f-8629-86b8221847de": {"doc_hash": "b5d03b4ca22b81cb4756234314ba6263176e4e2a763a9b12cb47d6533e1b43eb", "ref_doc_id": "3c378130-152a-4b34-b40c-2c5f5ff5fcfb"}, "a365e57e-2d37-490a-82f3-304ec91656c2": {"doc_hash": "ca88cca1c71a3bf4f9b978fd181bed9040c1724761b09b21d5d860e4014526a1", "ref_doc_id": "d4c1d5b3-4e70-47a6-8200-e01c1da468cc"}, "19bae759-6c89-4b62-b3b9-b7906d2e5f26": {"doc_hash": "31e606f642d54b815c33415193f9645ddb0eb908c9d1571036cecdcf03f1680b", "ref_doc_id": "7502d682-0968-41fa-b55d-5819eacd8d62"}, "e0570867-358c-441c-9040-508c6c446a13": {"doc_hash": "ad33bad079bb6816568b8b7d4d0809815c4ed7f9f22290b635c52b1dae7e6941", "ref_doc_id": "7502d682-0968-41fa-b55d-5819eacd8d62"}, "06201254-cb72-4eb1-8b64-97e0868f3d04": {"doc_hash": "75263886bbc7207adc4bb9a67414056c64e26aacffa7f46a784e8fc74bb3faea", "ref_doc_id": "054a4d03-49f9-488e-a175-d02a58d43684"}, "d8ac4e0e-87b5-4865-a5c3-5892761f4a62": {"doc_hash": "9b1291dc16af051ea15692dc1877934762dbd4ee5e19a5d31db4e98b6385c77c", "ref_doc_id": "19b4116c-3dcd-4ac5-b3cc-1698f683978c"}, "fe1b8578-c937-469c-9795-a670e7574baa": {"doc_hash": "cd04bd28ed9942f86c02cc1b0b1f9a7d28ff38b999f2f33d2b1b6f3432fcfc3b", "ref_doc_id": "22e1b81d-b8ab-445f-a1dc-cdb48180e8d0"}, "209a9f86-d422-4a7e-b0d3-3eca082315d0": {"doc_hash": "ac036a2a6df6b9d5bea0dd3c5a8880460a453e23c97665b9c2ee59a5bcd02727", "ref_doc_id": "c3a5fde2-555a-4d11-8ebc-a55b5a25bf74"}, "99082fad-0df8-4057-bf02-a7769a2cc2b5": {"doc_hash": "857c0a77eb864ca42551dee7ec981d3ac0b63908b3784adf39417f15f146ae17", "ref_doc_id": "1313a23b-3cfe-46aa-a8c0-b25a18daf5d4"}, "a5dc03a3-2f1d-42ad-8166-55156a8edb8a": {"doc_hash": "017c659454441be31bd0285eb264b016f244f4f95f723bf36ec908fe38e159f7", "ref_doc_id": "0602591e-396f-465a-9c22-d5c36a90d6cc"}, "a1cdd82d-9202-4797-a40b-8caaa7fc936d": {"doc_hash": "70129814ecd7075b89c96efc318b13e7d4a7641a2bfc921616cbb73bb8d7897e", "ref_doc_id": "ebc0feff-aaf6-4ffc-ac64-2982fef76e83"}, "1271b4fc-c0a0-4b0a-a77e-2c2244945e94": {"doc_hash": "faa7cd6c590a4fe2cb593b97ea466d0ae3f4c1008dbe833898d0d2b0e0eeb6b1", "ref_doc_id": "31a4e240-38b8-456d-a455-3d5248c6e1a0"}, "b053faf0-1df3-474e-b3de-d99871c100e0": {"doc_hash": "43c4c8a92ca9cb249bd29eab4fbc4edbe5d07d118aa484ab129031ab4fce9957", "ref_doc_id": "b7f5453b-2915-46a6-ae88-7942b1b94adf"}, "7a173dbf-e717-4e76-905a-c068c7fc5405": {"doc_hash": "c38f4fecb8cdf8cbabf51a78d0377dbb59608345fbdfcf30cb3bbf6dd57ee6cb", "ref_doc_id": "2e42ee72-4454-4064-a16a-2eba745e40d8"}, "979c7dfb-e1e5-43b2-98a9-d2cba83f8b32": {"doc_hash": "160b1280d60d82434ca7aa352fb6f221dcddffbe3484ab0f66c92aed96e87073", "ref_doc_id": "cb272b09-7494-49ae-9d3d-1bd5094576ea"}, "dad2ce53-e8f4-4253-81e1-b73105b59874": {"doc_hash": "99afc94312ce793c45cc02dbeff01bce72012a47f4be69949de9f58afdf57b45", "ref_doc_id": "74a1f56a-7bcb-4762-85ac-f6af487535ea"}, "b48d96b3-3329-4b95-9a4f-eb6c3e048f2d": {"doc_hash": "2e96639f42a74fa53f1ac8ca336e1d71fb315238c363e884b174fda7a9495023", "ref_doc_id": "de0fa9ea-7a5d-4b63-bbbe-1a31b5f1985a"}, "971d2f6e-0ced-4f90-b8c4-34720d7fe693": {"doc_hash": "daad1a192a05efad54213434290a95d4c6cfce97d44d4e48a5c702f6f4197c61", "ref_doc_id": "a21839e3-b820-439b-b5da-b5d43688d75d"}, "555b90fe-9611-49b2-98cc-fda44a97ac67": {"doc_hash": "db389ea2eff0db58fa54f6c725ebe53be8c6ac00784e018cec2cfe419d6cd764", "ref_doc_id": "0ee51a65-8fcc-4525-9c0c-78d5067a5322"}, "e6dd0714-06a1-468f-adfd-30da4147296a": {"doc_hash": "d19977d215439949ce6b90cff93d8d8da1eb141bc774da240826174a71f99a20", "ref_doc_id": "125e959a-cb4b-4a7c-9b73-5f80b61a74ca"}, "87b0c517-7c71-400f-a839-1abbb6cc213a": {"doc_hash": "646bfb398b410724623b867d3d0ecbd412f16f09e2454d216ed39ada636aad30", "ref_doc_id": "2047cd2d-605a-40ce-8b89-ec793a70d05b"}, "462ffaf5-b019-464f-a4e8-db5e5692995a": {"doc_hash": "e5b1418b9fe4affffaff8febac53b1047d1d0337769f1e9137bbcdf7b614f3bd", "ref_doc_id": "54eb0dd2-0372-4480-8700-2b2ab5e05d29"}, "80cee061-8b84-4a7f-a486-268b776615b1": {"doc_hash": "835e17c6db5c87e84166681d98c5663c6b8f9a6a686fd29ee6ac25c93b307028", "ref_doc_id": "4467e687-5999-4b63-9101-fe9d307cfc80"}, "4d36a5e1-62e2-4e01-8197-035f4ad72dd3": {"doc_hash": "be892b3951160ba86eff1ab3c17c8df5a04840a50bb7d5ac4d463429791ab844", "ref_doc_id": "6b6772b3-9022-4a46-bc80-adfe89c9accb"}, "4437d5d8-8c75-42cc-9cac-3efc7d7c1dab": {"doc_hash": "93c91e608698df473644b230a8a53d310f71c5383ff2d194ed6edcb5b88204bc", "ref_doc_id": "40fbc029-2ad0-402e-81cd-8c0efe287788"}, "f7a6a9f5-c3d3-4eb2-831b-6b62b1f68842": {"doc_hash": "f5694cdd3374b2dfaec0702801322e424390ec0c080a04d74435df3b026b6c76", "ref_doc_id": "58c66e14-f22b-4a36-ab1f-9f57d4b818f9"}, "fec09d0b-e735-417c-b5b5-a8955669bcd0": {"doc_hash": "c4bcb4501050fd2db225d786fbffd0ce6665a01c9170271cd6ccd3d4abfe103c", "ref_doc_id": "30483c99-d763-4ad5-b049-71ea752763cd"}, "848bbcae-08b8-44a8-8134-f50329851c68": {"doc_hash": "0d5f0e623d6bfa9def56fcc264f888dbf2a21621341150cc4452842a9fae1f66", "ref_doc_id": "6a51f9e0-f740-49ba-a5fb-21f5a4664960"}, "9207d7fd-cc90-4a7b-852e-ac3f0ca9849c": {"doc_hash": "b614ac1265d13c68df86cd0081d8e107a0e789b7f3d3c175159a7f8bc591110e", "ref_doc_id": "bd21fc9f-2e9d-4dae-9aa1-0127bd7991b0"}, "9aa12637-db34-4d7a-9784-ef31ac8a269b": {"doc_hash": "dfb1d5faa1ef60dbfc9b127922bd0873fa383976e8d2fa64a722a9d1c54b9541", "ref_doc_id": "ed55d837-9d25-42b2-9f2f-0988305f31b9"}, "86f775c7-90ef-43f2-9908-db52c8a86cb0": {"doc_hash": "e52dff8dfd437eb460a238dd35451d388be0c719cab8907a2509d83aea46f5f6", "ref_doc_id": "4669cc34-fabd-4371-afd9-07fc961fb99c"}, "d9f734fc-3226-4b81-babc-93d496d33951": {"doc_hash": "25e8c23aa0f5915a5c48eed91c667dc22c7bf60a26c4084047b62471bdcc8935", "ref_doc_id": "0c453eb8-561b-4931-abe3-ea257e314b77"}, "6601d651-4e32-43fa-a001-7f1af2ed50a5": {"doc_hash": "f54523a79b382670dd968c2c83038c548805f30b5ae7147e559116be0f477a07", "ref_doc_id": "a5eb5759-6fcd-4fba-a0ce-2d697baf268d"}, "ddcbe981-2b7a-44be-af60-bcf555433f0b": {"doc_hash": "e36a90e2d352eed949a90a1644c2c090f875b24eb7c6d264d6aaecea7eb8128f", "ref_doc_id": "4a760229-465c-427e-aa06-ee9c11b9d741"}, "e0b0b4a4-8b9a-4bfa-a123-93385461cdd5": {"doc_hash": "bf61739b1467e334d958755666f34e4a122b72df2ed10957da54a9b943f10812", "ref_doc_id": "5fa5cbaf-0f35-4b9d-adff-e85c226123ee"}, "ecea9bbd-03e7-48bb-a9f9-5336c4334872": {"doc_hash": "5abc9e7ce57f4236e259910514ff30e1a8d7d5430de53e4fc756e57abe5bff58", "ref_doc_id": "47fea022-bdde-408e-884b-15d4b71026b9"}, "ba98213b-5769-456f-a73c-9548722f822c": {"doc_hash": "1546b09c3c268b48e7c31a1310ab0d7c652d9987224a3f5129c056c73af188d9", "ref_doc_id": "801c7121-6498-45f9-9982-5ac4493b7d5c"}, "a64438d1-9e57-4325-8a98-99fc03559c27": {"doc_hash": "1ab9e792f001713e1f114bf201521287288bedc86666a5d7fa640572515e4ab1", "ref_doc_id": "7770cd55-5f3b-4e8e-aee9-ecf39b046832"}, "24c3a50c-42cd-4c3e-8001-e7332dccb190": {"doc_hash": "9d87eb5535a9164f20e81706de29504a87cc1baa56bd04b54ebc80daa15b1ec9", "ref_doc_id": "2de75324-dbdf-4dfd-b349-8d4646785a32"}, "e2cb319e-b352-4d4b-8f53-a8aa3675baf9": {"doc_hash": "6c05b1e5db74b810204955c3ed8ca0884cded84b6a4fa6f2d110b8b24c4dc406", "ref_doc_id": "771c14ae-b222-4117-b39d-2faea750ee5c"}, "6469cac0-fee6-4b34-8ea5-9073e683c617": {"doc_hash": "67b0af0c045af546e1b15851bffec36c34d21a22526f1dcd26ff37482e9b77ea", "ref_doc_id": "fdabded4-fe83-400b-bec1-ce4c30cf9b1f"}, "d2653b40-5996-4076-a42f-f531ece9bd7f": {"doc_hash": "cc63b973c2a205fea98095e249de4521e47b66810dffa22e09850d84a450d5ba", "ref_doc_id": "6505cecf-677c-4d91-bc21-4c3a911f2ac0"}, "9b41fc0e-a810-4ca3-95cc-e21c280031b0": {"doc_hash": "3ac5f273b4ef3c08569905fa9b4839b121311765f567a383a6912e67cc2fce13", "ref_doc_id": "453763d3-5a2c-4186-8f6a-d9f423a3c22e"}, "b45f890e-3c4c-44b2-bf62-87f14ac48e9a": {"doc_hash": "3a1e2cd5c8ace6eabbf60c6e044cfffe28497d9aee1b9deafcb8127910dedeae", "ref_doc_id": "dcc12e56-bbb1-48dd-90f1-330686f8779d"}, "b238dc51-f74a-4dc9-a980-bb6f2d0facca": {"doc_hash": "776acce3004c52166b47788f4b10398e1115c7dca42a108b136545b188c13d8a", "ref_doc_id": "2228b889-4a61-4d0e-ba33-07c97eed0389"}, "92e2dace-0784-4955-a484-939c74711ce2": {"doc_hash": "4faac44ede7cf4cfafea8e9d0e5bb23953815a648fd3ad7a511ce84fb9d5cfe6", "ref_doc_id": "78c46e43-b93a-4000-991b-de6110b1ed12"}, "3b1dd7c8-d7bf-4ac0-9d6f-6b21ed196e4e": {"doc_hash": "20cb064ee2279e197f0ad3707444338bfefdf8ceb52de83270d81e8d0b893652", "ref_doc_id": "e9f123f7-660d-4d8d-95f8-5e0bd024443c"}, "d8453891-ae22-412c-888d-98e7f50c361e": {"doc_hash": "f5fec634fd8a6b641f3c1bde017032cb60a9edefae6ac445d5eedb9f2178508c", "ref_doc_id": "abf11ad1-2619-4914-abcd-4ecc455d6b8c"}, "641f39eb-43fb-4f67-9f85-b27979fdcf89": {"doc_hash": "969e03e17fb597654613b519a991c9aa28c6db5846b3bff768600f4cf2ca394d", "ref_doc_id": "5044523e-0216-4f21-8097-9a0e34005ebc"}, "06ff69ea-ea3f-4e05-9702-a4f42083162c": {"doc_hash": "e80b44d9ec70ba13840bd9920b47b8e361204d8faf5513b80ed8ef6b5343f6aa", "ref_doc_id": "ff71afa6-6817-4c42-ab3e-c84632ee6845"}, "33862ba6-3d98-43a6-8b48-45d72ec0c9f7": {"doc_hash": "97d6f73af805f3e1f65e7e6ea54d0d926d8715acd42c6972f1d9ada0254c93ec", "ref_doc_id": "b373300d-6b21-4b71-ba8b-5169cd22a3c3"}, "5105ccff-853c-4348-81c4-0d3619922165": {"doc_hash": "cfc6c8196cb5063678c679d9fd1254d7ffd0c53f69b58f153bfb4802ea1332a6", "ref_doc_id": "43561dff-5a70-44c5-b85c-6b103665a579"}, "243dfa73-42aa-4ac7-9d0f-dbfcfac806d8": {"doc_hash": "5f2706abf4377c46ceebe2de95a26fbaef4ca3d4917b4892c73dd6ebdb46264a", "ref_doc_id": "006e6506-be88-4e19-b0f1-9558e4ad6ade"}, "50f9d152-9614-4f62-a600-ae7721e4f42c": {"doc_hash": "009940dbf1560c8f4b7ec2eb967cb2871b91834552c6a13ac359c5a8fa44afef", "ref_doc_id": "219da5b9-f055-48e9-92b4-22fdcb947390"}, "d781fb74-e430-4e16-8ba3-33f40cf8805c": {"doc_hash": "924a71c787d2d5011fa3b01dd5ddd2f453255620b52235f8f30645559de6065b", "ref_doc_id": "9b86a7d9-96a2-4e58-8f7b-c20667c1ab1c"}, "7870deef-0ff7-4eb9-9177-ee611d122f6c": {"doc_hash": "1514a649f9073c058755b8bc8ee4b17330f21cb231d4283f3ddeb1291ab8c133", "ref_doc_id": "5e5970cc-055f-4ad8-8118-51172040cc69"}, "ba304024-cb3c-49af-a18e-f96ec2724457": {"doc_hash": "1cfaa8101b65cf67e02607830cd1ef2127fd9fa0a4aeb995b75a6de74afb304a", "ref_doc_id": "65049405-5ee7-41a3-8f7e-1f4afd67da15"}, "16351c56-0d44-4ada-864f-be7104ad6860": {"doc_hash": "7af24b3b0ca0505458c3ca326564005a19f7ab38141e0c84614bff9d228e26e4", "ref_doc_id": "16ec0902-93f5-4310-af1b-cd584e6ededb"}, "a190cb27-9b4e-48b8-bad2-f21b21dce25b": {"doc_hash": "e8ba8e09d60a0b3d4d46e6edb6e3b5f9bde1fb1d26a49a5fcedc40b2818bc1a5", "ref_doc_id": "82077a3f-5db0-4220-969c-766bfbb80958"}, "a2dde6cc-b223-4833-8123-12a80b223f28": {"doc_hash": "92652de989508343d9dc9e7e5b76347734f385b357c3ee7aae49e1d518710b2f", "ref_doc_id": "2e04468b-1a5f-41cb-870d-d63002ee17b0"}, "162d8940-0b7f-4e87-8288-15ce58a4bd8e": {"doc_hash": "37ada3774930180b0f3258b20fd3f81b832c2be7fa99c58591cb3db78744ecad", "ref_doc_id": "0f936c7f-ea99-4cfd-b7a7-b526a15c0154"}, "fa854af0-f5b7-4f15-a27d-d77b60c06994": {"doc_hash": "2202e43264f9ac0b6eeebba1311b90f8de50bc3db792937a1a9a250391e6aa77", "ref_doc_id": "cc638242-a014-4e20-8438-82fe9a902629"}, "fc5e1b2a-c2f2-49c8-9d43-24afd4a22563": {"doc_hash": "66c199144a7086fd9534dd3ca06c64fd326e5e857a9a0283476acd49751e8053", "ref_doc_id": "d1bf8d3f-e168-4b22-9b78-5697e1d92ff0"}, "62c57601-3a00-4f38-9001-f1b1657519b8": {"doc_hash": "d7f83ee1b3e1a08dca5a62c833ce3073fe61b414d1be474cddb6d648da97c1de", "ref_doc_id": "dcfe059d-adf4-4efe-8a11-0f5df04bf137"}, "861da732-4fdc-4aab-bc7b-b047963943e3": {"doc_hash": "19d2c450de41032a2a280beaac703579099e0fdef58c4699e447bd4885090521", "ref_doc_id": "4827f7da-38d2-48b3-a83b-74a0ae6b0dc1"}, "9db76110-8d6d-4a95-9577-2aa0cc178cf7": {"doc_hash": "80b2266925ba26e8e0e278f84f8b1b987c0a3e48affcaef9a9b6087d7fb62066", "ref_doc_id": "a8b9a87d-c8c2-48bb-8c79-a7e914af3279"}, "65c8408d-f050-4ca4-8e98-8aa07163ca2e": {"doc_hash": "29a759d69914b936d0786bff92ac2185e12f072a9d1d17ffa5af9846e90e10d8", "ref_doc_id": "1c34a6ee-41fb-4374-bddc-50a460a096bd"}, "e3cb6921-36b2-446b-9f44-ae0a4c18259d": {"doc_hash": "4246391f561b7669d04cdf6b853e6e9e826b71eeac92cabcb48b35abbb29bbfd", "ref_doc_id": "d7cd9798-cf09-4395-ad0c-405565c47cf3"}, "01bd11b6-0227-43fd-8602-e65d1d744483": {"doc_hash": "dbbde49d9614208f93eabeff4086f80f22677dd1b5fdc14096e5e4a46c1e2e84", "ref_doc_id": "dac92a66-6742-42fa-9bc8-7aba5d6e50fe"}, "de0c6866-6a44-4fa7-a7a5-ee1b0012029a": {"doc_hash": "f915ff8f72df10e9cdc0c10532919769017514d7e77cc60cf674434e77d19e3c", "ref_doc_id": "c619de16-f76a-405a-b8f5-a3ffbd2dc920"}, "4f10ff3c-7482-4bc9-a624-fc899e30e624": {"doc_hash": "b59c5db7849030f4a1bd57238ae93f9064422c1cf9fb4697527589875ea525d7", "ref_doc_id": "ba32a073-fa17-4a8c-a508-de75fbbeb558"}, "bdcedd02-6321-4aee-8c5c-0f55495e7891": {"doc_hash": "200b25c1325b1c43c9e43758bdc86543b7360d2275ff0cbad68cc8ade9a10491", "ref_doc_id": "53f8a2c4-7e3e-4024-994f-05438c19456f"}, "04d8a208-e98b-4ecb-9c7f-4b74a830cdef": {"doc_hash": "57b349588a9213cb39902a7979d51c23fe951647d655e4f60706387b4596e9b2", "ref_doc_id": "c504291f-7c6d-44d7-9988-612a6d4258f9"}, "48b7809f-a0f3-462d-ba49-63a3cede58fe": {"doc_hash": "fedcb00ba5c9bc9a81a3b2606061e89537b96c44e353f9a63dfe4aa6e69b2a3e", "ref_doc_id": "2118b02b-9f5f-4dd7-9770-dadd54219e2c"}, "3cd472fa-0cb2-4f47-9860-1b70b88253aa": {"doc_hash": "218d8662eced5376c9008d8d257d561444ffcc48e1f4ce9261769bb7efdf0f20", "ref_doc_id": "79714208-495e-475b-82be-9cfb3eb94965"}, "649de324-ef4f-4f4f-815c-44528769a291": {"doc_hash": "cf0e8fdd30397e4d5076f295d5ef86dd68e0773b2a75dbba7d1e02bc219a6e89", "ref_doc_id": "ec9808bd-3e73-4956-a1ac-0c8c8a442f16"}, "78064cf5-b52a-4edd-9eee-8b82841a7f73": {"doc_hash": "f0753aa1011ca0741badfb69f05dc6ef45a67e5ffa00a92f573d36fcd7977dc5", "ref_doc_id": "6a35332e-c12b-4487-89cd-76da8b0f779b"}, "1d1fdcf4-00b9-4f7d-9638-c49924ef9e6f": {"doc_hash": "e00a0e8b74feae356fce39fb630adf1ea1aabe3eabe4506047f049b0e7d9acc1", "ref_doc_id": "1f82455d-8268-49b3-857e-ddabce1c25f3"}, "ff1d1173-ef6f-4ce4-81fa-9ad5396ac4e9": {"doc_hash": "99edc496e5ced80d48885703f0a55e4818a3d33fa7c2175490aa4b23132b3a64", "ref_doc_id": "6c29536f-9969-4ac8-bac4-763b731a23dc"}, "7aadc5f9-ced8-475a-875a-a1a75899e994": {"doc_hash": "8e1c37c0ef2d97060e84acf4b90939fb59531bd526e4b10725862bb3f0a7f8c0", "ref_doc_id": "506d8c87-e9c3-44ca-8327-d43785ff89cb"}, "27184572-28ce-4cef-9ede-e62d8421666f": {"doc_hash": "1e30ac74c04d7ccc54c586fae8387b6f0ec89c0d8269a7f73afe7bc22a730725", "ref_doc_id": "e86330df-b5ff-4404-83f7-a532df4a699b"}, "1f2df2b3-3b51-4e01-b2f1-202e5533caca": {"doc_hash": "5d6ce5af95a013755f8406ff20a118afd970b951702a6e0eea322d5aaf35b5ec", "ref_doc_id": "93744a9c-4c8e-4e45-9656-52c8de55e605"}, "e1ec47fd-eb6e-4dfb-b1c2-04372c1e62a1": {"doc_hash": "9ded777f82e4c8093c2dcc3796ca75d0b0f72a8f0aef1277fc0695361cc90d38", "ref_doc_id": "9b5fa849-f425-4f79-b3e3-398d7afaaad9"}, "516841c3-b9bb-452a-b495-eef19628220b": {"doc_hash": "a70f1d4e2ff62060f4911284d3bbcf7c2f69d3a49c256611eef44e696f5500f2", "ref_doc_id": "a65e5de8-a726-46de-97d1-d345af0493a5"}, "f63dde7b-d7c0-4369-a891-21770d563e50": {"doc_hash": "ab8c3595e8ab5dc699fbe88499e03a470f4664f4c20f5bae410691895566edfc", "ref_doc_id": "2eac5e37-3290-42aa-afea-3f7b49c5c4ef"}, "2670e9bd-ad8f-401a-ad59-f7a03c799c99": {"doc_hash": "cbf94f429625045a09c1919a174872e82b8fd201733e04e7e88f6eec9c9b3b72", "ref_doc_id": "1b37e028-4d89-4dc9-acda-2c74831dfb45"}, "cf8fc020-01e6-4470-b1db-70012eb2f822": {"doc_hash": "0332f13c5d6af48589a36d34e1f01d94e3105a874a79b6b361f64fc49059c583", "ref_doc_id": "6fbcc5a1-f232-4cc2-829a-ceec375b222e"}, "bac0b557-4d29-45e4-9b97-7eb3d94059c6": {"doc_hash": "3095605b64ed22b0e1bb72d316df5ae74a19cda35a625a506741016f368fffb9", "ref_doc_id": "1d433be7-3fee-40ad-9096-0cd30d082d5b"}, "c4ccbd8d-84b6-47e6-8d29-6f09d42e5c60": {"doc_hash": "928a9155305e654f1582a08f375c9da09485373569dde38051cd23e39e7d78ae", "ref_doc_id": "3c19b45c-0bb6-41a7-a513-2779f900200d"}, "15b3a0e9-c626-4ce0-a150-dc56e8976957": {"doc_hash": "9869082c23c3ba65083bd9ccdddda04c9bb9e9f935dfea4086a980e3cd2c70d8", "ref_doc_id": "bd4dfd55-fd52-4ad4-8f18-cd0eb92628bc"}, "11b2fb3b-e597-4181-8ca3-65b93e3a1b8d": {"doc_hash": "46e18c858bd33b7e6d46236e0c0c070790b0be21eec5eadae01d30768050f572", "ref_doc_id": "a65c6650-1424-4f55-aa5c-4fd7d807d0d0"}, "8316afb5-7e18-42ba-b4b5-ece619876d13": {"doc_hash": "a99009e17a82cf1803b4bd52c5f008e4806e60140756f8f8754fadcf3c6418ff", "ref_doc_id": "ca0210a6-bad3-4baa-9c51-0358f67c1f53"}, "3ff58683-b241-4204-9422-74ca76500024": {"doc_hash": "027b95cfc422bdf18666d997fb4d883a49b774cfca71497b84ad7760aab683bb", "ref_doc_id": "612883d9-9db4-48e7-9fac-2123087fa821"}, "26cac643-4e3f-40af-b6b3-198bf928e613": {"doc_hash": "23f38bb9f81d15f9f43088b8b272efe59694727ce2535c34dd2f134946370ff8", "ref_doc_id": "bb180876-b6e2-43a5-bcd4-0a64793d24f9"}, "f8190573-17a2-4f48-96f5-e9de24a468a3": {"doc_hash": "dabbb903bebfcd483ad1803af0a3d0e9981f0141c6f95f6ce4fa5ff87ec9ade0", "ref_doc_id": "c624a7a2-6d17-4bc8-b14b-41fdb271454b"}, "3a9a2c52-c8f7-4d5e-8604-e2108925bcfe": {"doc_hash": "5ddb2a4f32a5ac961f3116f3f985d5a230145131929ca3652f51b8312121dbfe", "ref_doc_id": "bc0eff0a-682f-40a9-8944-28d0548166ef"}, "391b30a4-a5c6-43ee-af92-3c4d3ffa9738": {"doc_hash": "71f3a289e33f4e6c43562dd72e09349e690bdbc1517f506edb5ee0aaba02730b", "ref_doc_id": "8babc670-40c0-456e-a794-1e2adf262c9a"}, "0dbde4c6-cc9a-4a2f-83d6-35a3602cd3bb": {"doc_hash": "c1d5499f01502a166bb1ff23f7bdf75c994c906ca8827a3f70208623059e9138", "ref_doc_id": "164a7700-9271-4c3d-8044-44e3699e41d0"}, "5672b081-5c8e-4df8-8072-0c57e5c54aa9": {"doc_hash": "ddcd56a3a7a98cb837b734216d798d6248a5136aedbc199df5092178fec5346c", "ref_doc_id": "d724225e-4bc5-47dd-9c3b-2dc28ed0a986"}, "5051c91a-36b9-4537-bdeb-e45c056c8fdd": {"doc_hash": "31479af5515ae9d75967cd54908c4901e11a960cc6ea8fc254f19eda6dcde66e", "ref_doc_id": "f850c619-c7d4-4836-9993-fdebbdbc4e72"}, "bb531fb7-0cfe-469f-b092-b69c85d2f79a": {"doc_hash": "67b2854d5693b86076487ca8899d982ed36f491d16a38d076ca00dbc34d7d772", "ref_doc_id": "5447f475-1492-43a8-93d3-515de254e4b9"}, "471d678f-de01-4b01-9832-0d94cf7283f2": {"doc_hash": "0e9a2db7c5c1b6d230ea15304d766aa00f97b19faa308677bd9189509c9ed33b", "ref_doc_id": "e50b4eae-c4b7-4d03-8794-6590c6f9515a"}, "75e58b01-d49c-4871-b2e6-5becf95f2bc0": {"doc_hash": "bea20c101632d1cb0dca9d123366d5cd79044d0a8884fb906dc9f8ebe83ede2d", "ref_doc_id": "89c0f327-0181-4262-961c-712fa3bd3f5a"}, "35fd07d3-ad65-405c-a284-275b10b83ed6": {"doc_hash": "11eeed14974e6c4167542f51fdfd21eb807eea4d0e908930be733780c3040317", "ref_doc_id": "bed8baab-41ea-443b-8c2a-2472e90c7933"}, "4d427609-7a63-4636-b86c-76727ebedf3f": {"doc_hash": "07a0524711a7de3473fc5a4458c1d184cfe37b7776d60c1670bc16f09d5d1b2a", "ref_doc_id": "ed184b12-df96-457d-830a-cfbc3c39dc36"}, "bac768a0-679a-4863-88d4-f7df15bfe00a": {"doc_hash": "922fb2757f5e9fa823aa4275883e89c9f31de16c1c93fd1fc6732c6c532b45fe", "ref_doc_id": "f9207ce3-2046-43ee-b074-875e1aec2213"}, "13501c1a-267c-4298-ab95-9de3805ae756": {"doc_hash": "5a3f0db5061358db632d34c922912c3062aebc3df0b47d5b9857787e3c341301", "ref_doc_id": "e195a8b7-9bd6-4243-b50e-99822347643e"}, "d34e59b3-ec97-4a89-ace3-4c28022c21da": {"doc_hash": "d5987cfbdba46730cba211fe8898558ccebfbe2de093054c7878934356701e34", "ref_doc_id": "a79b72e8-af14-404f-ba34-9b8740f8428d"}, "a4477c28-d91e-441f-88aa-102e447aaebd": {"doc_hash": "76219705f43035f7aee4f5d9030a72b6779cde34ebf52a5e684d9e4a5fe6b9f2", "ref_doc_id": "6418bd1d-1814-45de-88d7-f307c2bd82ff"}, "03c4a4c8-80e4-4412-83d5-0564106e9a74": {"doc_hash": "08c2db9f956fffe557b228dce585e6afc4f717197261ca28b70230ce7e82de7a", "ref_doc_id": "e2b5a1f2-ca1d-4174-bf53-0fbf97b69197"}, "f735b7d1-0aff-4c8f-8e09-9c2486cc4949": {"doc_hash": "57cd7a1ab5277ce72962f0b34baf793be28ed299d6a6b4bdf523f3bdd7d04df2", "ref_doc_id": "25ce72e4-5cad-4303-9831-a1dbb3eb2339"}, "7acb23d6-e401-47fa-a476-ff9aa5ba5200": {"doc_hash": "2d5e0e2ceae7c1f8c9e34ba3adea6b1659d93e040a2c4184dfc3de7d66e4885f", "ref_doc_id": "8d9bfff5-1578-4007-b762-1832b4a0c23b"}, "5505bba0-169e-45cf-88e0-7a09d74e92dc": {"doc_hash": "5d97ae9f624be35f956dbc3c08cd27ddd71a4340679ee73a84eedbf29681bb22", "ref_doc_id": "394a4f45-1d99-4702-9dc6-c9b89e15ec30"}, "dab4f4c5-4e06-4d59-8e8b-22d8153ed292": {"doc_hash": "16b890a36246c9ee1d86a8f0ed6bcaab6e79b5a08046520682bf147d33b85461", "ref_doc_id": "09c08890-5471-4e32-baa2-4ec0d3faf3f8"}, "d976907e-6a1e-4f20-a138-407dc66ea34c": {"doc_hash": "52f727fec00dd91b0460fe220ad0414af252e484b14fd321db65ea864663d016", "ref_doc_id": "fc26abac-1325-4bd1-af3b-2facd5b378f5"}, "6857750c-2920-441f-86c6-11b2297886d1": {"doc_hash": "8880b4ed70d6a69c4543e8477a0e85424a015cf0b363434c9052c406f76a1436", "ref_doc_id": "6aa69ebc-45f2-435e-bb1b-cad241b4fa23"}, "9741e9f4-9cc0-4bca-867a-d61b7857ed14": {"doc_hash": "7d767076fa5aacc1076ab433c9f26ee84ff3b42d03423b78ddf1a753ab25b156", "ref_doc_id": "c1abcc7f-2a36-4100-b728-fa8f385ba7dd"}, "a461165b-12a8-4cee-a663-10cc11edf05b": {"doc_hash": "317e01fa94c7ce32866fa4bf253bfef30e1021c8378c4a6a09c5991991feef82", "ref_doc_id": "a701e63b-aa68-4f04-bba9-c33ba763d6d5"}, "ff97433b-069f-4fc9-96fd-581cb92c35d6": {"doc_hash": "0d08353ddc3eac6d391f9c4069b8948706a5c5c1aa71b5f0d9c54b7570d2aa94", "ref_doc_id": "420c3b95-a64c-4c5a-af4a-709f7826fc14"}, "5930c6f6-c291-4ea8-9a73-fc52b471a514": {"doc_hash": "419facc820715c301b5efe00557b783f2fef298f7a31b7b91c67c8490b6e30bd", "ref_doc_id": "4751bee8-539f-4dfb-9718-f789534598d4"}, "8dd7b702-dd79-4264-91d7-53db1277a4f9": {"doc_hash": "f3edf9f45b3ccbd682fd5bc5e499cc09cae8a0e382b38334884c2dce41ed3830", "ref_doc_id": "46eb1b61-a236-4070-b02d-965650d9309b"}, "946b2634-b6a6-4898-af3d-c155f54d24ac": {"doc_hash": "778b6a6c180bfc4b5e96ce0331ae122e092c4553339363016361502dc20f2f20", "ref_doc_id": "00cf25b1-8a6a-4f6f-a217-5e8331c3ff61"}, "01bbea0e-ff7d-46f2-b3cc-e525913a67f2": {"doc_hash": "2c0384bf935f3e8ca5777374635ff2298f4873a5133b162345ee7341555668b5", "ref_doc_id": "7e5af48d-f5ff-4b60-b450-6aa543a5a171"}, "d9d5d2fa-8f23-46b9-9fec-319cf204711c": {"doc_hash": "324441c4e2dcd8bd12c65846091c9dc9af3b32885ed7317e3c9bea02552b7c78", "ref_doc_id": "9a04f9f7-e932-4822-8df6-ee97d6abb2b8"}, "3d16b8e5-afbf-47e4-a085-a1c8ec2c2d56": {"doc_hash": "bd60fe377eed17754375e59739f84db23cc50ccb2f7ca1595dad10cdabe8b2e4", "ref_doc_id": "5847202a-71f8-44f2-abde-5792dcab65e9"}, "d59129b7-9f30-4524-906a-d141cfb4b90f": {"doc_hash": "ef68d6a2bd1502b8bdca2c1497b6159c45637d80d6ef50ddf5adfe44e7535e90", "ref_doc_id": "03671864-c2be-42ec-87da-4d24b70c26ab"}}, "docstore/data": {"5fd6a050-23f3-4e8f-bba0-71fa5e7cc222": {"__data__": {"id_": "5fd6a050-23f3-4e8f-bba0-71fa5e7cc222", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ee8c1bea-b1cd-4fac-b9c4-9abe2fc7180a", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "1c00ad3af0149b0cabba753360daf30ae727aa7052c6a69e02ee82d0f74f540d", "class_name": "RelatedNodeInfo"}}, "text": "Python Protocol API v2\n\nPython Protocol API", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 45, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fb72f441-a712-4d13-85be-497de0ea4a6d": {"__data__": {"id_": "fb72f441-a712-4d13-85be-497de0ea4a6d", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "908670da-f9ca-45f4-9c87-18f5a25f1c50", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "cd47f931768321c55338deda36f2d691c4b2dd8ea575b2110969738a85dabfe0", "class_name": "RelatedNodeInfo"}}, "text": "Table of Contents\n\n- Welcome\n- Tutorial\n- Versioning\n- Labware\n- Moving Labware\n- Hardware Modules\n- Deck Slots\n- Pipettes\n- Building Block Commands\n- Complex Commands\n- Labware and Deck Positions\n- Runtime Parameters\n- Advanced Control\n- Protocol Examples\n- Adapting OT\\-2 Protocols for Flex\n- API Version 2 Reference\n\n---\n\n- OT\\-2 Python API v1", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 348, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5c43cac6-cbd5-4310-8d7e-644c79ea84e3": {"__data__": {"id_": "5c43cac6-cbd5-4310-8d7e-644c79ea84e3", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "39782762-0920-4ecf-8385-840e2a25cf4b", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "f994149bf66e0c07a66388f5c182b1a517db9ebc67865cc36d9f0de3851b8965", "class_name": "RelatedNodeInfo"}}, "text": "Related Topics\n\n- Documentation overview", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 42, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ff004526-704c-4adf-ba86-191b44bee19c": {"__data__": {"id_": "ff004526-704c-4adf-ba86-191b44bee19c", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "443f616f-d00e-4fce-9d52-2f82b3787301", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "17cd4ffa976395a166f978daf104773098be331796da8b244bdef440f19f8c86", "class_name": "RelatedNodeInfo"}}, "text": "Welcome", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 9, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "90fed81b-994e-447f-bb57-a58434d07c40": {"__data__": {"id_": "90fed81b-994e-447f-bb57-a58434d07c40", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c6039319-063d-4f6c-bd97-c2a6f8f29be3", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "e556f18bd418f88f747beef0984c0628969eb983b7e00766e3995e213ecfbf40", "class_name": "RelatedNodeInfo"}}, "text": "Tutorial", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 10, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7d19dd1f-4d1d-45bd-97b3-213043675326": {"__data__": {"id_": "7d19dd1f-4d1d-45bd-97b3-213043675326", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "90438811-6318-45c6-8a9b-31a4dda94448", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "00bbe8bc33a1e303a7f3252e31deb6a05a51bdddc14f97da16f0194b986f5603", "class_name": "RelatedNodeInfo"}}, "text": "Introduction\n\nThis tutorial will guide you through creating a Python protocol file from scratch. At the end of this process you\u2019ll have a complete protocol that can run on a Flex or an OT\\-2 robot. If you don\u2019t have a Flex or an OT\\-2 (or if you\u2019re away from your lab, or if your robot is in use), you can use the same file to simulate the protocol on your computer instead.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 376, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0ca2eafd-f502-4632-bebc-2a9004268225": {"__data__": {"id_": "0ca2eafd-f502-4632-bebc-2a9004268225", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1500300c-2874-4b87-8451-6e42a046b04c", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "851941caef6493e1abb0049a210fb0440febb412ea4720158fe6165b6df8de62", "class_name": "RelatedNodeInfo"}}, "text": "What You\u2019ll Automate\n\nThe lab task that you\u2019ll automate in this tutorial is serial dilution: taking a solution and progressively diluting it by transferring it stepwise across a plate from column 1 to column 12\\. With just a dozen or so lines of code, you can instruct your robot to perform the hundreds of individual pipetting actions necessary to fill an entire 96\\-well plate. And all of those liquid transfers will be done automatically, so you\u2019ll have more time to do other work in your lab.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 498, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "148b6c1e-85d2-4094-a823-08943ef9ef10": {"__data__": {"id_": "148b6c1e-85d2-4094-a823-08943ef9ef10", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c2f15d98-332a-4ac4-84c6-2e069e9c4d2b", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "0c0969716e8061659a84ba9af02fe51af8a85f28b59123f0f50c1c31d9267d00", "class_name": "RelatedNodeInfo"}}, "text": "Before You Begin\n\nYou\u2019re going to write some Python code, but you don\u2019t need to be a Python expert to get started writing Opentrons protocols. You should know some basic Python syntax, like how it uses indentation to group blocks of code, dot notation for calling methods, and the format of lists and dictionaries. You\u2019ll also be using common control structures like `if` statements and `for` loops.\n\nYou should write your code in your favorite plaintext editor or development environment and save it in a file with a `.py` extension, like `dilution-tutorial.py`.\n\nTo simulate your code, you\u2019ll need Python 3\\.10 and the pip package installer. Newer versions of Python aren\u2019t yet supported by the Python Protocol API. If you don\u2019t use Python 3\\.10 as your system Python, we recommend using pyenv to manage multiple Python versions.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 833, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bf194c77-94d6-468b-9dca-33b4a00b4341": {"__data__": {"id_": "bf194c77-94d6-468b-9dca-33b4a00b4341", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cda8dcad-3165-4e73-8ef9-913cccf2a532", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "382c14d34909b6353f49e0b14ced5d4b8827d1858d02e590272b0da8fb1b1b05", "class_name": "RelatedNodeInfo"}}, "text": "Hardware and Labware\n\nBefore running a protocol, you\u2019ll want to have the right kind of hardware and labware ready for your Flex or OT\\-2\\.\n\n- **Flex users** should review Chapter 2: Installation and Relocation in the instruction manual. Specifically, see the pipette information in the \u201cInstrument Installation and Calibration\u201d section. You can use either a 1\\-channel or 8\\-channel pipette for this tutorial. Most Flex code examples will use a Flex 1\\-Channel 1000 \u00b5L pipette.\n- **OT\\-2 users** should review the robot setup and pipette information on the Get Started page. Specifically, see attaching pipettes and initial calibration. You can use either a single\\-channel or 8\\-channel pipette for this tutorial. Most OT\\-2 code examples will use a P300 Single\\-Channel GEN2 pipette.\n\nThe Flex and OT\\-2 use similar labware for serial dilution. The tutorial code will use the labware listed in the table below, but as long as you have labware of each type you can modify the code to run with your labware.\n\n| Labware type   | Labware name                                                                                    | API load name                     |\n| -------------- | ----------------------------------------------------------------------------------------------- | --------------------------------- |\n| Reservoir      | NEST 12 Well Reservoir 15 mL            | `nest_12_reservoir_15ml`          |\n| Well plate     | NEST 96 Well Plate 200 \u00b5L Flat    | `nest_96_wellplate_200ul_flat`    |\n| Flex tip rack  | Opentrons Flex Tips, 200 \u00b5L            | `opentrons_flex_96_tiprack_200ul` |\n| OT\\-2 tip rack | Opentrons 96 Tip Rack | `opentrons_96_tiprack_300ul`      |\n\nFor the liquids, you can use plain water as the diluent and water dyed with food coloring as the solution.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1787, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7d5f954a-001c-4940-aae0-e524882b0dae": {"__data__": {"id_": "7d5f954a-001c-4940-aae0-e524882b0dae", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f12b1ab6-bf1d-4a1f-bb32-08050ed7ffd4", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "0f8bb430645a63de78b35721d3c69789c924764c3215cc8b647bbae1ed8a7edc", "class_name": "RelatedNodeInfo"}}, "text": "Create a Protocol File\n\nLet\u2019s start from scratch to create your serial dilution protocol. Open up a new file in your editor and start with the line:\n\n```\nfrom opentrons import protocol_api\n\n```\n\nThroughout this documentation, you\u2019ll see protocols that begin with the `import` statement shown above. It identifies your code as an Opentrons protocol. This statement is not required, but including it is a good practice and allows most code editors to provide helpful autocomplete suggestions.\n\nEverything else in the protocol file is required. Next, you\u2019ll specify the version of the API you\u2019re using. Then comes the core of the protocol: defining a single `run()` function that provides the locations of your labware, states which kind of pipettes you\u2019ll use, and finally issues the commands that the robot will perform.\n\nFor this tutorial, you\u2019ll write very little Python outside of the `run()` function. But for more complex applications it\u2019s worth remembering that your protocol file _is_ a Python script, so any Python code that can run on your robot can be a part of a protocol.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1084, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "618e1434-de1b-4c78-aaa3-ecde2504bcdf": {"__data__": {"id_": "618e1434-de1b-4c78-aaa3-ecde2504bcdf", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2cd0d4ec-de93-4c86-8e23-2301b9df028a", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "d3ed12185cc3bbfc7c730cb2ce394b2d6b8141f33bd3a485a3efddf0dae296b2", "class_name": "RelatedNodeInfo"}}, "text": "Metadata\n\nEvery protocol needs to have a metadata dictionary with information about the protocol. At minimum, you need to specify what version of the API the protocol requires. The scripts for this tutorial were validated against API version 2\\.16, so specify:\n\n```\nmetadata = {\"apiLevel\": \"2.16\"}\n\n```\n\nYou can include any other information you like in the metadata dictionary. The fields `protocolName`, `description`, and `author` are all displayed in the Opentrons App, so it\u2019s a good idea to expand the dictionary to include them:\n\n```\nmetadata = {\n    \"apiLevel\": \"2.16\",\n    \"protocolName\": \"Serial Dilution Tutorial\",\n    \"description\": \"\"\"This protocol is the outcome of following the\n                   Python Protocol API Tutorial located at\n                   https://docs.opentrons.com/v2/tutorial.html. It takes a\n                   solution and progressively dilutes it by transferring it\n                   stepwise across a plate.\"\"\",\n    \"author\": \"New API User\"\n    }\n\n```\n\nNote, if you have a Flex, or are using an OT\\-2 with API v2\\.15 (or higher), we recommend adding a `requirements` section to your code. See the Requirements section below.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1166, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f93e4978-3efc-45f3-bf8b-3c250e6867ec": {"__data__": {"id_": "f93e4978-3efc-45f3-bf8b-3c250e6867ec", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e05e5cb6-514b-4eb3-aeb9-fa3339907cfa", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ae13d0ad8ad477b56ba80671a46ec6da2581c0622accde9a1e348f7ede01db57", "class_name": "RelatedNodeInfo"}}, "text": "Requirements\n\nThe `requirements` code block can appear before _or_ after the `metadata` code block in a Python protocol. It uses the following syntax and accepts two arguments: `robotType` and `apiLevel`.\n\nWhether you need a `requirements` block depends on your robot model and API version.\n\n- **Flex:** The `requirements` block is always required. And, the API version does not go in the `metadata` section. The API version belongs in the `requirements`. For example:\n\n```\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\": \"2.16\"}\n\n```\n\n- **OT\\-2:** The `requirements` block is optional, but including it is a recommended best practice, particularly if you\u2019re using API version 2\\.15 or greater. If you do use it, remember to remove the API version from the `metadata`. For example:\n\n```\nrequirements = {\"robotType\": \"OT-2\", \"apiLevel\": \"2.16\"}\n\n```\n\nWith the metadata and requirements defined, you can move on to creating the `run()` function for your protocol.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 964, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ed204267-d82b-4dc2-8b63-c2808d43a436": {"__data__": {"id_": "ed204267-d82b-4dc2-8b63-c2808d43a436", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "86c4df41-67bc-4b18-9531-991ec39cdeb4", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "57641084a3c696a4d1aae74a296bed6a7f44e58e452e886e708727203a405594", "class_name": "RelatedNodeInfo"}}, "text": "The `run()` function\n\nNow it\u2019s time to actually instruct the Flex or OT\\-2 how to perform serial dilution. All of this information is contained in a single Python function, which has to be named `run`. This function takes one argument, which is the _protocol context_. Many examples in these docs use the argument name `protocol`, and sometimes they specify the argument\u2019s type:\n\n```\ndef run(protocol: protocol_api.ProtocolContext):\n\n```\n\nWith the protocol context argument named and typed, you can start calling methods on `protocol` to add labware and hardware.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 565, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "edf53007-1498-457f-95bc-41dd176e8e3e": {"__data__": {"id_": "edf53007-1498-457f-95bc-41dd176e8e3e", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6bb64722-3854-4de2-bf50-7316a8a7a149", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "f52057c4b52be056363c0faa1f686beaeced59d42c82e0cae06e804c2e4d2816", "class_name": "RelatedNodeInfo"}}, "text": "Labware\n\nFor serial dilution, you need to load a tip rack, reservoir, and 96\\-well plate on the deck of your Flex or OT\\-2\\. Loading labware is done with the `load_labware()` method of the protocol context, which takes two arguments: the standard labware name as defined in the Opentrons Labware Library, and the position where you\u2019ll place the labware on the robot\u2019s deck.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 375, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "74c99f97-26f7-43a6-89f6-4fbf174fad47": {"__data__": {"id_": "74c99f97-26f7-43a6-89f6-4fbf174fad47", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1bb4c179-ec9b-47a4-85c5-3d787bf7001b", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "763f3378a0d9c2dc9f4839a8db20d7d70cfb8e048824d480311f7a44ae211c30", "class_name": "RelatedNodeInfo"}}, "text": "Flex\n\nHere\u2019s how to load the labware on a Flex in slots D1, D2, and D3 (repeating the `def` statement from above to show proper indenting):\n\n```\ndef run(protocol: protocol_api.ProtocolContext):\n    tips = protocol.load_labware(\"opentrons_flex_96_tiprack_200ul\", \"D1\")\n    reservoir = protocol.load_labware(\"nest_12_reservoir_15ml\", \"D2\")\n    plate = protocol.load_labware(\"nest_96_wellplate_200ul_flat\", \"D3\")\n\n```\n\nIf you\u2019re using a different model of labware, find its name in the Labware Library and replace it in your code.\n\nNow the robot will expect to find labware in a configuration that looks like this:", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 613, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ba8a6241-8f23-4f5d-8ff1-97e13b7dfafd": {"__data__": {"id_": "ba8a6241-8f23-4f5d-8ff1-97e13b7dfafd", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "07dc62f5-fff0-49d2-bdcb-0b4caa795372", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "8849eeae9574ea581d1d499a4f032a8ad55b54084302403b417b8bb417acc8d9", "class_name": "RelatedNodeInfo"}}, "text": "OT-2\n\nHere\u2019s how to load the labware on an OT\\-2 in slots 1, 2, and 3 (repeating the `def` statement from above to show proper indenting):\n\n```\ndef run(protocol: protocol_api.ProtocolContext):\n    tips = protocol.load_labware(\"opentrons_96_tiprack_300ul\", 1)\n    reservoir = protocol.load_labware(\"nest_12_reservoir_15ml\", 2)\n    plate = protocol.load_labware(\"nest_96_wellplate_200ul_flat\", 3)\n\n```\n\nIf you\u2019re using a different model of labware, find its name in the Labware Library and replace it in your code.\n\nNow the robot will expect to find labware in a configuration that looks like this:\n\nYou may notice that these deck maps don\u2019t show where the liquids will be at the start of the protocol. Liquid definitions aren\u2019t required in Python protocols, unlike protocols made in Protocol Designer. If you want to identify liquids, see Labeling Liquids in Wells. (Sneak peek: you\u2019ll put the diluent in column 1 of the reservoir and the solution in column 2 of the reservoir.)", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 979, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9aa01e0c-b6eb-4167-b102-d2a752dd3ab5": {"__data__": {"id_": "9aa01e0c-b6eb-4167-b102-d2a752dd3ab5", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d63598fb-e347-4caf-8874-4ea073ff89a8", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "c335e7033effd0df8b27233b701a75a4a06998d146bda7235aa83e85b1b16f52", "class_name": "RelatedNodeInfo"}}, "text": "Trash Bin\n\nFlex and OT\\-2 both come with a trash bin for disposing used tips.\n\nThe OT\\-2 trash bin is fixed in slot 12\\. Since it can\u2019t go anywhere else on the deck, you don\u2019t need to write any code to tell the API where it is. Skip ahead to the Pipettes section below.\n\nFlex lets you put a trash bin in multiple locations on the deck. You can even have more than one trash bin, or none at all (if you use the waste chute instead, or if your protocol never trashes any tips). For serial dilution, you\u2019ll need to dispose used tips, so you also need to tell the API where the trash container is located on your robot. Loading a trash bin on Flex is done with the `load_trash_bin()` method, which takes one argument: its location. Here\u2019s how to load the trash in slot A3:\n\n```\ntrash = protocol.load_trash_bin(\"A3\")\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 818, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6046a625-2392-424d-a51b-7200fd7c676b": {"__data__": {"id_": "6046a625-2392-424d-a51b-7200fd7c676b", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2af8bedc-9d1c-45ac-9d9f-5674e6253616", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "0d965771123e907eea2be70e3433edea0808dd57387aca037ce8bdd89642d7f7", "class_name": "RelatedNodeInfo"}}, "text": "Pipettes\n\nNext you\u2019ll specify what pipette to use in the protocol. Loading a pipette is done with the `load_instrument()` method, which takes three arguments: the name of the pipette, the mount it\u2019s installed in, and the tip racks it should use when performing transfers. Load whatever pipette you have installed in your robot by using its standard pipette name. Here\u2019s how to load the pipette in the left mount and instantiate it as a variable named `left_pipette`:\n\n```\n# Flex\nleft_pipette = protocol.load_instrument(\"flex_1channel_1000\", \"left\", tip_racks=[tips])\n\n```\n\n```\n# OT-2\nleft_pipette = protocol.load_instrument(\"p300_single_gen2\", \"left\", tip_racks=[tips])\n\n```\n\nSince the pipette is so fundamental to the protocol, it might seem like you should have specified it first. But there\u2019s a good reason why pipettes are loaded after labware: you need to have already loaded `tips` in order to tell the pipette to use it. And now you won\u2019t have to reference `tips` again in your code \u2014 it\u2019s assigned to the `left_pipette` and the robot will know to use it when commanded to pick up tips.\n\nNote\n\nYou may notice that the value of `tip_racks` is in brackets, indicating that it\u2019s a list. This serial dilution protocol only uses one tip rack, but some protocols require more tips, so you can assign them to a pipette all at once, like `tip_racks=[tips1, tips2]`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1366, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fb05732f-c330-4e38-8be4-afd27dd0d467": {"__data__": {"id_": "fb05732f-c330-4e38-8be4-afd27dd0d467", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "21660e10-5ec6-4d81-af4d-b8fa01baf94c", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "570a1d118ace75a8b9fbad82537549fea30295f81d2c163c90eeb38a618749db", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "7ea28507-8d34-4264-9ec3-e83c3cad6fb6", "node_type": "1", "metadata": {}, "hash": "2cd7886af845c152ce7f7d27ec53609164866ddd66c6fbf2ebbed877372bcd8e", "class_name": "RelatedNodeInfo"}}, "text": "Commands\n\nFinally, all of your labware and hardware is in place, so it\u2019s time to give the robot pipetting commands. The required steps of the serial dilution process break down into three main phases:\n\n1. Measure out equal amounts of diluent from the reservoir to every well on the plate.\n2. Measure out equal amounts of solution from the reservoir into wells in the first column of the plate.\n3. Move a portion of the combined liquid from column 1 to 2, then from column 2 to 3, and so on all the way to column 12\\.\n\nThanks to the flexibility of the API\u2019s `transfer()` method, which combines many building block commands into one call, each of these phases can be accomplished with a single line of code! You\u2019ll just have to write a few more lines of code to repeat the process for as many rows as you want to fill.\n\nLet\u2019s start with the diluent. This phase takes a larger quantity of liquid and spreads it equally to many wells. `transfer()` can handle this all at once, because it accepts either a single well or a list of wells for its source and destination:\n\n```\nleft_pipette.transfer(100, reservoir[\"A1\"], plate.wells())\n\n```\n\nBreaking down these single lines of code shows the power of complex commands. The first argument is the amount to transfer to each destination, 100 \u00b5L. The second argument is the source, column 1 of the reservoir (which is still specified with grid\\-style coordinates as `A1` \u2014 a reservoir only has an A row). The third argument is the destination. Here, calling the `wells()` method of `plate` returns a list of _every well_, and the command will apply to all of them.\n\nIn plain English, you\u2019ve instructed the robot, \u201cFor every well on the plate, aspirate 100 \u00b5L of fluid from column 1 of the reservoir and dispense it in the well.\u201d That\u2019s how we understand this line of code as scientists, yet the robot will understand and execute it as nearly 200 discrete actions.\n\nNow it\u2019s time to start mixing in the solution. To do this row by row, nest the commands in a `for` loop:\n\n```\nfor i in range(8):\n    row = plate.rows()[i]\n\n```\n\nUsing Python\u2019s built\\-in `range`') class is an easy way to repeat this block 8 times, once for each row. This also lets you use the repeat index `i` with `plate.rows()` to keep track of the current row.\n\nIn each row, you first need to add solution. This will be similar to what you did with the diluent, but putting it only in column 1 of the plate. It\u2019s best to mix the combined solution and diluent thoroughly, so add the optional `mix_after` argument to `transfer()`:\n\n```\nleft_pipette.transfer(100, reservoir[\"A2\"], row[0], mix_after=(3, 50))\n\n```\n\nAs before, the first argument specifies to transfer 100 \u00b5L. The second argument is the source, column 2 of the reservoir. The third argument is the destination, the element at index 0 of the current `row`. Since Python lists are zero\\-indexed, but columns on labware start numbering at 1, this will be well A1 on the first time through the loop, B1 the second time, and so on. The fourth argument specifies to mix 3 times with 50 \u00b5L of fluid each time.\n\nFinally, it\u2019s time to dilute the solution down the row. One approach would be to nest another `for` loop here, but instead let\u2019s use another feature of the `transfer()` method, taking lists as the source and destination arguments:\n\n```\nleft_pipette.transfer(100, row[:11], row[1:], mix_after=(3, 50))\n\n```\n\nThere\u2019s some Python shorthand here, so let\u2019s unpack it. You can get a range of indices from a list using the colon `:` operator, and omitting it at either end means \u201cfrom the beginning\u201d or \u201cuntil the end\u201d of the list. So the source is `row[:11]`, from the beginning of the row until its 11th item. And the destination is `row[1:]`, from index 1 (column 2!) until the end. Since both of these lists have 11 items, `transfer()` will _step through them in parallel_, and they\u2019re constructed so when the source is 0, the destination is 1; when the source is 1, the destination is 2; and so on. This condenses all of the subsequent transfers down the row into a single line of code.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 4058, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7ea28507-8d34-4264-9ec3-e83c3cad6fb6": {"__data__": {"id_": "7ea28507-8d34-4264-9ec3-e83c3cad6fb6", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "21660e10-5ec6-4d81-af4d-b8fa01baf94c", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "570a1d118ace75a8b9fbad82537549fea30295f81d2c163c90eeb38a618749db", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "fb05732f-c330-4e38-8be4-afd27dd0d467", "node_type": "1", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "c7b4f5dfe4bedf1c920424c3e26a1545c71d4223ec17c11dc20d8d78ec26d602", "class_name": "RelatedNodeInfo"}}, "text": "You can get a range of indices from a list using the colon `:` operator, and omitting it at either end means \u201cfrom the beginning\u201d or \u201cuntil the end\u201d of the list. So the source is `row[:11]`, from the beginning of the row until its 11th item. And the destination is `row[1:]`, from index 1 (column 2!) until the end. Since both of these lists have 11 items, `transfer()` will _step through them in parallel_, and they\u2019re constructed so when the source is 0, the destination is 1; when the source is 1, the destination is 2; and so on. This condenses all of the subsequent transfers down the row into a single line of code.\n\nAll that remains is for the loop to repeat these steps, filling each row down the plate.\n\nThat\u2019s it! If you\u2019re using a single\\-channel pipette, you\u2019re ready to try out your protocol.", "mimetype": "text/plain", "start_char_idx": 3437, "end_char_idx": 4242, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "90119cef-21c5-4c91-a649-5d34c669eac8": {"__data__": {"id_": "90119cef-21c5-4c91-a649-5d34c669eac8", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a90ea0d4-c27a-46de-8738-36937bacf466", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "64d6702cf7212549762970306f98517ec4a3512e30bb48ae385e9ec7b5368462", "class_name": "RelatedNodeInfo"}}, "text": "8\\-Channel Pipette\n\nIf you\u2019re using an 8\\-channel pipette, you\u2019ll need to make a couple tweaks to the single\\-channel code from above. Most importantly, whenever you target a well in row A of a plate with an 8\\-channel pipette, it will move its topmost tip to row A, lining itself up over the entire column.\n\nThus, when adding the diluent, instead of targeting every well on the plate, you should only target the top row:\n\n```\nleft_pipette.transfer(100, reservoir[\"A1\"], plate.rows()[0])\n\n```\n\nAnd by accessing an entire column at once, the 8\\-channel pipette effectively implements the `for` loop in hardware, so you\u2019ll need to remove it:\n\n```\nrow = plate.rows()[0]\nleft_pipette.transfer(100, reservoir[\"A2\"], row[0], mix_after=(3, 50))\nleft_pipette.transfer(100, row[:11], row[1:], mix_after=(3, 50))\n\n```\n\nInstead of tracking the current row in the `row` variable, this code sets it to always be row A (index 0\\).", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 918, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8c1900a7-2428-4b2e-9813-b0d9d95d16aa": {"__data__": {"id_": "8c1900a7-2428-4b2e-9813-b0d9d95d16aa", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "884e2dd3-ea7a-4e36-8ae2-8f62bf050531", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "1c2d978182e66442331e073c32b5fe86638e5d89c7ce0d85ed4db7aa0f4899be", "class_name": "RelatedNodeInfo"}}, "text": "Try Your Protocol\n\nThere are two ways to try out your protocol: simulation on your computer, or a live run on a Flex or OT\\-2\\. Even if you plan to run your protocol on a robot, it\u2019s a good idea to check the simulation output first.\n\nIf you get any errors in simulation, or you don\u2019t get the outcome you expected when running your protocol, you can check your code against these reference protocols on GitHub:\n\n- Flex: Single\\-channel serial dilution\n- Flex: 8\\-channel serial dilution\n- OT\\-2: Single\\-channel serial dilution\n- OT\\-2: 8\\-channel serial dilution", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 564, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a9e68bf4-38b4-499e-b31c-49260b0f25e8": {"__data__": {"id_": "a9e68bf4-38b4-499e-b31c-49260b0f25e8", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7b7763bd-1f87-4b28-b172-88434a0a738d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "704749c4aa2b08f9598744761907dcaf03f019460db438b4d82191b7e28ccada", "class_name": "RelatedNodeInfo"}}, "text": "In Simulation\n\nSimulation doesn\u2019t require having a robot connected to your computer. You just need to install the Opentrons Python module using pip (`pip install opentrons`). This will give you access to the `opentrons_simulate` command\\-line utility (`opentrons_simulate.exe` on Windows).\n\nTo see a text preview of the steps your Flex or OT\\-2 will take, use the change directory (`cd`) command to navigate to the location of your saved protocol file and run:\n\n```\nopentrons_simulate dilution-tutorial.py\n\n```\n\nThis should generate a lot of output! As written, the protocol has about 1000 steps. In fact, using a single\\-channel pipette for serial dilution across the whole plate will take about half an hour \u2014 plenty of time to grab a coffee while your robot pipettes for you! \u2615\ufe0f\n\nIf that\u2019s too long, you can always cancel your run partway through or modify `for i in range(8)` to loop through fewer rows.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 909, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "016f74e6-4cdd-4908-a670-9ce88db38ac8": {"__data__": {"id_": "016f74e6-4cdd-4908-a670-9ce88db38ac8", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "93f63f91-a2cf-4c98-b1a2-af9134983d98", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ba114f418e563db902bd475a0c2c25040ab7e3ab99970a3e77a32e53c118a40f", "class_name": "RelatedNodeInfo"}}, "text": "On a Robot\n\nThe simplest way to run your protocol on a Flex or OT\\-2 is to use the Opentrons App. When you first launch the Opentrons App, you will see the Protocols screen. (Click **Protocols** in the left sidebar to access it at any other time.) Click **Import** in the top right corner to reveal the Import a Protocol pane. Then click **Choose File** and find your protocol in the system file picker, or drag and drop your protocol file into the well.\n\nYou should see \u201cProtocol \\- Serial Dilution Tutorial\u201d (or whatever `protocolName` you entered in the metadata) in the list of protocols. Click the three\\-dot menu (\u22ee) for your protocol and choose **Start setup**.\n\nIf you have any remaining calibration tasks to do, you can finish them up here. Below the calibration section is a preview of the initial deck state. Optionally you can run Labware Position Check, or you can go ahead and click **Proceed to Run**.\n\nOn the Run tab, you can double\\-check the Run Preview, which is similar to the command\\-line simulation output. Make sure all your labware and liquids are in the right place, and then click **Start run**. The run log will update in real time as your robot proceeds through the steps.\n\nWhen it\u2019s all done, check the results of your serial dilution procedure \u2014 you should have a beautiful dye gradient running across the plate!", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1345, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "637df4d8-3bb4-4e1e-b56b-a672fb78cfb3": {"__data__": {"id_": "637df4d8-3bb4-4e1e-b56b-a672fb78cfb3", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4958c287-f737-46f2-97ef-bc6944efaed9", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "59bba534751e43f62abcd3467b4e7933169f70c8be68b734b1d05ce2c6201960", "class_name": "RelatedNodeInfo"}}, "text": "Next Steps\n\nThis tutorial has relied heavily on the `transfer()` method, but there\u2019s much more that the Python Protocol API can do. Many advanced applications use building block commands for finer control over the robot. These commands let you aspirate and dispense separately, add air gaps, blow out excess liquid, move the pipette to any location, and more. For protocols that use Opentrons hardware modules, there are methods to control their behavior. And all of the API\u2019s classes and methods are catalogued in the API Reference.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 535, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ff91cb92-24c1-422a-ad85-3083e163098a": {"__data__": {"id_": "ff91cb92-24c1-422a-ad85-3083e163098a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b5ab2401-83c5-464c-862f-fa9f6fa74f56", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "dff92c63dbfcac389cdf557b9b6ddc66e099933686e48e435f1283f9fcce7706", "class_name": "RelatedNodeInfo"}}, "text": "Versioning\n\nThe Python Protocol API has its own versioning system, which is separate from the versioning system used for the robot software and the Opentrons App. This allows protocols to run on newer robot software versions without modification.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 248, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "32016a56-9bad-4a2c-a89b-f65bd22ed4d3": {"__data__": {"id_": "32016a56-9bad-4a2c-a89b-f65bd22ed4d3", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0227c4aa-7239-4e62-bcc9-8e90f5b2d44d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "01bc36f8bb8557fe87be755b03c12b88f0b8bd793855442f7724e7b145b578a8", "class_name": "RelatedNodeInfo"}}, "text": "Major and Minor Versions\n\nThe API uses a major and minor version number and does not use patch version numbers. For instance, major version 2 and minor version 0 is written as `2.0`. Versions are not decimal numbers, so `2.10` indicates major version 2 and minor version 10\\. The Python Protocol API version will only increase based on changes that affect protocol behavior.\n\nThe major version of the API increases whenever there are significant structural or behavioral changes to protocols. For instance, major version 2 of the API was introduced because it required protocols to have a `run` function that takes a `protocol` argument rather than importing the `robot`, `instruments`, and `labware` modules. Protocols written with major version 1 of the API will not run without modification in major version 2\\. A similar level of structural change would require a major version 3\\. This documentation only deals with features found in major version 2 of the API; see the archived version 1 documentation for information on older protocols.\n\nThe minor version of the API increases whenever there is new functionality that might change the way a protocol is written, or when a behavior changes in one aspect of the API but does not affect all protocols. For instance, adding support for a new hardware module, adding new parameters for a function, or deprecating a feature would increase the minor version of the API.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1421, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a91527a1-0c42-46fc-a00d-51e48e160a99": {"__data__": {"id_": "a91527a1-0c42-46fc-a00d-51e48e160a99", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "62a8b884-ade8-4a27-b6a8-c125f915b95d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "92906ee56485b5757e5ff4991aa2a7cee1284e13a214f34bbdc89b263a2a92e0", "class_name": "RelatedNodeInfo"}}, "text": "Specifying Versions\n\nYou must specify the API version you are targeting in your Python protocol. In all minor versions, you can do this with the `apiLevel` key in the `metadata` dictionary, alongside any other metadata elements:\n\n```\n from opentrons import protocol_api\n\n metadata = {\n     \"apiLevel\": \"2.19\",\n     \"author\": \"A. Biologist\"}\n\n def run(protocol: protocol_api.ProtocolContext):\n     protocol.comment(\"Hello, world!\")\n\n```\n\nFrom version 2\\.15 onward, you can specify `apiLevel` in the `requirements` dictionary instead:\n\n```\n from opentrons import protocol_api\n\n metadata = {\"author\": \"A. Biologist\"}\n requirements = {\"apiLevel\": \"2.19\", \"robotType\": \"Flex\"}\n\n def run(protocol: protocol_api.ProtocolContext):\n     protocol.comment(\"Hello, Flex!\")\n\n```\n\nChoose only one of these places to specify `apiLevel`. If you put it in neither or both places, you will not be able to simulate or run your protocol.\n\nThe version you specify determines the features and behaviors available to your protocol. For example, support for the Heater\\-Shaker Module was added in version 2\\.13, so you can\u2019t specify a lower version and then call `HeaterShakerContext` methods without causing an error. This protects you from accidentally using features not present in your specified API version, and keeps your protocol portable between API versions.\n\nWhen choosing an API level, consider what features you need and how widely you plan to share your protocol. Throughout the Python Protocol API documentation, there are version statements indicating when elements (features, function calls, available properties, etc.) were introduced. Keep these in mind when specifying your protocol\u2019s API version. Version statements look like this:\n\nNew in version 2\\.0\\.\n\nOn the one hand, using the highest available version will give your protocol access to all the latest features and fixes. On the other hand, using the lowest possible version lets the protocol work on a wider range of robot software versions. For example, a protocol that uses the Heater\\-Shaker and specifies version 2\\.13 of the API should work equally well on a robot running version 6\\.1\\.0 or 6\\.2\\.0 of the robot software. Specifying version 2\\.14 would limit the protocol to robots running 6\\.2\\.0 or higher.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2269, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ca903758-010a-47e1-acce-16a4043df791": {"__data__": {"id_": "ca903758-010a-47e1-acce-16a4043df791", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9d2dc5ed-5e92-475b-82b6-56268780b21d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "b33ee6ee2d86cda85f8cefd8789289ad29eb420ca213aa6f7c64166370a358db", "class_name": "RelatedNodeInfo"}}, "text": "Maximum Supported Versions\n\nThe maximum supported API version for your robot is listed in the Opentrons App under **Robots** \\> your robot \\> **Robot Settings** \\> **Advanced**. Before version 6\\.0\\.0 of the app, the same information was listed on your robot\u2019s **Information** card.\n\nIf you upload a protocol that specifies a higher API level than the maximum supported, your robot won\u2019t be able to analyze or run your protocol. You can increase the maximum supported version by updating your robot software and Opentrons App.\n\nOpentrons robots running the latest software (7\\.3\\.0\\) support the following version ranges:\n\n> - **Flex:** version 2\\.15\u20132\\.19\\.\n> - **OT\\-2:** versions 2\\.0\u20132\\.19\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 697, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "591cba89-9e7a-4331-9799-e9b3e319fa38": {"__data__": {"id_": "591cba89-9e7a-4331-9799-e9b3e319fa38", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ec91b65d-e280-46b5-a777-e84d83560d98", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "2832d6c95d88b0e55d63f9577a0f36afee19decb84b94dffeebe08c27f680dfc", "class_name": "RelatedNodeInfo"}}, "text": "API and Robot Software Versions\n\nThis table lists the correspondence between Protocol API versions and robot software versions.\n\n| API Version | Introduced in Robot Software |\n| ----------- | ---------------------------- |\n| 2\\.19       | 7\\.3\\.1                      |\n| 2\\.18       | 7\\.3\\.0                      |\n| 2\\.17       | 7\\.2\\.0                      |\n| 2\\.16       | 7\\.1\\.0                      |\n| 2\\.15       | 7\\.0\\.0                      |\n| 2\\.14       | 6\\.3\\.0                      |\n| 2\\.13       | 6\\.1\\.0                      |\n| 2\\.12       | 5\\.0\\.0                      |\n| 2\\.11       | 4\\.4\\.0                      |\n| 2\\.10       | 4\\.3\\.0                      |\n| 2\\.9        | 4\\.1\\.0                      |\n| 2\\.8        | 4\\.0\\.0                      |\n| 2\\.7        | 3\\.21\\.0                     |\n| 2\\.6        | 3\\.20\\.0                     |\n| 2\\.5        | 3\\.19\\.0                     |\n| 2\\.4        | 3\\.17\\.1                     |\n| 2\\.3        | 3\\.17\\.0                     |\n| 2\\.2        | 3\\.16\\.0                     |\n| 2\\.1        | 3\\.15\\.2                     |\n| 2\\.0        | 3\\.14\\.0                     |\n| 1\\.0        | 3\\.0\\.0                      |", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1211, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "70ad93a9-8073-4e58-8868-d8e7559ea8b9": {"__data__": {"id_": "70ad93a9-8073-4e58-8868-d8e7559ea8b9", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d47ef1f0-3a24-4e62-98eb-f2d4f4e64515", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "e12d9375bbff5c6a63d9808ecec5bcfae9c3b0e7d4d834465b4031a032a9df8b", "class_name": "RelatedNodeInfo"}}, "text": "Changes in API Versions", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 25, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "447bc559-f776-42b6-8228-7e330d6aaac3": {"__data__": {"id_": "447bc559-f776-42b6-8228-7e330d6aaac3", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1067516d-07d0-42fc-a9e2-b5cc0de4fe9a", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "657331dfba7cd7a88619bc3202ee7ad53cc18b9ed876a11071078cfbf36a3945", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.19\n\nOpentrons recommends updating protocols from `apiLevel` 2\\.18 to 2\\.19 to take advantage of improved pipetting behavior.\n\n- This version uses new values for how much a tip overlaps with the pipette nozzle when the pipette picks up tips. This can correct errors caused by the robot positioning the tip slightly lower than intended, potentially making contact with labware. See `pick_up_tip()` for additional details.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 432, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "212eb7f4-b59c-45b9-a864-ddbb25f66fa3": {"__data__": {"id_": "212eb7f4-b59c-45b9-a864-ddbb25f66fa3", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5048901c-dd23-4034-b49a-059813f62608", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "5ba9882352295359dbd443dbbd87908c53dbfbb002fb75274c2027c6f68b2009", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.18\n\n- Define customizable parameters with the new `add_parameters()` function, and access their values on the `ProtocolContext.params` object during a protocol run. See Runtime Parameters and related pages for more information.\n- Move the pipette to positions relative to the top of a trash container. See Position Relative to Trash Containers. The default behavior of `drop_tip()` also accounts for this new possibility.\n- `set_offset()` has been restored to the API with new behavior that applies to labware type\u2013location pairs.\n- Automatic tip tracking is now available for all nozzle configurations.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 616, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3c076ce3-5021-413d-b07e-b3da4772a6f2": {"__data__": {"id_": "3c076ce3-5021-413d-b07e-b3da4772a6f2", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "13f2e3fd-a955-4360-acd1-9761ef014aec", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "c22040a288456498e64d7f724e70497ec664f92a56ea3689c748ccb7963109b8", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.17\n\n- `dispense()` now raises an error if you try to dispense more than `InstrumentContext.current_volume`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 120, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a7a68eab-bb2c-4505-9414-26af70c11169": {"__data__": {"id_": "a7a68eab-bb2c-4505-9414-26af70c11169", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5f65fa5a-be1c-4d4c-841d-71826c3097e8", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "6aff1701e8e9d4c4fe2d3e0d077201619b1ae87be66a4bb737b1435411c8b18a", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.16\n\nThis version introduces new features for Flex and adds and improves methods for aspirating and dispensing. Note that when updating Flex protocols to version 2\\.16, you _must_ load a trash container before dropping tips.\n\n- New features\n\n  - Use `configure_nozzle_layout()` to pick up a single column of tips with the 96\\-channel pipette. See Partial Tip Pickup.\n  - Specify the trash containers attached to your Flex with `load_waste_chute()` and `load_trash_bin()`.\n  - Dispense, blow out, drop tips, and dispose labware in the waste chute. Disposing labware requires the gripper and calling `move_labware()` with `use_gripper=True`.\n  - Perform actions in staging area slots by referencing slots A4 through D4\\. See Deck Slots.\n  - Explicitly command a pipette to `prepare_to_aspirate()`. The API usually prepares pipettes to aspirate automatically, but this is useful for certain applications, like pre\\-wetting routines.\n\n- Improved features\n\n  - `aspirate()`, `dispense()`, and `mix()` will not move any liquid when called with `volume=0`.\n\n- Other changes\n\n  - `ProtocolContext.fixed_trash` and `InstrumentContext.trash_container` now return `TrashBin` objects instead of `Labware` objects.\n  - Flex will no longer automatically drop tips in the trash at the end of a protocol. You can add a `drop_tip()` command to your protocol or use the Opentrons App to drop the tips.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1395, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "77695f86-93ab-4b06-83d1-2e9f653d542d": {"__data__": {"id_": "77695f86-93ab-4b06-83d1-2e9f653d542d", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3b6461a1-c383-4500-a9e6-43f39b6458ac", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "c10fb731f015aa7171e3b3c8f68edabe7181dc72f686b63b16d583691d4196bc", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.15\n\nThis version introduces support for the Opentrons Flex robot, instruments, modules, and labware.\n\n- Flex features\n\n  - Write protocols for Opentrons Flex by declaring `\"robotType\": \"Flex\"` in the new `requirements` dictionary. See the examples in the Tutorial.\n  - `load_instrument()` supports loading Flex 1\\-, 8\\-, and 96\\-channel pipettes. See Loading Pipettes.\n  - The new `move_labware()` method can move labware automatically using the Flex Gripper. You can also move labware manually on Flex.\n  - `load_module()` supports loading the Magnetic Block.\n  - The API does not enforce placement restrictions for the Heater\\-Shaker module on Flex, because it is installed below\\-deck in a module caddy. Pipetting restrictions are still in place when the Heater\\-Shaker is shaking or its labware latch is open.\n  - The new `configure_for_volume()` method can place Flex 50 \u00b5L pipettes in a low\\-volume mode for dispensing very small volumes of liquid. See Volume Modes.\n\n- Flex and OT\\-2 features\n\n  - Optionally specify `apiLevel` in the new `requirements` dictionary (otherwise, specify it in `metadata`).\n  - Optionally specify `\"robotType\": \"OT-2\"` in `requirements`.\n  - Use coordinates or numbers to specify deck slots. These formats match physical labels on Flex and OT\\-2, but you can use either system, regardless of `robotType`.\n  - The new module context `load_adapter()` methods let you load adapters and labware separately on modules, and `ProtocolContext.load_adapter()` lets you load adapters directly in deck slots. See Loading Labware on Adapters.\n  - Move labware manually using `move_labware()`, without having to stop your protocol.\n  - Manual labware moves support moving to or from the new `OFF_DECK` location (outside of the robot).\n  - `ProtocolContext.load_labware()` also accepts `OFF_DECK` as a location. This lets you prepare labware to be moved onto the deck later in a protocol.\n  - The new `push_out` parameter of the `dispense()` method helps ensure that the pipette dispenses all of its liquid when working with very small volumes.\n  - By default, repeated calls to `drop_tip()` cycle through multiple locations above the trash bin to prevent tips from stacking up.\n\n- Bug fixes\n\n  - `InstrumentContext.starting_tip` is now respected on the second and subsequent calls to `InstrumentContext.pick_up_tip()` with no argument.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2372, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6c6f7fdb-ca10-4a39-be7f-0e905c74f8e5": {"__data__": {"id_": "6c6f7fdb-ca10-4a39-be7f-0e905c74f8e5", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1299ce80-d804-4efe-bd44-49226ac327f8", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "d3c41640df2ea01e926eff798011ea8b9cc2968710458cb0638587f30443b6e2", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.14\n\nThis version introduces a new protocol runtime that offers more reliable run control\nand builds a strong foundation for future Protocol API improvements.\n\nSeveral older parts of the Protocol API were deprecated as part of this switchover.\nIf you specify an API version of `2.13` or lower, your protocols will continue to execute on the old runtime.\n\n- Feature additions\n\n  - `ProtocolContext.define_liquid()` and `Well.load_liquid()` added\n    to define different liquid types and add them to wells, respectively.\n\n- Bug fixes\n\n  - `Labware` and `Well` now adhere to the protocol\u2019s API level setting.\n    Prior to this version, they incorrectly ignored the setting.\n  - `InstrumentContext.touch_tip()` will end with the pipette tip in the center of the well\n    instead of on the edge closest to the front of the machine.\n  - `ProtocolContext.load_labware()` now prefers loading user\\-provided labware definitions\n    rather than built\\-in definitions if no explicit `namespace` is specified.\n  - `ProtocolContext.pause()` will now properly wait until you resume the protocol before moving on.\n    In previous versions, the run will not pause until the first call to a different `ProtocolContext` method.\n  - Motion planning has been improved to avoid certain erroneous downward movements,\n    especially when using `InstrumentContext.aspirate()`.\n  - `Labware.reset()` and `Labware.tip_length` will raise useful errors if called on labware that is not a tip rack.\n\n- Removals\n\n  - The `presses` and `increment` arguments of `InstrumentContext.pick_up_tip()` were deprecated.\n    Configure your pipette pick\\-up settings with the Opentrons App, instead.\n  - `InstrumentContext.speed` property was removed.\n    This property tried to allow setting a pipette\u2019s **plunger** speed in mm/s.\n    However, it could only approximately set the plunger speed,\n    because the plunger\u2019s speed is a stepwise function of the volume.\n    Use `InstrumentContext.flow_rate` to set the flow rate in \u00b5L/s, instead.\n  - `load_labware_object()` was removed from module contexts as an unnecessary internal method.\n  - `geometry` was removed from module contexts in favor of\n    `model` and `type` attributes.\n  - `Well.geometry` was removed as unnecessary.\n  - `MagneticModuleContext.calibrate` was removed since it was never needed nor implemented.\n  - The `height` parameter of `MagneticModuleContext.engage()` was removed.\n    Use `offset` or `height_from_base` instead.\n  - `Labware.separate_calibration` and `Labware.set_calibration()` were removed,\n    since they were holdovers from a calibration system that no longer exists.\n  - Various methods and setters were removed that could modify tip state outside of\n    calls to `InstrumentContext.pick_up_tip()` and `InstrumentContext.drop_tip()`.\n    This change allows the robot to track tip usage more completely and reliably.\n    You may still use `Labware.reset()` and `InstrumentContext.reset_tipracks()`\n    to reset your tip racks\u2019 state.\n\n  > - The `Well.has_tip` **setter** was removed. **The getter is still supported.**\n  >   - Internal methods `Labware.use_tips`, `Labware.previous_tip`, and `Labware.return_tips`\n  >     were removed.\n\n  - The `configuration` argument of `ProtocolContext.load_module()` was removed\n    because it made unsafe modifications to the protocol\u2019s geometry system,\n    and the Thermocycler\u2019s \u201csemi\u201d configuration is not officially supported.\n\n- Known limitations\n\n  - `Labware.set_offset()` is not yet supported on this API version.\n    Run protocols via the Opentrons App, instead.\n  - `ProtocolContext.max_speeds` is not yet supported on the API version.\n    Use `InstrumentContext.default_speed` or the per\\-method speed argument, instead.\n  - `InstrumentContext.starting_tip` is not respected on the second and subsequent calls to `InstrumentContext.pick_up_tip()` with no argument.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 3876, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c4a68a3f-5adc-454c-9329-d04beb315b66": {"__data__": {"id_": "c4a68a3f-5adc-454c-9329-d04beb315b66", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9f33c3e1-1e3d-40bb-9815-0ab96dee0e26", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "e924a3cac67a0f661e968dddf10b80bff9431cae163bc82f872c8ab5b6b11b55", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.13\n\n- Adds `HeaterShakerContext` to support the Heater\\-Shaker Module. You can use the load name `heaterShakerModuleV1` with `ProtocolContext.load_module()` to add a Heater\\-Shaker to a protocol.\n- `InstrumentContext.drop_tip()` now has a `prep_after` parameter.\n- `InstrumentContext.home()` may home _both_ pipettes as needed to avoid collision risks.\n- `InstrumentContext.aspirate()` and `InstrumentContext.dispense()` will avoid interacting directly with modules.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 479, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dd007594-e618-4623-8115-5975ec5a9c56": {"__data__": {"id_": "dd007594-e618-4623-8115-5975ec5a9c56", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6fafa2db-d580-4bd6-bf08-2f3b424d1c97", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "3e5519d1820bf23726ff00d00d932aee406523e0d050ad34399ed5d0d708cdd3", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.12\n\n- `ProtocolContext.resume()` has been deprecated.\n- `Labware.set_offset()` has been added to apply labware offsets to protocols run (exclusively) outside of the Opentrons App (Jupyter Notebook and SSH).", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 219, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2693d643-cade-446b-b4d9-b42ad94fc62e": {"__data__": {"id_": "2693d643-cade-446b-b4d9-b42ad94fc62e", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "94eee232-a3ad-4b0f-85ec-afbdc0d5d33a", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "cc48c95dfeb8ebec710a7b5b94a77a85203c2efb20970425a915a600bb9a5db5", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.11\n\n- Attempting to aspirate from or dispense to tip racks will raise an error.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 92, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f459b952-d907-4aad-a92c-b71613ff6a4a": {"__data__": {"id_": "f459b952-d907-4aad-a92c-b71613ff6a4a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "202afc63-7d82-488a-9137-97ceabee5814", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "58908fe55605eaaa80d050c1b0d3c8bc21244744b83f205b2b9be02b8f5a66b3", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.10\n\n- Moving to the same well twice in a row with different pipettes no longer results in strange diagonal movements.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 130, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8b50f6ed-9ce3-4b2d-9c21-aa7aa9122050": {"__data__": {"id_": "8b50f6ed-9ce3-4b2d-9c21-aa7aa9122050", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d33a7aa3-a7c9-4dd3-9912-e6e18ed4ca90", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "2d9ae1b4ea4a7c5adf248573462efd8e10bc8588ad33b9d4e0dfaf10924b7514", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.9\n\n- You can now access certain geometry data regarding a labware\u2019s well via a Well Object. See Well Dimensions for more information.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 146, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e66d3f9b-af1d-40b4-99a2-21fa95e2f55c": {"__data__": {"id_": "e66d3f9b-af1d-40b4-99a2-21fa95e2f55c", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b0a92881-a03c-4afd-8067-ad2ec5a13701", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "7cdcd5bda005a3edffd54abb59137415466ebe467aa6da9697031456089de6a9", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.8\n\n- You can now pass in a list of volumes to distribute and consolidate. See List of Volumes for more information.\n\n  - Passing in a zero volume to any complex command will result in no actions taken for aspirate or dispense\n\n- `Well.from_center_cartesian()` can be used to find a point within a well using normalized distance from the center in each axis.\n\n  - Note that you will need to create a location object to use this function in a protocol. See Labware for more information.\n\n- You can now pass in a blowout location to transfer, distribute, and consolidate\n  with the `blowout_location` parameter. See `InstrumentContext.transfer()` for more detail!", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 673, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "57091c68-9147-4261-86b7-9c91562b01ed": {"__data__": {"id_": "57091c68-9147-4261-86b7-9c91562b01ed", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "579f3294-8ab7-4e22-9588-33471c4a708e", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "24c72b2e062dd5694cd381f425592e64e69b3d49c43833c4d290e2abbced57bd", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.7\n\n- Added `InstrumentContext.pair_with()`, an experimental feature for moving both pipettes simultaneously.\n\nNote\n\nThis feature has been removed from the Python Protocol API.\n\n- Calling `InstrumentContext.has_tip()` will return whether a particular instrument\n  has a tip attached or not.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 302, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c63bac2c-818a-4f66-ae06-44032bde8628": {"__data__": {"id_": "c63bac2c-818a-4f66-ae06-44032bde8628", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ac29e2b5-71ce-4c38-a656-c33875238965", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "2f45107302c9c6f46336758b48d32f32f8dc49a0575a51c463c60a419315bff5", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.6\n\n- GEN2 Single pipettes now default to flow rates equivalent to 10 mm/s plunger\n  speeds\n\n      + Protocols that manually configure pipette flow rates will be unaffected\n      + For a comparison between API Versions, see OT\\-2 Pipette Flow Rates", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 260, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "200ce9dd-cd00-4851-a923-7824a527cf44": {"__data__": {"id_": "200ce9dd-cd00-4851-a923-7824a527cf44", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a84485c9-b380-493a-b067-094fdd376094", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "e1b81cc6b3fb0981dcf450e4de799a69e3dee73bbc96b4d262bf7eb7582076ca", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.5\n\n- New utility commands were added:\n\n  - `ProtocolContext.set_rail_lights()`: turns robot rail lights on or off\n  - `ProtocolContext.rail_lights_on`: describes whether or not the rail lights are on\n  - `ProtocolContext.door_closed`: describes whether the robot door is closed", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 290, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9918a549-33d8-4cc3-8582-0b6258c2cdda": {"__data__": {"id_": "9918a549-33d8-4cc3-8582-0b6258c2cdda", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "756f8435-bab7-4990-938d-0a5c79c41202", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "22991bf0dcc79e14d529f8aca8c3ac6ed78621824af0a954c65b772f2e3f4b07", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.4\n\n- The following improvements were made to the `touch_tip` command:\n\n  - The speed for `touch_tip` can now be lowered down to 1 mm/s\n  - `touch_tip` no longer moves diagonally from the X direction \\-\\> Y direction\n  - Takes into account geometry of the deck and modules", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 284, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "61111df3-ee09-4924-88bd-a283ae67baa3": {"__data__": {"id_": "61111df3-ee09-4924-88bd-a283ae67baa3", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a7566768-83eb-430b-8927-cf27b0116b87", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "223aa027a3719b847d7073d828c80813b030c17a85403e688b81caeada7ba11f", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.3\n\n- Magnetic Module GEN2 and Temperature Module GEN2 are now supported; you can load them with the names `\"magnetic module gen2\"` and `\"temperature module gen2\"`, respectively.\n- All pipettes will return tips to tip racks from a higher position to avoid\n  possible collisions.\n- During a `mix()`, the pipette will no longer move up to clear the liquid in\n  between every dispense and following aspirate.\n- You can now access the Temperature Module\u2019s status via `TemperatureModuleContext.status`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 509, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "38186da5-60a4-45a8-838e-ae5dd6b24b89": {"__data__": {"id_": "38186da5-60a4-45a8-838e-ae5dd6b24b89", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "947440ab-25f3-4da8-8d46-0b6010cf4c1d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "2fdddc394608b5ad87223efbac68eebc542f9896108a11241781d68c8250963e", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.2\n\n- You should now specify Magnetic Module engage height using the\n  `height_from_base` parameter, which specifies the height of the top of the\n  magnet from the base of the labware. For more, see Engaging and Disengaging.\n- Return tip will now use pre\\-defined heights from hardware testing. For more information, see Returning a Tip.\n- When using the return tip function, tips are no longer added back into the tip tracker. For more information, see Returning a Tip.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 482, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "215b168b-72e7-444b-93c7-933264a3875a": {"__data__": {"id_": "215b168b-72e7-444b-93c7-933264a3875a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "11392ab1-c733-4b0e-a3b4-51b914143cd2", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "33f1cbe30588d63a6869f6ee4337ae27ce1b651f8b035c786d350045add5e0a6", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.1\n\n- When loading labware onto a module, you can now specify a label with the `label` parameter of\n  `MagneticModuleContext.load_labware()`,\n  `TemperatureModuleContext.load_labware()`, or\n  `ThermocyclerContext.load_labware()`,\n  just like you can when loading labware onto the deck with `ProtocolContext.load_labware()`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 335, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4b8efd40-5180-4c76-b048-33e6a84cf9eb": {"__data__": {"id_": "4b8efd40-5180-4c76-b048-33e6a84cf9eb", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "677686d6-dcff-4e7e-aa22-8aab50d5c9d5", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "4b5aa71553276801fe40a5e11c2d8fce0d6401512128cc802b31c52bda1eeb47", "class_name": "RelatedNodeInfo"}}, "text": "Version 2\\.0\n\nVersion 2 of the API is a new way to write Python protocols, with support for new modules like the Thermocycler. To transition your protocols from version 1 to version 2 of the API, follow this migration guide.\n\nWe\u2019ve also published a more in\\-depth discussion of why we developed version 2 of the API and how it differs from version 1\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 353, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6d498364-56fb-49a3-92d2-30f2838277de": {"__data__": {"id_": "6d498364-56fb-49a3-92d2-30f2838277de", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "282ac654-91de-4776-80e2-e59a4f83193d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "9a69aba484fd23c0469eeb0941d579bbb793bc301525b663867af5e4d3f93b73", "class_name": "RelatedNodeInfo"}}, "text": "Labware\n\nLabware are the durable or consumable items that you work with, reuse, or discard while running a protocol on a Flex or OT\\-2\\. Items such as pipette tips, well plates, tubes, and reservoirs are all examples of labware. This section provides a brief overview of default labware, custom labware, and how to use basic labware API methods when creating a protocol for your robot.\n\nNote\n\nCode snippets use coordinate deck slot locations (e.g. `\"D1\"`, `\"D2\"`), like those found on Flex. If you have an OT\\-2 and are using API version 2\\.14 or earlier, replace the coordinate with its numeric OT\\-2 equivalent. For example, slot D1 on Flex corresponds to slot 1 on an OT\\-2\\. See Deck Slots for more information.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 717, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "344aec64-60fe-407b-ae79-06d2111587c0": {"__data__": {"id_": "344aec64-60fe-407b-ae79-06d2111587c0", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "31631f53-39eb-4bab-a03d-f24041756d15", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "eb37c3f4a19eb5f7cedcf5f7bb99f3b18999829410789cca8526456d03b16284", "class_name": "RelatedNodeInfo"}}, "text": "Labware Types", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 15, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6027dcb1-2584-4d20-be83-dddf8b581639": {"__data__": {"id_": "6027dcb1-2584-4d20-be83-dddf8b581639", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c4ff6a2c-3797-4ee0-bbf5-5b1849d8c328", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "e747b25f0bddbe0d43999ce0d04c2137d1da402c92bf2d816a24d6c4f6071f3f", "class_name": "RelatedNodeInfo"}}, "text": "Default Labware\n\nDefault labware is everything listed in the Opentrons Labware Library. When used in a protocol, your Flex or OT\\-2 knows how to work with default labware. However, you must first inform the API about the labware you will place on the robot\u2019s deck. Search the library when you\u2019re looking for the API load names of the labware you want to use. You can copy the load names from the library and pass them to the `load_labware()` method in your protocol.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 468, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "57ad1753-d494-445f-b1be-3187ea8a43ba": {"__data__": {"id_": "57ad1753-d494-445f-b1be-3187ea8a43ba", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b20bab95-1850-421a-a785-1f6b1665520d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "640145ad9ae74332ac695c84d2a79b282db396e311960cff872d093357bffd05", "class_name": "RelatedNodeInfo"}}, "text": "Custom Labware\n\nCustom labware is labware that is not listed the Labware Library. If your protocol needs something that\u2019s not in the library, you can create it with the Opentrons Labware Creator. However, before using the Labware Creator, you should take a moment to review the support article Creating Custom Labware Definitions.\n\nAfter you\u2019ve created your labware, save it as a `.json` file and add it to the Opentrons App. See Using Labware in Your Protocols for instructions.\n\nIf other people need to use your custom labware definition, they must also add it to their Opentrons App.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 588, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9abf3c38-9bb4-49c9-abea-0bfd7aaf0920": {"__data__": {"id_": "9abf3c38-9bb4-49c9-abea-0bfd7aaf0920", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2eec6d88-96a5-4ebf-80ae-3084489084c6", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "5c1639d79bf88b6045011d78b6689b707af76169e896d27889975dce9a3472ec", "class_name": "RelatedNodeInfo"}}, "text": "Loading Labware\n\nThroughout this section, we\u2019ll use the labware listed in the following table.\n\n| Labware type   | Labware name                                                                                        | API load name                     |\n| -------------- | --------------------------------------------------------------------------------------------------- | --------------------------------- |\n| Well plate     | Corning 96 Well Plate 360 \u00b5L Flat | `corning_96_wellplate_360ul_flat` |\n| Flex tip rack  | Opentrons Flex 96 Tips 200 \u00b5L              | `opentrons_flex_96_tiprack_200ul` |\n| OT\\-2 tip rack | Opentrons 96 Tip Rack 300 \u00b5L            | `opentrons_96_tiprack_300ul`      |\n\nSimilar to the code sample in How the API Works, here\u2019s how you use the `ProtocolContext.load_labware()` method to load labware on either Flex or OT\\-2\\.\n\n```\n#Flex\ntiprack = protocol.load_labware(\"opentrons_flex_96_tiprack_200ul\", \"D1\")\nplate = protocol.load_labware(\"corning_96_wellplate_360ul_flat\", \"D2\")\n\n```\n\n```\n#OT-2\ntiprack = protocol.load_labware(\"opentrons_96_tiprack_300ul\", \"1\")\nplate = protocol.load_labware(\"corning_96_wellplate_360ul_flat\", \"2\")\n\n```\n\nNew in version 2\\.0\\.\n\nWhen the `load_labware` method loads labware into your protocol, it returns a `Labware` object.\n\nTip\n\nThe `load_labware` method includes an optional `label` argument. You can use it to identify labware with a descriptive name. If used, the label value is displayed in the Opentrons App. For example:\n\n```\ntiprack = protocol.load_labware(\n    load_name=\"corning_96_wellplate_360ul_flat\",\n    location=\"D1\",\n    label=\"any-name-you-want\")\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1633, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9a4d4676-2fbf-4d82-8233-21eaa4bd674c": {"__data__": {"id_": "9a4d4676-2fbf-4d82-8233-21eaa4bd674c", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "88dc04a6-a0a0-43fb-8661-a06c018980f5", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "530ca137fce27df8c80c6a3e0d746976aea70e802cc0554a4ffbe3a8f8f691d3", "class_name": "RelatedNodeInfo"}}, "text": "Loading Labware on Adapters\n\nThe previous section demonstrates loading labware directly into a deck slot. But you can also load labware on top of an adapter that either fits on a module or goes directly on the deck. The ability to combine labware with adapters adds functionality and flexibility to your robot and protocols.\n\nYou can either load the adapter first and the labware second, or load both the adapter and labware all at once.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 439, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7add000c-a7f1-44eb-b8c3-e658482e13ba": {"__data__": {"id_": "7add000c-a7f1-44eb-b8c3-e658482e13ba", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6d13b8ba-18bd-490f-9c2d-9d549550d782", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "b4019291c957a200abaebd0b21fb497fe711200fb1bdbd3dab163a2dc642558b", "class_name": "RelatedNodeInfo"}}, "text": "Loading Separately\n\nThe `load_adapter()` method is available on `ProtocolContext` and module contexts. It behaves similarly to `load_labware()`, requiring the load name and location for the desired adapter. Load a module, adapter, and labware with separate calls to specify each layer of the physical stack of components individually:\n\n```\nhs_mod = protocol.load_module(\"heaterShakerModuleV1\", \"D1\")\nhs_adapter = hs_mod.load_adapter(\"opentrons_96_flat_bottom_adapter\")\nhs_plate = hs_adapter.load_labware(\"nest_96_wellplate_200ul_flat\")\n\n```\n\nNew in version 2\\.15: The `load_adapter()` method.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 594, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a4513569-7d04-4939-9534-49c886c375b2": {"__data__": {"id_": "a4513569-7d04-4939-9534-49c886c375b2", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "205d6cb1-d53d-4cb4-bfee-6d7cb87d2c02", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "6aa5df57405d3d694a2b2eb4aba2bc98fcbd3b5d0b91add7219c8d83997fbcab", "class_name": "RelatedNodeInfo"}}, "text": "Loading Together\n\nUse the `adapter` argument of `load_labware()` to load an adapter at the same time as labware. For example, to load the same 96\\-well plate and adapter from the previous section at once:\n\n```\nhs_plate = hs_mod.load_labware(\n    name=\"nest_96_wellplate_200ul_flat\",\n    adapter=\"opentrons_96_flat_bottom_adapter\"\n)\n\n```\n\nNew in version 2\\.15: The `adapter` parameter.\n\nThe API also has some \u201ccombination\u201d labware definitions, which treat the adapter and labware as a unit:\n\n```\nhs_combo = hs_mod.load_labware(\n    \"opentrons_96_flat_bottom_adapter_nest_wellplate_200ul_flat\"\n)\n\n```\n\nLoading labware this way prevents you from moving the labware onto or off of the adapter, so it\u2019s less flexible than loading the two separately. Avoid using combination definitions unless your protocol specifies an `apiLevel` of 2\\.14 or lower.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 846, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "45483488-f867-487e-bb35-5614a6143edb": {"__data__": {"id_": "45483488-f867-487e-bb35-5614a6143edb", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6c369cc3-8892-4b09-a524-b043d002b7a1", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "2eb68fd069aa0a351df6ac566533d31d1d15df138ba0d3ae4df2d804f61908d1", "class_name": "RelatedNodeInfo"}}, "text": "Accessing Wells in Labware", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 28, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a5ed50da-540b-42b4-8a51-03e1b47f79ba": {"__data__": {"id_": "a5ed50da-540b-42b4-8a51-03e1b47f79ba", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6306ae25-5d84-4f9b-b0d8-b5c649ac9a23", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "8a2aea80861798cbe2ea4f26af49f579707c32d134c995bebc42b9baf18a6b41", "class_name": "RelatedNodeInfo"}}, "text": "Well Ordering\n\nYou need to select which wells to transfer liquids to and from over the course of a protocol.\n\nRows of wells on a labware have labels that are capital letters starting with A. For instance, an 96\\-well plate has 8 rows, labeled `\"A\"` through `\"H\"`.\n\nColumns of wells on a labware have labels that are numbers starting with 1\\. For instance, a 96\\-well plate has columns `\"1\"` through `\"12\"`.\n\nAll well\\-accessing functions start with the well at the top left corner of the labware. The ending well is in the bottom right. The order of travel from top left to bottom right depends on which function you use.\n\nThe code in this section assumes that `plate` is a 24\\-well plate. For example:\n\n```\nplate = protocol.load_labware(\"corning_24_wellplate_3.4ml_flat\", location=\"D1\")\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 794, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7b3d3d1e-1041-48f6-a443-50b76cfacd71": {"__data__": {"id_": "7b3d3d1e-1041-48f6-a443-50b76cfacd71", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "04c427d9-e2fa-41bd-baec-a4a7a317660b", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "32cb225619d5ae73006c67f79dc6f850cd10ab5cd5272730ce4fc448b62c68ae", "class_name": "RelatedNodeInfo"}}, "text": "Accessor Methods\n\nThe API provides many different ways to access wells inside labware. Different methods are useful in different contexts. The table below lists out the methods available to access wells and their differences.\n\n| Method                                                                                                                                    | Returns                               | Example                                                                |\n| ----------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------- | ---------------------------------------------------------------------- |\n| `Labware.wells()`                               | List of all wells.                    | `[labware:A1, labware:B1, labware:C1...]`                              |\n| `Labware.rows()`                                  | List of lists grouped by row.         | `[[labware:A1, labware:A2...], [labware:B1, labware:B2...]]`           |\n| `Labware.columns()`                         | List of lists grouped by column.      | `[[labware:A1, labware:B1...], [labware:A2, labware:B2...]]`           |\n| `Labware.wells_by_name()`       | Dictionary with well names as keys.   | `{\"A1\": labware:A1, \"B1\": labware:B1}`                                 |\n| `Labware.rows_by_name()`          | Dictionary with row names as keys.    | `{\"A\": [labware:A1, labware:A2...], \"B\": [labware:B1, labware:B2...]}` |\n| `Labware.columns_by_name()` | Dictionary with column names as keys. | `{\"1\": [labware:A1, labware:B1...], \"2\": [labware:A2, labware:B2...]}` |", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1676, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "28726f90-f670-4016-bff0-fd983af10963": {"__data__": {"id_": "28726f90-f670-4016-bff0-fd983af10963", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "aab510f8-68e5-4a6b-9dfc-bc62ea31bd0e", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "fceb19012133938bff7274c61a272131cc0be8ede311873a71327d62d52561a3", "class_name": "RelatedNodeInfo"}}, "text": "Accessing Individual Wells", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 28, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "28a2bfc9-b7ba-4b20-bf32-12e69a7d5117": {"__data__": {"id_": "28a2bfc9-b7ba-4b20-bf32-12e69a7d5117", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6ef1cfef-1436-4538-bdbf-ab280b7e469a", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "996fe8a957f952f67ad0f20e42c3def59258bc073ee379d6116a24215551f35d", "class_name": "RelatedNodeInfo"}}, "text": "Dictionary Access\n\nThe simplest way to refer to a single well is by its `well_name`, like A1 or D6\\. Referencing a particular key in the result of `Labware.wells_by_name()` accomplishes this. This is such a common task that the API also has an equivalent shortcut: dictionary indexing.\n\n```\na1 = plate.wells_by_name()[\"A1\"]\nd6 = plate[\"D6\"]  # dictionary indexing\n\n```\n\nIf a well does not exist in the labware, such as `plate[\"H12\"]` on a 24\\-well plate, the API will raise a `KeyError`. In contrast, it would be a valid reference on a standard 96\\-well plate.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 585, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "88966cf8-3991-4ddf-81e1-962fcbae103e": {"__data__": {"id_": "88966cf8-3991-4ddf-81e1-962fcbae103e", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f72abc19-8b18-4335-8881-c297dc1163f2", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "50fcc66c01bced7be3948af152a92d3bb472d422d5f228c329b8c7e30fc931f3", "class_name": "RelatedNodeInfo"}}, "text": "List Access From `wells`\n\nIn addition to referencing wells by name, you can also reference them with zero\\-indexing. The first well in a labware is at position 0\\.\n\n```\nplate.wells()[0]   # well A1\nplate.wells()[23]  # well D6\n\n```\n\nTip\n\nYou may find coordinate well names like `\"B3\"` easier to reason with, especially when working with irregular labware, e.g.\n`opentrons_10_tuberack_falcon_4x50ml_6x15ml_conical` (see the Opentrons 10 Tube Rack in the Labware Library). Whichever well access method you use, your protocol will be most maintainable if you use only one access method consistently.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 621, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d0ef0f79-241d-415f-8ac2-2541f79d1f1a": {"__data__": {"id_": "d0ef0f79-241d-415f-8ac2-2541f79d1f1a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0cae6ee2-b850-44c1-bf99-694cee68a4b6", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "c9f7f14f8b79ff7ae0b29ee66a43cac4df0883b99b5787b5cc1c3a4dcbdd2648", "class_name": "RelatedNodeInfo"}}, "text": "Accessing Groups of Wells\n\nWhen handling liquid, you can provide a group of wells as the source or destination. Alternatively, you can take a group of wells and loop (or iterate) through them, with each liquid\\-handling command inside the loop accessing the loop index.\n\nUse `Labware.rows_by_name()` to access a specific row of wells or `Labware.columns_by_name()` to access a specific column of wells on a labware. These methods both return a dictionary with the row or column name as the keys:\n\n```\nrow_dict = plate.rows_by_name()[\"A\"]\nrow_list = plate.rows()[0]  # equivalent to the line above\ncolumn_dict = plate.columns_by_name()[\"1\"]\ncolumn_list = plate.columns()[0]  # equivalent to the line above\n\nprint('Column \"1\" has', len(column_dict), 'wells')  # Column \"1\" has 4 wells\nprint('Row \"A\" has', len(row_dict), 'wells')  # Row \"A\" has 6 wells\n\n```\n\nSince these methods return either lists or dictionaries, you can iterate through them as you would regular Python data structures.\n\nFor example, to transfer 50 \u00b5L of liquid from the first well of a reservoir to each of the wells of row `\"A\"` on a plate:\n\n```\nfor well in plate.rows()[0]:\n    pipette.transfer(reservoir[\"A1\"], well, 50)\n\n```\n\nEquivalently, using `rows_by_name`:\n\n```\nfor well in plate.rows_by_name()[\"A\"].values():\n    pipette.transfer(reservoir[\"A1\"], well, 50)\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1365, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fbf33eaf-9f7b-4509-b47a-611f4d7a50aa": {"__data__": {"id_": "fbf33eaf-9f7b-4509-b47a-611f4d7a50aa", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e2716b63-d299-4465-8e6e-d976bf37e9d0", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "668af6fbf34e65ec32694ba06d83b8c672a8fca41ef7f47d302687b8003deea5", "class_name": "RelatedNodeInfo"}}, "text": "Labeling Liquids in Wells\n\nOptionally, you can specify the liquids that should be in various wells at the beginning of your protocol. Doing so helps you identify well contents by name and volume, and adds corresponding labels to a single well, or group of wells, in well plates and reservoirs. You can view the initial liquid setup:\n\n- For Flex protocols, on the touchscreen.\n- For Flex or OT\\-2 protocols, in the Opentrons App (v6\\.3\\.0 or higher).\n\nTo use these optional methods, first create a liquid object with `ProtocolContext.define_liquid()` and then label individual wells by calling `Well.load_liquid()`.\n\nLet\u2019s examine how these two methods work. The following examples demonstrate how to define colored water samples for a well plate and reservoir.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 762, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "57b62286-fd01-47f0-8674-2b80a9fee898": {"__data__": {"id_": "57b62286-fd01-47f0-8674-2b80a9fee898", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6bb63a31-b4ce-4b00-8efd-307768f04424", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "0ae7f7eb46f711969cae986331bc01ebea75f119330c37bc16d888aa4ff7995e", "class_name": "RelatedNodeInfo"}}, "text": "Defining Liquids\n\nThis example uses `define_liquid` to create two liquid objects and instantiates them with the variables `greenWater` and `blueWater`, respectively. The arguments for `define_liquid` are all required, and let you name the liquid, describe it, and assign it a color:\n\n```\ngreenWater = protocol.define_liquid(\n    name=\"Green water\",\n    description=\"Green colored water for demo\",\n    display_color=\"#00FF00\",\n)\nblueWater = protocol.define_liquid(\n    name=\"Blue water\",\n    description=\"Blue colored water for demo\",\n    display_color=\"#0000FF\",\n)\n\n```\n\nNew in version 2\\.14\\.\n\nThe `display_color` parameter accepts a hex color code, which adds a color to that liquid\u2019s label when you import your protocol into the Opentrons App. The `define_liquid` method accepts standard 3\\-, 4\\-, 6\\-, and 8\\-character hex color codes.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 841, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4b27a462-6514-4a2e-9d97-0bbd7039f65a": {"__data__": {"id_": "4b27a462-6514-4a2e-9d97-0bbd7039f65a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e3796c9c-ffdd-423d-8b76-118a05663bb5", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "a9c851a563b282a648a0db1ec7fe0c15b67dd99bb65d7b0ff3ce76b86afaa31f", "class_name": "RelatedNodeInfo"}}, "text": "Labeling Wells and Reservoirs\n\nThis example uses `load_liquid` to label the initial well location, contents, and volume (in \u00b5L) for the liquid objects created by `define_liquid`. Notice how values of the `liquid` argument use the variable names `greenWater` and `blueWater` (defined above) to associate each well with a particular liquid:\n\n```\nwell_plate[\"A1\"].load_liquid(liquid=greenWater, volume=50)\nwell_plate[\"A2\"].load_liquid(liquid=greenWater, volume=50)\nwell_plate[\"B1\"].load_liquid(liquid=blueWater, volume=50)\nwell_plate[\"B2\"].load_liquid(liquid=blueWater, volume=50)\nreservoir[\"A1\"].load_liquid(liquid=greenWater, volume=200)\nreservoir[\"A2\"].load_liquid(liquid=blueWater, volume=200)\n\n```\n\nNew in version 2\\.14\\.\n\nThis information is available after you import your protocol to the app or send it to Flex. A summary of liquids appears on the protocol detail page, and well\\-by\\-well detail is available on the run setup page (under Initial Liquid Setup in the app, or under Liquids on Flex).\n\nNote\n\n`load_liquid` does not validate volume for your labware nor does it prevent you from adding multiple liquids to each well. For example, you could label a 40 \u00b5L well with `greenWater`, `volume=50`, and then also add blue water to the well. The API won\u2019t stop you. It\u2019s your responsibility to ensure the labels you use accurately reflect the amounts and types of liquid you plan to place into wells and reservoirs.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1424, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7c5075f5-b0a0-4bf2-8a6e-9e429113717b": {"__data__": {"id_": "7c5075f5-b0a0-4bf2-8a6e-9e429113717b", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2a55f44f-4fbf-499d-b815-f9c2877a8d0e", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "09d9025ef903ca77fe1d45d632a888b35d5f48294e86aa0a743c18bfddfd1004", "class_name": "RelatedNodeInfo"}}, "text": "Labeling vs Handling Liquids\n\nThe `load_liquid` arguments include a volume amount (`volume=n` in \u00b5L). This amount is just a label. It isn\u2019t a command or function that manipulates liquids. It only tells you how much liquid should be in a well at the start of the protocol. You need to use a method like `transfer()` to physically move liquids from a source to a destination.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 375, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5a2a09af-531c-4eaf-a0cf-72b66d0392ef": {"__data__": {"id_": "5a2a09af-531c-4eaf-a0cf-72b66d0392ef", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7361c261-b009-427a-81ba-edcfdda667e6", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "f96bc55ffa259d9d67e448124a27722f9829cf0b2d3b9a112ad2f7574775f70f", "class_name": "RelatedNodeInfo"}}, "text": "Well Dimensions\n\nThe functions in the Accessing Wells in Labware section above return a single `Well` object or a larger object representing many wells. `Well` objects have attributes that provide information about their physical shape, such as the depth or diameter, as specified in their corresponding labware definition. These properties can be used for different applications, such as calculating the volume of a well or a position relative to the well.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 459, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ace66c16-e8e3-44c4-adff-1260bfe4f840": {"__data__": {"id_": "ace66c16-e8e3-44c4-adff-1260bfe4f840", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e47aa32b-4c2b-455f-a134-d242e27199ed", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "2a6b2480e01ba5a0a76042a6f2b2f7fba2962416a1caf6cf18caf38c71bf02a8", "class_name": "RelatedNodeInfo"}}, "text": "Depth\n\nUse `Well.depth` to get the distance in mm between the very top of the well and the very bottom. For example, a conical well\u2019s depth is measured from the top center to the bottom center of the well.\n\n```\nplate = protocol.load_labware(\"corning_96_wellplate_360ul_flat\", \"D1\")\ndepth = plate[\"A1\"].depth  # 10.67\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 323, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1801eede-81f2-4a73-8714-3929e604cea9": {"__data__": {"id_": "1801eede-81f2-4a73-8714-3929e604cea9", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "00d870b8-cbb0-4d7d-a350-496c3e19a1bd", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "07d0b9f27f4bbe7e0ef87fa28fab775fc38287dd69bdd2d59046b928159da20e", "class_name": "RelatedNodeInfo"}}, "text": "Diameter\n\nUse `Well.diameter` to get the diameter of a given well in mm. Since diameter is a circular measurement, this attribute is only present on labware with circular wells. If the well is not circular, the value will be `None`. Use length and width (see below) for non\\-circular wells.\n\n```\nplate = protocol.load_labware(\"corning_96_wellplate_360ul_flat\", \"D1\")\ndiameter = plate[\"A1\"].diameter      # 6.86\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 417, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1c749976-1c14-436c-9927-d5418b73805b": {"__data__": {"id_": "1c749976-1c14-436c-9927-d5418b73805b", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "11382185-80cf-4e29-9b32-e96ab039e973", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "100549f8788c74d369ef4f969d4d2486ff9df3b536ccdaf3756c1f908fbf3502", "class_name": "RelatedNodeInfo"}}, "text": "Length\n\nUse `Well.length` to get the length of a given well in mm. Length is defined as the distance along the robot\u2019s x\\-axis (left to right). This attribute is only present on rectangular wells. If the well is not rectangular, the value will be `None`. Use diameter (see above) for circular wells.\n\n```\nplate = protocol.load_labware(\"nest_12_reservoir_15ml\", \"D1\")\nlength = plate[\"A1\"].length  # 8.2\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 408, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "64fd41b5-bf91-40ef-9675-a2b23bfee199": {"__data__": {"id_": "64fd41b5-bf91-40ef-9675-a2b23bfee199", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6c334337-2220-4f84-a1ff-d0d977582906", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "987312c509b1f4a85da0397a57e8e4d727cc881a298931b81eb3a027b84f4279", "class_name": "RelatedNodeInfo"}}, "text": "Width\n\nUse `Well.width` to get the width of a given well in mm. Width is defined as the distance along the y\\-axis (front to back). This attribute is only present on rectangular wells. If the well is not rectangular, the value will be `None`. Use diameter (see above) for circular wells.\n\n```\nplate = protocol.load_labware(\"nest_12_reservoir_15ml\", \"D1\")\nwidth = plate[\"A1\"].width  # 71.2\n\n```\n\nNew in version 2\\.9\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 418, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "257afe00-9c68-43ce-bb95-d0cbca2e23d7": {"__data__": {"id_": "257afe00-9c68-43ce-bb95-d0cbca2e23d7", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0b0fe093-dce4-4605-9bee-82c42074f1eb", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "238e24fafb1a0855040c43e3adb87cbc6c85cbd5d73af5572079293040ade16f", "class_name": "RelatedNodeInfo"}}, "text": "Moving Labware\n\nYou can move an entire labware (and all of its contents) from one deck slot to another at any point during your protocol. On Flex, you can either use the gripper or move the labware manually. On OT\\-2, you can can only move labware manually, since it doesn\u2019t have a gripper instrument.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 303, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f6fd86de-3321-464e-9e49-b7875248ed94": {"__data__": {"id_": "f6fd86de-3321-464e-9e49-b7875248ed94", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8f18e61c-5f3d-499b-8a20-e029fb61b208", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "08be2c33d2330a2e09d71f027d9d639e00f7fd3011cb1891b60a873b96cbe61e", "class_name": "RelatedNodeInfo"}}, "text": "Basic Movement\n\nUse the `ProtocolContext.move_labware()` method to initiate a move, regardless of whether it uses the gripper.\n\n```\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\"nest_96_wellplate_200ul_flat\", \"D1\")\n    protocol.move_labware(labware=plate, new_location=\"D2\")\n\n```\n\nNew in version 2\\.15\\.\n\nThe required arguments of `move_labware()` are the `labware` you want to move and its `new_location`. You don\u2019t need to specify where the move begins, since that information is already stored in the `Labware` object \u2014 `plate` in this example. The destination of the move can be any empty deck slot, or a module that\u2019s ready to have labware added to it (see Movement with Modules below). Movement to an occupied location, including the labware\u2019s current location, will raise an error.\n\nWhen the move step is complete, the API updates the labware\u2019s location, so you can move the plate multiple times:\n\n```\nprotocol.move_labware(labware=plate, new_location=\"D2\")\nprotocol.move_labware(labware=plate, new_location=\"D3\")\n\n```\n\nFor the first move, the API knows to find the plate in its initial load location, slot D1\\. For the second move, the API knows to find the plate in D2\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1219, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b86c41ed-f1fc-4f91-b92d-74ec2c7034bf": {"__data__": {"id_": "b86c41ed-f1fc-4f91-b92d-74ec2c7034bf", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c62e1dee-ebc0-4f4f-98cc-5c99dac80529", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "a62cd229a1f683b6dd3124ff7a266e32f798b1907d2cf5abb4d7be33fcf0823d", "class_name": "RelatedNodeInfo"}}, "text": "Automatic vs Manual Moves\n\nThere are two ways to move labware:\n\n- Automatically, with the Opentrons Flex Gripper.\n- Manually, by pausing the protocol until a user confirms that they\u2019ve moved the labware.\n\nThe `use_gripper` parameter of `move_labware()` determines whether a movement is automatic or manual. Set its value to `True` for an automatic move. The default value is `False`, so if you don\u2019t specify a value, the protocol will pause for a manual move.\n\n```\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\"nest_96_wellplate_200ul_flat\", \"D1\")\n\n    # have the gripper move the plate from D1 to D2\n    protocol.move_labware(labware=plate, new_location=\"D2\", use_gripper=True)\n\n    # pause to move the plate manually from D2 to D3\n    protocol.move_labware(labware=plate, new_location=\"D3\", use_gripper=False)\n\n    # pause to move the plate manually from D3 to C1\n    protocol.move_labware(labware=plate, new_location=\"C1\")\n\n```\n\nNew in version 2\\.15\\.\n\nNote\n\nDon\u2019t add a `pause()` command before `move_labware()`. When `use_gripper` is unset or `False`, the protocol pauses when it reaches the movement step. The Opentrons App or the touchscreen on Flex shows an animation of the labware movement that you need to perform manually. The protocol only resumes when you press **Confirm and resume**.\n\nThe above example is a complete and valid `run()` function. You don\u2019t have to load the gripper as an instrument, and there is no `InstrumentContext` for the gripper. All you have to do to specify that a protocol requires the gripper is to include at least one `move_labware()` command with `use_gripper=True`.\n\nIf you attempt to use the gripper to move labware in an OT\\-2 protocol, the API will raise an error.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1752, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "026546e7-181a-4206-90ed-120461f65c38": {"__data__": {"id_": "026546e7-181a-4206-90ed-120461f65c38", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2be3e37e-fb2a-4504-a589-8c14055853ef", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "83407e5157d08d3ac53347363d9ab8f944218bb592f2804afd205f46f2a02a82", "class_name": "RelatedNodeInfo"}}, "text": "Supported Labware\n\nYou can manually move any standard or custom labware. Using the gripper to move the following labware is fully supported by Opentrons:\n\n| Labware Type                | API Load Names                                                                                                                                                                                                                            |\n| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Full\\-skirt PCR plates      | _ `armadillo_96_wellplate_200ul_pcr_full_skirt` _ `opentrons_96_wellplate_200ul_pcr_full_skirt`                                                                                                                                           |\n| NEST well plates            | _ `nest_96_wellplate_200ul_flat` _ `nest_96_wellplate_2ml_deep`                                                                                                                                                                           |\n| Opentrons Flex 96 Tip Racks | _ `opentrons_flex_96_tiprack_50ul` _ `opentrons_flex_96_tiprack_200ul` _ `opentrons_flex_96_tiprack_1000ul` _ `opentrons_flex_96_filtertiprack_50ul` _ `opentrons_flex_96_filtertiprack_200ul` _ `opentrons_flex_96_filtertiprack_1000ul` |\n\nThe gripper may work with other ANSI/SLAS standard labware, but this is not recommended.\n\nNote\n\nThe labware definitions listed above include information about the position and force that the gripper uses to pick up the labware. The gripper uses default values for labware definitions that don\u2019t include position and force information. The Python Protocol API won\u2019t raise a warning or error if you try to grip and move other types of labware.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1939, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c3b6ca63-6d23-4976-94cd-8580e6503e61": {"__data__": {"id_": "c3b6ca63-6d23-4976-94cd-8580e6503e61", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a3f10417-72a7-4462-8ee0-440e39a24ab2", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "7ed84b07a4f626ea14cbd4735651f33fbe82de158ee9dd264d631ac51e8ca81e", "class_name": "RelatedNodeInfo"}}, "text": "Movement with Modules\n\nMoving labware on and off of modules lets you precisely control when the labware is in contact with the hot, cold, or magnetic surfaces of the modules \u2014\u00a0all within a single protocol.\n\nWhen moving labware anywhere that isn\u2019t an empty deck slot, consider what physical object the labware will rest on following the move. That object should be the value of `new_location`, and you need to make sure it\u2019s already loaded before the move. For example, if you want to move a 96\\-well flat plate onto a Heater\\-Shaker module, you actually want to have it rest on top of the Heater\\-Shaker\u2019s 96 Flat Bottom Adapter. Pass the adapter, not the module or the slot, as the value of `new_location`:\n\n```\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\"nest_96_wellplate_200ul_flat\", \"D1\")\n    hs_mod = protocol.load_module(\"heaterShakerModuleV1\", \"C1\")\n    hs_adapter = hs_mod.load_adapter(\"opentrons_96_flat_bottom_adapter\")\n    hs_mod.open_labware_latch()\n    protocol.move_labware(\n        labware=plate, new_location=hs_adapter, use_gripper=True\n    )\n\n```\n\nNew in version 2\\.15\\.\n\nIf you try to move the plate to slot C1 or the Heater\\-Shaker module, the API will raise an error, because C1 is occupied by the Heater\\-Shaker, and the Heater\\-Shaker is occupied by the adapter. Only the adapter, as the topmost item in that stack, is unoccupied.\n\nAlso note the `hs_mod.open_labware_latch()` command in the above example. To move labware onto or off of a module, you have to make sure that it\u2019s physically accessible:\n\n> - For the Heater\\-Shaker, use `open_labware_latch()`.\n> - For the Thermocycler, use `open_lid()`.\n\nIf the labware is inaccessible, the API will raise an error.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1730, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9bef5dc4-21d0-4a5c-ad87-6e432cb56ace": {"__data__": {"id_": "9bef5dc4-21d0-4a5c-ad87-6e432cb56ace", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f95d67bd-6c0d-479a-a872-3674377bca97", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "3e79cc3220dc67f26b754f64be50f2e8f4c5fda59f5f72936418501578c374a8", "class_name": "RelatedNodeInfo"}}, "text": "Movement into the Waste Chute\n\nMove used tip racks and well plates to the waste chute to dispose of them. This requires you to first configure the waste chute in your protocol. Then use the loaded `WasteChute` object as the value of `new_location`:\n\n```\nchute = protocol.load_waste_chute()\nprotocol.move_labware(\n    labware=plate, new_location=chute, use_gripper=True\n)\n\n```\n\nNew in version 2\\.16\\.\n\nThis will pick up `plate` from its current location and drop it into the chute.\n\nAlways specify `use_gripper=True` when moving labware into the waste chute. The chute is not designed for manual movement. You can still manually move labware to other locations, including off\\-deck, with the chute installed.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 709, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e4b5304b-823e-4445-a1ea-c0cc4cd38fca": {"__data__": {"id_": "e4b5304b-823e-4445-a1ea-c0cc4cd38fca", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8c6dd48a-7701-46a7-95ab-162bb819468f", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "30be8048d8e760ee9b6159c911dbccea25d1579fd0968f66d3ec86a1ece4d7a0", "class_name": "RelatedNodeInfo"}}, "text": "The Off\\-Deck Location\n\nIn addition to moving labware around the deck, `move_labware()` can also prompt you to move labware off of or onto the deck.\n\nRemove labware from the deck to perform tasks like retrieving samples or discarding a spent tip rack. The destination location for such moves is the special constant `OFF_DECK`:\n\n```\nprotocol.move_labware(labware=plate, new_location=protocol_api.OFF_DECK)\n\n```\n\nNew in version 2\\.15\\.\n\nMoving labware off\\-deck always requires user intervention, because the gripper can\u2019t reach outside of the robot. Omit the `use_gripper` parameter or explicitly set it to `False`. If you try to move labware off\\-deck with `use_gripper=True`, the API will raise an error.\n\nYou can also load labware off\\-deck, in preparation for a `move_labware()` command that brings it _onto_ the deck. For example, you could assign two tip racks to a pipette \u2014 one on\\-deck, and one off\\-deck \u2014 and then swap out the first rack for the second one:\n\n> ```\n> from opentrons import protocol_api\n>\n> metadata = {\"apiLevel\": \"2.19\", \"protocolName\": \"Tip rack replacement\"}\n> requirements = {\"robotType\": \"OT-2\"}\n>\n>\n> def run(protocol: protocol_api.ProtocolContext):\n>     tips1 = protocol.load_labware(\"opentrons_96_tiprack_1000ul\", 1)\n>     # load another tip rack but don't put it in a slot yet\n>     tips2 = protocol.load_labware(\n>         \"opentrons_96_tiprack_1000ul\", protocol_api.OFF_DECK\n>     )\n>     pipette = protocol.load_instrument(\n>         \"p1000_single_gen2\", \"left\", tip_racks=[tips1, tips2]\n>     )\n>     # use all the on-deck tips\n>     for i in range(96):\n>         pipette.pick_up_tip()\n>         pipette.drop_tip()\n>     # pause to move the spent tip rack off-deck\n>     protocol.move_labware(labware=tips1, new_location=protocol_api.OFF_DECK)\n>     # pause to move the fresh tip rack on-deck\n>     protocol.move_labware(labware=tips2, new_location=1)\n>     pipette.pick_up_tip()\n>\n> ```\n\nUsing the off\\-deck location to remove or replace labware lets you continue your workflow in a single protocol, rather than needing to end a protocol, reset the deck, and start a new protocol run.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2128, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "910cf0de-fab0-477c-b7a4-d647114bbb11": {"__data__": {"id_": "910cf0de-fab0-477c-b7a4-d647114bbb11", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bc6e6f88-5eb1-408e-8ad7-6da71f6f1d38", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "2440b4b983a752097febb57cd334ad7f8ece737c7ae42b71bdee01d9052ad2eb", "class_name": "RelatedNodeInfo"}}, "text": "Hardware Modules", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 18, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a13e8beb-1ae1-40b7-ad66-8d2e8ea13cf5": {"__data__": {"id_": "a13e8beb-1ae1-40b7-ad66-8d2e8ea13cf5", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d1a63777-02d6-4af8-a809-2f8ae6e6475d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "350eb7bbde5b650422abdce2fa48b589f2f623da75f87ed458d9762291d8e0b9", "class_name": "RelatedNodeInfo"}}, "text": "Module Setup", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 14, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c75ac5eb-5803-4ea7-8192-05ce627f6249": {"__data__": {"id_": "c75ac5eb-5803-4ea7-8192-05ce627f6249", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3b458459-4dd9-4848-9549-85e9a77fecab", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "4ed0f646f770604caadd7747189995a460b7a16b69be166ebbe809032b9ae7d6", "class_name": "RelatedNodeInfo"}}, "text": "Loading Modules onto the Deck\n\nSimilar to labware and pipettes, you must inform the API about the modules you want to use in your protocol. Even if you don\u2019t use the module anywhere else in your protocol, the Opentrons App and the robot won\u2019t let you start the protocol run until all loaded modules that use power are connected via USB and turned on.\n\nUse `ProtocolContext.load_module()` to load a module.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 407, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dc21147f-8e07-4809-bbb4-8792f4b5088a": {"__data__": {"id_": "dc21147f-8e07-4809-bbb4-8792f4b5088a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "51ba3d9f-a608-42da-8e73-50f9815acc58", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "07b2e034fb317cd1b9cff1ddf0c76135b501192f05f31cf6a77e2be1b5d062dc", "class_name": "RelatedNodeInfo"}}, "text": "Flex\n\n```\nfrom opentrons import protocol_api\n\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    # Load a Heater-Shaker Module GEN1 in deck slot D1.\n    heater_shaker = protocol.load_module(\n      module_name=\"heaterShakerModuleV1\", location=\"D1\")\n\n    # Load a Temperature Module GEN2 in deck slot D3.\n    temperature_module = protocol.load_module(\n      module_name=\"temperature module gen2\", location=\"D3\")\n\n```\n\nAfter the `load_module()` method loads the modules into your protocol, it returns the `HeaterShakerContext` and `TemperatureModuleContext` objects.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 625, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "70b61591-5818-4d13-94e9-62d98f34ad86": {"__data__": {"id_": "70b61591-5818-4d13-94e9-62d98f34ad86", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7aa44a91-4a05-4638-b083-d7b567e074fd", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "a1da1e0451a5c3aa3602ca8546b32abfa43ac5f68a2754b975be8f3258859754", "class_name": "RelatedNodeInfo"}}, "text": "OT-2\n\n```\nfrom opentrons import protocol_api\n\nmetadata = {\"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    # Load a Magnetic Module GEN2 in deck slot 1.\n    magnetic_module = protocol.load_module(\n      module_name=\"magnetic module gen2\", location=1)\n\n    # Load a Temperature Module GEN1 in deck slot 3.\n    temperature_module = protocol.load_module(\n      module_name=\"temperature module\", location=3)\n\n```\n\nAfter the `load_module()` method loads the modules into your protocol, it returns the `MagneticModuleContext` and `TemperatureModuleContext` objects.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 609, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "308ac43a-fba8-466d-84cd-9f9786d45512": {"__data__": {"id_": "308ac43a-fba8-466d-84cd-9f9786d45512", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d69fed16-ef9c-477b-8162-5398ec0becec", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "819383e8bfc0ebda3841e1bf45034a8d27bf06afaea424182fbaadac3b36f89a", "class_name": "RelatedNodeInfo"}}, "text": "Available Modules\n\nThe first parameter of `ProtocolContext.load_module()` is the module\u2019s _API load name_. The load name tells your robot which module you\u2019re going to use in a protocol. The table below lists the API load names for the currently available modules.\n\n| Module                     | API Load Name                                        | Introduced in API Version |\n| -------------------------- | ---------------------------------------------------- | ------------------------- |\n| Temperature Module GEN1    | `temperature module` or `tempdeck`                   | 2\\.0                      |\n| Temperature Module GEN2    | `temperature module gen2`                            | 2\\.3                      |\n| Magnetic Module GEN1       | `magnetic module` or `magdeck`                       | 2\\.0                      |\n| Magnetic Module GEN2       | `magnetic module gen2`                               | 2\\.3                      |\n| Thermocycler Module GEN1   | `thermocycler module` or `thermocycler`              | 2\\.0                      |\n| Thermocycler Module GEN2   | `thermocycler module gen2` or `thermocyclerModuleV2` | 2\\.13                     |\n| Heater\\-Shaker Module GEN1 | `heaterShakerModuleV1`                               | 2\\.13                     |\n| Magnetic Block GEN1        | `magneticBlockV1`                                    | 2\\.15                     |\n\nSome modules were added to our Python API later than others, and others span multiple hardware generations. When writing a protocol that requires a module, make sure your `requirements` or `metadata` code block specifies an API version high enough to support all the module generations you want to use.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1710, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fe3a5b11-1735-4d81-80bb-c036ba11cd84": {"__data__": {"id_": "fe3a5b11-1735-4d81-80bb-c036ba11cd84", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1e28e0d8-a45a-4ecd-8fc6-3ed34c463e4c", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "a6127b917d39ca1701bf4494a46b11faee017510b7c095af826dcad13a50e0ab", "class_name": "RelatedNodeInfo"}}, "text": "Loading Labware onto a Module\n\nUse the `load_labware()` method on the module context to load labware on a module. For example, to load the Opentrons 24 Well Aluminum Block on top of a Temperature Module:\n\n```\ndef run(protocol: protocol_api.ProtocolContext):\n    temp_mod = protocol.load_module(\n      module_name=\"temperature module gen2\",\n      location=\"D1\")\n    temp_labware = temp_mod.load_labware(\n        name=\"opentrons_24_aluminumblock_generic_2ml_screwcap\",\n        label=\"Temperature-Controlled Tubes\")\n\n```\n\nNew in version 2\\.0\\.\n\nWhen you load labware on a module, you don\u2019t need to specify the deck slot. In the above example, the `load_module()` method already specifies where the module is on the deck: `location= \"D1\"`.\n\nAny custom labware added to your Opentrons App is also accessible when loading labware onto a module. You can find and copy its load name by going to its card on the Labware page.\n\nNew in version 2\\.1\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 941, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "47b56d4a-735d-48a2-af71-73aa8af48557": {"__data__": {"id_": "47b56d4a-735d-48a2-af71-73aa8af48557", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2385bce1-9781-40a9-bc5f-babc5758b8a8", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "e7f3a7b9c251970796b396bf230c38db0b9be5d9d2668149a7ac57e0478d36d9", "class_name": "RelatedNodeInfo"}}, "text": "Module and Labware Compatibility\n\nIt\u2019s your responsibility to ensure the labware and module combinations you load together work together. The Protocol API won\u2019t raise a warning or error if you load an unusual combination, like placing a tube rack on a Thermocycler. See What labware can I use with my modules? for more information about labware/module combinations.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 367, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3add3fdb-f4da-465d-9169-f29febbf1824": {"__data__": {"id_": "3add3fdb-f4da-465d-9169-f29febbf1824", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "917359d2-353c-445f-b663-2fc3df9b4709", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "830244d8f47c14c46023a1fc8bd7f29f1e7fe7e6ccbbe1eac544d90a23f6ad63", "class_name": "RelatedNodeInfo"}}, "text": "Additional Labware Parameters\n\nIn addition to the mandatory `load_name` argument, you can also specify additional parameters. For example, if you specify a `label`, this name will appear in the Opentrons App and the run log instead of the load name. For labware that has multiple definitions, you can specify `version` and `namespace` (though most of the time you won\u2019t have to). The `load_labware()` methods of all module contexts accept these additional parameters.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 469, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "38b29421-6026-4c4c-b185-215d46bb154b": {"__data__": {"id_": "38b29421-6026-4c4c-b185-215d46bb154b", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "94e300b3-0998-4e9f-8198-6c6f820d2e82", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "7e751e7df393e5f45d5597a830950f45654466e9abae3de69be21bada11c2a8d", "class_name": "RelatedNodeInfo"}}, "text": "Heater\\-Shaker Module\n\nThe Heater\\-Shaker Module provides on\\-deck heating and orbital shaking. The module can heat from 37 to 95 \u00b0C, and can shake samples from 200 to 3000 rpm.\n\nThe Heater\\-Shaker Module is represented in code by a `HeaterShakerContext` object. For example:\n\n```\nhs_mod = protocol.load_module(\n    module_name=\"heaterShakerModuleV1\", location=\"D1\"\n)\n\n```\n\nNew in version 2\\.13\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 398, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "41398e86-5b6e-46bb-9a65-40961ace4da2": {"__data__": {"id_": "41398e86-5b6e-46bb-9a65-40961ace4da2", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cfcc63a6-d0c1-4c7b-8a51-557bc0dc565e", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "3c7344245458a311f61338bf96e7edd85674ac62cab444da8fc4e2c111668828", "class_name": "RelatedNodeInfo"}}, "text": "Deck Slots\n\nThe supported deck slot positions for the Heater\\-Shaker depend on the robot you\u2019re using.\n\n| Robot Model | Heater\\-Shaker Deck Placement                                                                               |\n| ----------- | ----------------------------------------------------------------------------------------------------------- |\n| Flex        | In any deck slot in column 1 or 3\\. The module can go in slot A3, but you need to move the trash bin first. |\n| OT\\-2       | In deck slot 1, 3, 4, 6, 7, or 10\\.                                                                         |", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 609, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1d4a1982-5b0b-45be-ac4f-83d439dc303d": {"__data__": {"id_": "1d4a1982-5b0b-45be-ac4f-83d439dc303d", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4f20e1b9-764d-4ffe-801a-19a51b1058b0", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "530e581562b9864df702942bd1e6f63eb955c792607213387ab4c92716bfa60f", "class_name": "RelatedNodeInfo"}}, "text": "OT\\-2 Placement Restrictions\n\nOn OT\\-2, you need to restrict placement of other modules and labware around the Heater\\-Shaker. On Flex, the module is installed below\\-deck in a caddy and there is more space between deck slots, so these restrictions don\u2019t apply.\n\nIn general, it\u2019s best to leave all slots adjacent to the Heater\\-Shaker empty. If your protocol requires filling those slots, observe the following restrictions to avoid physical crashes involving the Heater\\-Shaker.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 481, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7c64cfd5-b8e5-47b3-84fa-baf21fe1e41c": {"__data__": {"id_": "7c64cfd5-b8e5-47b3-84fa-baf21fe1e41c", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9858a4df-7f4b-42c3-b033-6606454404e6", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "c16628b7621111d77cd958894a7b3127e9cfb1258ef16349c848f9c8d7bf26ec", "class_name": "RelatedNodeInfo"}}, "text": "Adjacent Modules\n\nDo not place other modules next to the Heater\\-Shaker. Keeping adjacent deck slots clear helps prevents collisions during shaking and while opening the labware latch. Loading a module next to the Heater\\-Shaker on OT\\-2 will raise a `DeckConflictError`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 273, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1a367c53-3325-4cd9-b266-96204893392d": {"__data__": {"id_": "1a367c53-3325-4cd9-b266-96204893392d", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c4fd46da-c327-4201-bcc8-65ff4895ba5b", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "88a11d77bbc719085572d9a1730ea45bd2977e88b37b7b94ff817ab806fdda06", "class_name": "RelatedNodeInfo"}}, "text": "Tall Labware\n\nDo not place labware taller than 53 mm to the left or right of the Heater\\-Shaker. This prevents the Heater\\-Shaker\u2019s latch from colliding with the adjacent labware. Common labware that exceed the height limit include Opentrons tube racks and Opentrons 1000 \u00b5L tip racks. Loading tall labware to the right or left of the Heater\\-Shaker on OT\\-2 will raise a `DeckConflictError`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 394, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e26bb185-e570-47be-a374-daba5dbb7c3e": {"__data__": {"id_": "e26bb185-e570-47be-a374-daba5dbb7c3e", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7c151f85-8ba8-4b98-a167-a53fde012914", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "09c4e50be96e89e090e5efdad58e08543c6fa15f9957a19d929090fa733de4e5", "class_name": "RelatedNodeInfo"}}, "text": "8\\-Channel Pipettes\n\nYou can\u2019t perform pipetting actions in any slots adjacent to the Heater\\-Shaker if you\u2019re using a GEN2 or GEN1 8\\-channel pipette. This prevents the pipette ejector from crashing on the module housing or labware latch. Using an 8\\-channel pipette will raise a `PipetteMovementRestrictedByHeaterShakerError`.\n\nThere is one exception: to the front or back of the Heater\\-Shaker, an 8\\-channel pipette can access tip racks only. Attempting to pipette to non\\-tip\\-rack labware will also raise a `PipetteMovementRestrictedByHeaterShakerError`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 562, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b8fc69cc-e537-4446-8f33-b45ca411d031": {"__data__": {"id_": "b8fc69cc-e537-4446-8f33-b45ca411d031", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "19ae540e-1254-4853-b078-e61060a4a0ed", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ffc6f66af0e497fa19be876a6506eeac8b9f7d9b2b6b6e7557901e000af5dfbd", "class_name": "RelatedNodeInfo"}}, "text": "Latch Control\n\nTo add and remove labware from the Heater\\-Shaker, control the module\u2019s labware latch from your protocol using `open_labware_latch()` and `close_labware_latch()`. Shaking requires the labware latch to be closed, so you may want to issue a close command before the first shake command in your protocol:\n\n```\nhs_mod.close_labware_latch()\nhs_mod.set_and_wait_for_shake_speed(500)\n\n```\n\nIf the labware latch is already closed, `close_labware_latch()` will succeed immediately; you don\u2019t have to check the status of the latch before opening or closing it.\n\nTo prepare the deck before running a protocol, use the labware latch controls in the Opentrons App or run these methods in Jupyter notebook.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 709, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d4efc45a-8e92-4637-a8ee-bf6e15e1ad60": {"__data__": {"id_": "d4efc45a-8e92-4637-a8ee-bf6e15e1ad60", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e635531f-c20b-4860-8dfb-420b960c5f8e", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "1af2fa9f1a295c4426cd18618148eb95c07d3f7e18c2a1f6bd61ff26d8887b28", "class_name": "RelatedNodeInfo"}}, "text": "Loading Labware\n\nUse the Heater\\-Shaker\u2019s `load_adapter()` and `load_labware()` methods to specify what you will place on the module. For the Heater\\-Shaker, use one of the thermal adapters listed below and labware that fits on the adapter. See Loading Labware on Adapters for examples of loading labware on modules.\n\nThe Opentrons Labware Library includes definitions for both standalone adapters and adapter\u2013labware combinations. These labware definitions help make the Heater\\-Shaker ready to use right out of the box.\n\nNote\n\nIf you plan to move labware onto or off of the Heater\\-Shaker during your protocol, you must use a standalone adapter definition, not an adapter\u2013labware combination definiton.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 706, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fedf6bff-f687-4b6d-9dc0-7008c00d49f8": {"__data__": {"id_": "fedf6bff-f687-4b6d-9dc0-7008c00d49f8", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cccc5fb8-ddbf-42d8-99bf-3d47d736af84", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "0c616f5a5bc948d0d6eb9990a5835db00ababa280db3edecce055a6908db9574", "class_name": "RelatedNodeInfo"}}, "text": "Standalone Adapters\n\nYou can use these standalone adapter definitions to load Opentrons verified or custom labware on top of the Heater\\-Shaker.\n\n| Adapter Type                                    | API Load Name                      |\n| ----------------------------------------------- | ---------------------------------- |\n| Opentrons Universal Flat Heater\\-Shaker Adapter | `opentrons_universal_flat_adapter` |\n| Opentrons 96 PCR Heater\\-Shaker Adapter         | `opentrons_96_pcr_adapter`         |\n| Opentrons 96 Deep Well Heater\\-Shaker Adapter   | `opentrons_96_deep_well_adapter`   |\n| Opentrons 96 Flat Bottom Heater\\-Shaker Adapter | `opentrons_96_flat_bottom_adapter` |\n\nFor example, these commands load a well plate on top of the flat bottom adapter:\n\n```\nhs_adapter = hs_mod.load_adapter(\"opentrons_96_flat_bottom_adapter\")\nhs_plate = hs_adapter.load_labware(\"nest_96_wellplate_200ul_flat\")\n\n```\n\nNew in version 2\\.15: The `load_adapter()` method.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 961, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "811695ee-2228-4c8f-951a-82d7f4f45c3f": {"__data__": {"id_": "811695ee-2228-4c8f-951a-82d7f4f45c3f", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9769d996-c1b4-4dd9-8234-fe2515e80255", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "08c833352fa26c900b21b59b57ce2c16a134ce053fbc9dc1b29e48711f41fc74", "class_name": "RelatedNodeInfo"}}, "text": "Pre\\-configured Combinations\n\nThe Heater\\-Shaker supports these thermal adapter and labware combinations for backwards compatibility. If your protocol specifies an `apiLevel` of 2\\.15 or higher, you should use the standalone adapter definitions instead.\n\n| Adapter/Labware Combination                                              | API Load Name                                                       |\n| ------------------------------------------------------------------------ | ------------------------------------------------------------------- |\n| Opentrons 96 Deep Well Adapter with NEST Deep Well Plate 2 mL            | `opentrons_96_deep_well_adapter_nest_wellplate_2ml_deep`            |\n| Opentrons 96 Flat Bottom Adapter with NEST 96 Well Plate 200 \u00b5L Flat     | `opentrons_96_flat_bottom_adapter_nest_wellplate_200ul_flat`        |\n| Opentrons 96 PCR Adapter with Armadillo Well Plate 200 \u00b5L                | `opentrons_96_pcr_adapter_armadillo_wellplate_200ul`                |\n| Opentrons 96 PCR Adapter with NEST Well Plate 100 \u00b5L                     | `opentrons_96_pcr_adapter_nest_wellplate_100ul_pcr_full_skirt`      |\n| Opentrons Universal Flat Adapter with Corning 384 Well Plate 112 \u00b5L Flat | `opentrons_universal_flat_adapter_corning_384_wellplate_112ul_flat` |\n\nThis command loads the same physical adapter and labware as the example in the previous section, but it is also compatible with API versions 2\\.13 and 2\\.14:\n\n```\nhs_combo = hs_mod.load_labware(\n    \"opentrons_96_flat_bottom_adapter_nest_wellplate_200ul_flat\"\n)\n\n```\n\nNew in version 2\\.13\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1577, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "55922c6e-79a7-40a3-94a5-c57015dc53af": {"__data__": {"id_": "55922c6e-79a7-40a3-94a5-c57015dc53af", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f055d117-26de-4aa7-8381-a2a3550eacc2", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "448a694a521cdaf2b7c4561eaf1e3a7523092b48af7c41848f15a8a6d4b10d1e", "class_name": "RelatedNodeInfo"}}, "text": "Custom Flat\\-Bottom Labware\n\nCustom flat\\-bottom labware can be used with the Universal Flat Adapter. See the support article Requesting a Custom Labware Definition if you need assistance creating custom labware definitions for the Heater\\-Shaker.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 249, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cc0292fe-89e4-4ed0-88a8-8bf84434944a": {"__data__": {"id_": "cc0292fe-89e4-4ed0-88a8-8bf84434944a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ac98703e-178c-4344-a053-9adda47dcd16", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "da3fdc5a1b0547ac4ac3f00b86654520a0b65ece9ef0153d30a4c47ceb2d37dd", "class_name": "RelatedNodeInfo"}}, "text": "Heating and Shaking\n\nThe API treats heating and shaking as separate, independent activities due to the amount of time they take.\n\nIncreasing or reducing shaking speed takes a few seconds, so the API treats these actions as _blocking_ commands. All other commands cannot run until the module reaches the required speed.\n\nHeating the module, or letting it passively cool, takes more time than changing the shaking speed. As a result, the API gives you the flexibility to perform other pipetting actions while waiting for the module to reach a target temperature. When holding at temperature, you can design your protocol to run in a blocking or non\\-blocking manner.\n\nNote\n\nSince API version 2\\.13, only the Heater\\-Shaker Module supports non\\-blocking command execution. All other modules\u2019 methods are blocking commands.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 821, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2a4423e3-72a1-4253-84e0-2cd14733e5ca": {"__data__": {"id_": "2a4423e3-72a1-4253-84e0-2cd14733e5ca", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4e01c364-e826-4134-a736-fba73609950d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "c22d0e64bd39a41bf2ee4bbfadc9cf3f6aeb877bae1349446dd024de7b5c0954", "class_name": "RelatedNodeInfo"}}, "text": "Blocking commands\n\nThis example uses a blocking command and shakes a sample for one minute. No other commands will execute until a minute has elapsed. The three commands in this example start the shake, wait for one minute, and then stop the shake:\n\n```\nhs_mod.set_and_wait_for_shake_speed(500)\nprotocol.delay(minutes=1)\nhs_mod.deactivate_shaker()\n\n```\n\nThese actions will take about 65 seconds total. Compare this with similar\\-looking commands for holding a sample at a temperature for one minute:\n\n```\nhs_mod.set_and_wait_for_temperature(75)\nprotocol.delay(minutes=1)\nhs_mod.deactivate_heater()\n\n```\n\nThis may take much longer, depending on the thermal block used, the volume and type of liquid contained in the labware, and the initial temperature of the module.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 768, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7a9b4fa2-7c27-40f1-bc48-435ddf6117cd": {"__data__": {"id_": "7a9b4fa2-7c27-40f1-bc48-435ddf6117cd", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "95463265-4f6f-4c31-8d48-990df80674af", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "be646d16797a08c46710bade7cc6b227de7e3d12d3966457baa27958aebc6e74", "class_name": "RelatedNodeInfo"}}, "text": "Non\\-blocking commands\n\nTo pipette while the Heater\\-Shaker is heating, use `set_target_temperature()` and `wait_for_temperature()` instead of `set_and_wait_for_temperature()`:\n\n```\nhs_mod.set_target_temperature(75)\npipette.pick_up_tip()\npipette.aspirate(50, plate[\"A1\"])\npipette.dispense(50, plate[\"B1\"])\npipette.drop_tip()\nhs_mod.wait_for_temperature()\nprotocol.delay(minutes=1)\nhs_mod.deactivate_heater()\n\n```\n\nThis example would likely take just as long as the blocking version above; it\u2019s unlikely that one aspirate and one dispense action would take longer than the time for the module to heat. However, be careful when putting a lot of commands between a `set_target_temperature()` call and a `delay()` call. In this situation, you\u2019re relying on `wait_for_temperature()` to resume execution of commands once heating is complete. But if the temperature has already been reached, the delay will begin later than expected and the Heater\\-Shaker will hold at its target temperature longer than intended.\n\nAdditionally, if you want to pipette while the module holds a temperature for a certain length of time, you need to track the holding time yourself. One of the simplest ways to do this is with Python\u2019s `time` module. First, add `import time` at the start of your protocol. Then, use `time.monotonic()`') to set a reference time when the target is reached. Finally, add a delay that calculates how much holding time is remaining after the pipetting actions:\n\n```\nhs_mod.set_and_wait_for_temperature(75)\nstart_time = time.monotonic()  # set reference time\npipette.pick_up_tip()\npipette.aspirate(50, plate[\"A1\"])\npipette.dispense(50, plate[\"B1\"])\npipette.drop_tip()\n# delay for the difference between now and 60 seconds after the reference time\nprotocol.delay(max(0, start_time+60 - time.monotonic()))\nhs_mod.deactivate_heater()\n\n```\n\nProvided that the parallel pipetting actions don\u2019t take more than one minute, this code will deactivate the heater one minute after its target was reached. If more than one minute has elapsed, the value passed to `protocol.delay()` will equal 0, and the protocol will continue immediately.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2131, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "de7a313b-87dc-4714-8e67-8cf20017a4cb": {"__data__": {"id_": "de7a313b-87dc-4714-8e67-8cf20017a4cb", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7a1867b0-ab52-48f8-951b-fc43bd32f774", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "35605c5473640e03d85a44713c2397b95e1a4e497913c6d28321c121ec4b24c8", "class_name": "RelatedNodeInfo"}}, "text": "Deactivating\n\nDeactivating the heater and shaker are done separately using the `deactivate_heater()` and `deactivate_shaker()` methods, respectively. There is no method to deactivate both simultaneously. Call the two methods in sequence if you need to stop both heating and shaking.\n\nNote\n\nThe robot will not automatically deactivate the Heater\\-Shaker at the end of a protocol. If you need to deactivate the module after a protocol is completed or canceled, use the Heater\\-Shaker module controls on the device detail page in the Opentrons App or run these methods in Jupyter notebook.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 588, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7d0b50a0-ea1e-4a94-a0ec-8d3673980d30": {"__data__": {"id_": "7d0b50a0-ea1e-4a94-a0ec-8d3673980d30", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cf77a9ff-f7c7-4593-a369-cd4fcec74f2e", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "dd9c4b375f49494ba8d5ae624e6234afcdcb9499bcf93817a43e5dde87fb223b", "class_name": "RelatedNodeInfo"}}, "text": "Magnetic Block\n\nNote\n\nThe Magnetic Block is compatible with Opentrons Flex only. If you have an OT\\-2, use the Magnetic Module.\n\nThe Magnetic Block is an unpowered, 96\\-well plate that holds labware close to its high\\-strength neodymium magnets. This module is suitable for many magnetic bead\\-based protocols, but does not move beads up or down in solution.\n\nBecause the Magnetic Block is unpowered, neither your robot nor the Opentrons App aware of this module. You \u201ccontrol\u201d it via protocols to load labware onto the module and use the Opentrons Flex Gripper to move labware on and off the module. See Moving Labware for more information.\n\nThe Magnetic Block is represented by a `MagneticBlockContext` object which lets you load labware on top of the module.\n\n```\n# Load the Magnetic Block in deck slot D1\nmagnetic_block = protocol.load_module(\n    module_name=\"magneticBlockV1\", location=\"D1\"\n)\n\n# Load a 96-well plate on the magnetic block\nmag_plate = magnetic_block.load_labware(\n    name=\"biorad_96_wellplate_200ul_pcr\"\n)\n\n# Use the Gripper to move labware\nprotocol.move_labware(mag_plate, new_location=\"B2\", use_gripper=True)\n\n```\n\nNew in version 2\\.15\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1164, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9bee9f1a-6dbc-4059-936e-45558667d141": {"__data__": {"id_": "9bee9f1a-6dbc-4059-936e-45558667d141", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2998f37a-c9ce-4c33-bf4e-52eebed61bb6", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ce96543206b3a4b5dd06a434e8f2ec0488e7775b4f5cd26e58497b4495c8ab4c", "class_name": "RelatedNodeInfo"}}, "text": "Magnetic Module\n\nNote\n\nThe Magnetic Module is compatible with the OT\\-2 only. If you have a Flex, use the Magnetic Block.\n\nThe Magnetic Module controls a set of permanent magnets which can move vertically to induce a magnetic field in the labware loaded on the module.\n\nThe Magnetic Module is represented by a `MagneticModuleContext` object, which has methods for engaging (raising) and disengaging (lowering) its magnets.\n\nThe examples in this section apply to an OT\\-2 with a Magnetic Module GEN2 loaded in slot 6:\n\n```\ndef run(protocol: protocol_api.ProtocolContext):\n    mag_mod = protocol.load_module(\n      module_name=\"magnetic module gen2\",\n      location=\"6\")\n    plate = mag_mod.load_labware(\n      name=\"nest_96_wellplate_100ul_pcr_full_skirt\")\n\n```\n\nNew in version 2\\.3\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 785, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f7f3b1bd-ec07-41a7-a936-404f27f1fd59": {"__data__": {"id_": "f7f3b1bd-ec07-41a7-a936-404f27f1fd59", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5da6ead4-b24f-43e3-bedc-9a77b862fc9e", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "b953a11e5f4b844f5c40f9d9c38727efb0d8f678e071645087ac103bebb620b5", "class_name": "RelatedNodeInfo"}}, "text": "Loading Labware\n\nLike with all modules, use the Magnetic Module\u2019s `load_labware()` method to specify what you will place on the module. The Magnetic Module supports 96\\-well PCR plates and deep well plates. For the best compatibility, use a labware definition that specifies how far the magnets should move when engaging with the labware. The following plates in the Opentrons Labware Library include this measurement:\n\n| Labware Name                                 | API Load Name                              |\n| -------------------------------------------- | ------------------------------------------ |\n| Bio\\-Rad 96 Well Plate 200 \u00b5L PCR            | `biorad_96_wellplate_200ul_pcr`            |\n| NEST 96 Well Plate 100 \u00b5L PCR Full Skirt     | `nest_96_wellplate_100ul_pcr_full_skirt`   |\n| NEST 96 Deep Well Plate 2mL                  | `nest_96_wellplate_2ml_deep`               |\n| Thermo Scientific Nunc 96 Well Plate 1300 \u00b5L | `thermoscientificnunc_96_wellplate_1300ul` |\n| Thermo Scientific Nunc 96 Well Plate 2000 \u00b5L | `thermoscientificnunc_96_wellplate_2000ul` |\n| USA Scientific 96 Deep Well Plate 2\\.4 mL    | `usascientific_96_wellplate_2.4ml_deep`    |\n\nTo check whether a custom labware definition specifies this measurement, load the labware and query its `magdeck_engage_height` property. If has a numerical value, the labware is ready for use with the Magnetic Module.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1393, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "50083219-d212-497c-b454-93b2d826fccc": {"__data__": {"id_": "50083219-d212-497c-b454-93b2d826fccc", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c99c0473-2ee3-4626-a83c-889903223a8d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "3cc5522614ace6c31db35681e75179b71b9b672d8ec14537767663934695d542", "class_name": "RelatedNodeInfo"}}, "text": "Engaging and Disengaging\n\nRaise and lower the module\u2019s magnets with the `engage()` and `disengage()` functions, respectively.\n\nIf your loaded labware is fully compatible with the Magnetic Module, you can call `engage()` with no argument:\n\n> ```\n> mag_mod.engage()\n>\n> ```\n>\n> New in version 2\\.0\\.\n\nThis will move the magnets upward to the default height for the labware, which should be close to the bottom of the labware\u2019s wells. If your loaded labware doesn\u2019t specify a default height, this will raise an `ExceptionInProtocolError`.\n\nFor certain applications, you may want to move the magnets to a different height. The recommended way is to use the `height_from_base` parameter, which represents the distance above the base of the labware (its lowest point, where it rests on the module). Setting `height_from_base=0` should move the tops of the magnets level with the base of the labware. Alternatively, you can use the `offset` parameter, which represents the distance above _or below_ the labware\u2019s default position (close to the bottom of its wells). Like using `engage()` with no argument, this will raise an error if there is no default height for the loaded labware.\n\nNote\n\nThere is up to 1 mm of manufacturing variance across Magnetic Module units, so observe the exact position and adjust as necessary before running your protocol.\n\nHere are some examples of where the magnets will move when using the different parameters in combination with the loaded NEST PCR plate, which specifies a default height of 20 mm:\n\n> ```\n> mag_mod.engage(height_from_base=13.5)  # 13.5 mm\n> mag_mod.engage(offset=-2)              # 15.5 mm\n>\n> ```\n\nNote that `offset` takes into account the fact that the magnets\u2019 home position is measured as \u22122\\.5 mm for GEN2 modules.\n\n> New in version 2\\.0\\.\n>\n> Changed in version 2\\.2: Added the `height_from_base` parameter.\n\nWhen you need to retract the magnets back to their home position, call `disengage()`.\n\n> ```\n> mag_mod.disengage()  # -2.5 mm\n>\n> ```\n\nNew in version 2\\.0\\.\n\nIf at any point you need to check whether the magnets are engaged or not, use the `status` property. This will return either the string `engaged` or `disengaged`, not the exact height of the magnets.\n\nNote\n\nThe OT\\-2 will not automatically deactivate the Magnetic Module at the end of a protocol. If you need to deactivate the module after a protocol is completed or canceled, use the Magnetic Module controls on the device detail page in the Opentrons App or run `deactivate()` in Jupyter notebook.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2519, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "19f48a1b-65d0-44a2-a1fd-a556bb4a4104": {"__data__": {"id_": "19f48a1b-65d0-44a2-a1fd-a556bb4a4104", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e1730e91-dc77-4608-9b00-c63130efd0f6", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "1d49010f8b6769fa6f98effffaa457ab49380fede7534e975c54a82b495e08bd", "class_name": "RelatedNodeInfo"}}, "text": "Changes with the GEN2 Magnetic Module\n\nThe GEN2 Magnetic Module uses smaller magnets than the GEN1 version. This change helps mitigate an issue with the magnets attracting beads from their retracted position, but it also takes longer for the GEN2 module to attract beads. The recommended attraction time is 5 minutes for liquid volumes up to 50 \u00b5L and 7 minutes for volumes greater than 50 \u00b5L. If your application needs additional magnetic strength to attract beads within these timeframes, use the available Adapter Magnets.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 527, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0dfedaa9-28bb-4e38-8a0f-c221bbadde41": {"__data__": {"id_": "0dfedaa9-28bb-4e38-8a0f-c221bbadde41", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "623359d1-b398-4a1f-bbed-a2188f071c4f", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "03c499612360562defa34aa154fc5917aa709e99a40a28647ee03b0015aea1d1", "class_name": "RelatedNodeInfo"}}, "text": "Temperature Module\n\nThe Temperature Module acts as both a cooling and heating device. It can control the temperature of its deck between 4 \u00b0C and 95 \u00b0C with a resolution of 1 \u00b0C.\n\nThe Temperature Module is represented in code by a `TemperatureModuleContext` object, which has methods for setting target temperatures and reading the module\u2019s status. This example demonstrates loading a Temperature Module GEN2 and loading a well plate on top of it.\n\n```\ntemp_mod = protocol.load_module(\n    module_name=\"temperature module gen2\", location=\"D3\"\n)\n\n```\n\nNew in version 2\\.3\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 574, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d30f5461-bfe9-419a-b9e5-13e7f817d3eb": {"__data__": {"id_": "d30f5461-bfe9-419a-b9e5-13e7f817d3eb", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c7fc7ded-4162-42fc-89f0-25bebb2072f7", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "b72eee81145aaa6e78afd9aeac82e5932a0e3b907f2c4dec0f27dfacb8b47eea", "class_name": "RelatedNodeInfo"}}, "text": "Loading Labware\n\nUse the Temperature Module\u2019s `load_adapter()` and `load_labware()` methods to specify what you will place on the module. You may use one or both of the methods, depending on the labware you\u2019re using. See Loading Labware on Adapters for examples of loading labware on modules.\n\nThe Opentrons Labware Library includes definitions for both standalone adapters and adapter\u2013labware combinations. These labware definitions help make the Temperature Module ready to use right out of the box.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 503, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a4a4c01d-1d77-499c-a26e-93f5724f836a": {"__data__": {"id_": "a4a4c01d-1d77-499c-a26e-93f5724f836a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cae08c35-58df-4cf0-9034-118be5bbfe65", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "597f6f57a123220a784c3a8e0bba900677c563bb7dc1eb434ac470d50e2c8ac9", "class_name": "RelatedNodeInfo"}}, "text": "Standalone Adapters\n\nYou can use these standalone adapter definitions to load Opentrons verified or custom labware on top of the Temperature Module.\n\n| Adapter Type                         | API Load Name                          |\n| ------------------------------------ | -------------------------------------- |\n| Opentrons Aluminum Flat Bottom Plate | `opentrons_aluminum_flat_bottom_plate` |\n| Opentrons 96 Well Aluminum Block     | `opentrons_96_well_aluminum_block`     |\n\nFor example, these commands load a PCR plate on top of the 96\\-well block:\n\n```\ntemp_adapter = temp_mod.load_adapter(\n    \"opentrons_96_well_aluminum_block\"\n)\ntemp_plate = temp_adapter.load_labware(\n    \"nest_96_wellplate_100ul_pcr_full_skirt\"\n)\n\n```\n\nNew in version 2\\.15: The `load_adapter()` method.\n\nNote\n\nYou can also load labware directly onto the Temperature Module. In API version 2\\.14 and earlier, this was the correct way to load labware on top of the flat bottom plate. In API version 2\\.15 and later, you should load both the adapter and the labware with separate commands.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1067, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cefe593e-4bce-4336-a105-086bc6a1b89d": {"__data__": {"id_": "cefe593e-4bce-4336-a105-086bc6a1b89d", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f8790928-f542-4321-b081-e518644dc5b6", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "1ecc55e3485dedd5315f44c0984790e7a30c9f7bddccdf7a112acf3934450762", "class_name": "RelatedNodeInfo"}}, "text": "Block\\-and\\-tube combinations\n\nYou can use these combination labware definitions to load various types of tubes into the 24\\-well thermal block on top of the Temperature Module. There is no standalone definition for the 24\\-well block.\n\n| Tube Type              | API Load Name                                     |\n| ---------------------- | ------------------------------------------------- |\n| Generic 2 mL screw cap | `opentrons_24_aluminumblock_generic_2ml_screwcap` |\n| NEST 0\\.5 mL screw cap | `opentrons_24_aluminumblock_nest_0.5ml_screwcap`  |\n| NEST 1\\.5 mL screw cap | `opentrons_24_aluminumblock_nest_1.5ml_screwcap`  |\n| NEST 1\\.5 mL snap cap  | `opentrons_24_aluminumblock_nest_1.5ml_snapcap`   |\n| NEST 2 mL screw cap    | `opentrons_24_aluminumblock_nest_2ml_screwcap`    |\n| NEST 2 mL snap cap     | `opentrons_24_aluminumblock_nest_2ml_snapcap`     |\n\nFor example, this command loads the 24\\-well block with generic 2 mL tubes:\n\n```\ntemp_tubes = temp_mod.load_labware(\n    \"opentrons_24_aluminumblock_generic_2ml_screwcap\"\n)\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1072, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "50b1a5fc-76fd-43ae-8d2c-5b3d523b43ff": {"__data__": {"id_": "50b1a5fc-76fd-43ae-8d2c-5b3d523b43ff", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "83b2eff1-167f-4ecb-8fea-bc10ab4531af", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "c806387d6dcc958e43e0d2da8de99cf9268ca40fce719eb869f8cc7fc00517d9", "class_name": "RelatedNodeInfo"}}, "text": "Block\\-and\\-plate combinations\n\nThe Temperature Module supports these 96\\-well block and labware combinations for backwards compatibility. If your protocol specifies an `apiLevel` of 2\\.15 or higher, you should use the standalone 96\\-well block definition instead.\n\n| 96\\-well block contents    | API Load Name                                        |\n| -------------------------- | ---------------------------------------------------- |\n| Bio\\-Rad well plate 200 \u00b5L | `opentrons_96_aluminumblock_biorad_wellplate_200uL`  |\n| Generic PCR strip 200 \u00b5L   | `opentrons_96_aluminumblock_generic_pcr_strip_200uL` |\n| NEST well plate 100 \u00b5L     | `opentrons_96_aluminumblock_nest_wellplate_100uL`    |\n\nThis command loads the same physical adapter and labware as the example in the Standalone Adapters section above, but it is also compatible with earlier API versions:\n\n```\ntemp_combo = temp_mod.load_labware(\n    \"opentrons_96_aluminumblock_nest_wellplate_100uL\"\n)\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 990, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fbb6629d-83f6-40c4-a33b-90071643c471": {"__data__": {"id_": "fbb6629d-83f6-40c4-a33b-90071643c471", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b7d86710-14f3-4128-9055-d2f74d49704f", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "77622e36750ff0d90b4cec3f8a004c7077411444b56ab85775ddd0d530f34820", "class_name": "RelatedNodeInfo"}}, "text": "Temperature Control\n\nThe primary function of the module is to control the temperature of its deck, using `set_temperature()`, which takes one parameter: `celsius`. For example, to set the Temperature Module to 4 \u00b0C:\n\n```\ntemp_mod.set_temperature(celsius=4)\n\n```\n\nWhen using `set_temperature()`, your protocol will wait until the target temperature is reached before proceeding to further commands. In other words, you can pipette to or from the Temperature Module when it is holding at a temperature or idle, but not while it is actively changing temperature. Whenever the module reaches its target temperature, it will hold the temperature until you set a different target or call `deactivate()`, which will stop heating or cooling and will turn off the fan.\n\nNote\n\nYour robot will not automatically deactivate the Temperature Module at the end of a protocol. If you need to deactivate the module after a protocol is completed or canceled, use the Temperature Module controls on the device detail page in the Opentrons App or run `deactivate()` in Jupyter notebook.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1091, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5ebf07e2-6f73-45de-8193-13b4a5849c97": {"__data__": {"id_": "5ebf07e2-6f73-45de-8193-13b4a5849c97", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9efe19e9-92a3-42f7-a2fc-591df5e1f4cc", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "4eabbc52f2f65daa7a00797a78a7d64763271978cd9c1840313a57bc136a3bd9", "class_name": "RelatedNodeInfo"}}, "text": "Temperature Status\n\nIf you need to confirm in software whether the Temperature Module is holding at a temperature or is idle, use the `status` property:\n\n```\ntemp_mod.set_temperature(celsius=90)\ntemp_mod.status  # \"holding at target\"\ntemp_mod.deactivate()\ntemp_mod.status  # \"idle\"\n\n```\n\nIf you don\u2019t need to use the status value in your code, and you have physical access to the module, you can read its status and temperature from the LED and display on the module.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 492, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "23efc760-5dd5-464e-96d9-55018af5a877": {"__data__": {"id_": "23efc760-5dd5-464e-96d9-55018af5a877", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bb774b2c-b190-424c-8f29-da6e433a7ed6", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "9fcd2abee3368e5881c3753377c8c02bc92475e8278b95eced37b27fce7ba6de", "class_name": "RelatedNodeInfo"}}, "text": "Changes with the GEN2 Temperature Module\n\nAll methods of `TemperatureModuleContext` work with both the GEN1 and GEN2 Temperature Module. Physically, the GEN2 module has a plastic insulating rim around the plate, and plastic insulating shrouds designed to fit over Opentrons aluminum blocks. This mitigates an issue where the GEN1 module would have trouble cooling to very low temperatures, especially if it shared the deck with a running Thermocycler.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 453, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fef84c92-5054-4ef0-98e0-b7ad804f8ec7": {"__data__": {"id_": "fef84c92-5054-4ef0-98e0-b7ad804f8ec7", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "03c17ce7-f7a9-4af4-bbda-4ef034c1775e", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "4d5093fa8fc8d02319ded15c12c5b4265ef3261ee36c5ab4e8b4e135bcbfd7ed", "class_name": "RelatedNodeInfo"}}, "text": "Thermocycler Module\n\nThe Thermocycler Module provides on\\-deck, fully automated thermocycling, and can heat and cool very quickly during operation. The module\u2019s block can reach and maintain temperatures between 4 and 99 \u00b0C. The module\u2019s lid can heat up to 110 \u00b0C.\n\nThe Thermocycler is represented in code by a `ThermocyclerContext` object, which has methods for controlling the lid, controlling the block, and setting _profiles_ \u2014 timed heating and cooling routines that can be repeated automatically.\n\nThe examples in this section will use a Thermocycler Module GEN2 loaded as follows:\n\n```\ntc_mod = protocol.load_module(module_name=\"thermocyclerModuleV2\")\nplate = tc_mod.load_labware(name=\"nest_96_wellplate_100ul_pcr_full_skirt\")\n\n```\n\nNew in version 2\\.13\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 763, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "432a45aa-48e5-4043-98da-b8ae68632fa1": {"__data__": {"id_": "432a45aa-48e5-4043-98da-b8ae68632fa1", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8c47a83a-cece-4eed-9754-e87cfa1311fb", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "008f4a06d2ca3b4c082a175e5ae84990cdb7af9848c82c92653900dc84465a11", "class_name": "RelatedNodeInfo"}}, "text": "Lid Control\n\nThe Thermocycler can control the position and temperature of its lid.\n\nTo change the lid position, use `open_lid()` and `close_lid()`. When the lid is open, the pipettes can access the loaded labware.\n\nYou can also control the temperature of the lid. Acceptable target temperatures are between 37 and 110 \u00b0C. Use `set_lid_temperature()`, which takes one parameter: the target `temperature` (in degrees Celsius) as an integer. For example, to set the lid to 50 \u00b0C:\n\n```\ntc_mod.set_lid_temperature(temperature=50)\n\n```\n\nThe protocol will only proceed once the lid temperature reaches 50 \u00b0C. This is the case whether the previous temperature was lower than 50 \u00b0C (in which case the lid will actively heat) or higher than 50 \u00b0C (in which case the lid will passively cool).\n\nYou can turn off the lid heater at any time with `deactivate_lid()`.\n\nNote\n\nLid temperature is not affected by Thermocycler profiles. Therefore you should set an appropriate lid temperature to hold during your profile _before_ executing it. See Thermocycler Profiles for more information on defining and executing profiles.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1131, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "28e15324-5851-42c0-b1f2-0a1e1ed4cdac": {"__data__": {"id_": "28e15324-5851-42c0-b1f2-0a1e1ed4cdac", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7c325cb2-4c75-4937-b03b-0621439135e5", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "3966a50d4a5a90840532226991de33855ab9fbd464afc48702824d29f960da01", "class_name": "RelatedNodeInfo"}}, "text": "Block Control\n\nThe Thermocycler can control its block temperature, including holding at a temperature and adjusting for the volume of liquid held in its loaded plate.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 168, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "03bc875a-d6e8-455d-b9f1-86e01d0d4765": {"__data__": {"id_": "03bc875a-d6e8-455d-b9f1-86e01d0d4765", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b8310bbb-c7ee-4550-875c-c54c445580d8", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "83138f33147e050b599a711f5b401d404c60dd15cf58e8964a2196100324589a", "class_name": "RelatedNodeInfo"}}, "text": "Temperature\n\nTo set the block temperature inside the Thermocycler, use `set_block_temperature()`. At minimum you have to specify a `temperature` in degrees Celsius:\n\n```\ntc_mod.set_block_temperature(temperature=4)\n\n```\n\nIf you don\u2019t specify any other parameters, the Thermocycler will hold this temperature until a new temperature is set, `deactivate_block()` is called, or the module is powered off.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 425, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "60458e4e-0c67-42c2-8310-81e5d8f132f1": {"__data__": {"id_": "60458e4e-0c67-42c2-8310-81e5d8f132f1", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a1e3b10e-6074-4a02-b32e-9d69f689ab63", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "4933aa97be1bcd25b35c3b4c9a0b15955265863ebeb28e14edf8703409d527c5", "class_name": "RelatedNodeInfo"}}, "text": "Hold Time\n\nYou can optionally instruct the Thermocycler to hold its block temperature for a specific amount of time. You can specify `hold_time_minutes`, `hold_time_seconds`, or both (in which case they will be added together). For example, this will set the block to 4 \u00b0C for 4 minutes and 15 seconds:\n\n```\ntc_mod.set_block_temperature(\n    temperature=4,\n    hold_time_minutes=4,\n    hold_time_seconds=15)\n\n```\n\nNote\n\nYour protocol will not proceed to further commands while holding at a temperature. If you don\u2019t specify a hold time, the protocol will proceed as soon as the target temperature is reached.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 633, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "58a8ba9a-b614-4721-b5af-93142e365307": {"__data__": {"id_": "58a8ba9a-b614-4721-b5af-93142e365307", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "befa605f-8e9c-4682-905d-bb77f58d0fbb", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "94f48aeac66451c578f9818c01243b85fedfab47a6ff177d86e3d25554841634", "class_name": "RelatedNodeInfo"}}, "text": "Block Max Volume\n\nThe Thermocycler\u2019s block temperature controller varies its behavior based on the amount of liquid in the wells of its labware. Accurately specifying the liquid volume allows the Thermocycler to more precisely control the temperature of the samples. You should set the `block_max_volume` parameter to the amount of liquid in the _fullest_ well, measured in \u00b5L. If not specified, the Thermocycler will assume samples of 25 \u00b5L.\n\nIt is especially important to specify `block_max_volume` when holding at a temperature. For example, say you want to hold larger samples at a temperature for a short time:\n\n```\ntc_mod.set_block_temperature(\n    temperature=4,\n    hold_time_seconds=20,\n    block_max_volume=80)\n\n```\n\nIf the Thermocycler assumes these samples are 25 \u00b5L, it may not cool them to 4 \u00b0C before starting the 20\\-second timer. In fact, with such a short hold time they may not reach 4 \u00b0C at all!\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 940, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cf70cbfd-5bf7-4388-9cae-eab7d813a45b": {"__data__": {"id_": "cf70cbfd-5bf7-4388-9cae-eab7d813a45b", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d74a49ec-52f8-43a0-bbdf-8b110eae4626", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "22de98ac1ad09226fcd9459db4bb662b523e238bf088a4b1511447617915155e", "class_name": "RelatedNodeInfo"}}, "text": "Thermocycler Profiles\n\nIn addition to executing individual temperature commands, the Thermocycler can automatically cycle through a sequence of block temperatures to perform heat\\-sensitive reactions. These sequences are called _profiles_, which are defined in the Protocol API as lists of dictionaries. Each dictionary within the profile should have a `temperature` key, which specifies the temperature of the step, and either or both of `hold_time_seconds` and `hold_time_minutes`, which specify the duration of the step.\n\nFor example, this profile commands the Thermocycler to reach 10 \u00b0C and hold for 30 seconds, and then to reach 60 \u00b0C and hold for 45 seconds:\n\n```\nprofile = [\n    {\"temperature\":10, \"hold_time_seconds\":30},\n    {\"temperature\":60, \"hold_time_seconds\":45}\n]\n\n```\n\nOnce you have written the steps of your profile, execute it with `execute_profile()`. This function executes your profile steps multiple times depending on the `repetitions` parameter. It also takes a `block_max_volume` parameter, which is the same as that of the `set_block_temperature()` function.\n\nFor instance, a PCR prep protocol might define and execute a profile like this:\n\n```\nprofile = [\n    {\"temperature\":95, \"hold_time_seconds\":30},\n    {\"temperature\":57, \"hold_time_seconds\":30},\n    {\"temperature\":72, \"hold_time_seconds\":60}\n]\ntc_mod.execute_profile(steps=profile, repetitions=20, block_max_volume=32)\n\n```\n\nIn terms of the actions that the Thermocycler performs, this would be equivalent to nesting `set_block_temperature` commands in a `for` loop:\n\n```\nfor i in range(20):\n    tc_mod.set_block_temperature(95, hold_time_seconds=30, block_max_volume=32)\n    tc_mod.set_block_temperature(57, hold_time_seconds=30, block_max_volume=32)\n    tc_mod.set_block_temperature(72, hold_time_seconds=60, block_max_volume=32)\n\n```\n\nHowever, this code would generate 60 lines in the protocol\u2019s run log, while executing a profile is summarized in a single line. Additionally, you can set a profile once and execute it multiple times (with different numbers of repetitions and maximum volumes, if needed).\n\nNote\n\nTemperature profiles only control the temperature of the block in the Thermocycler. You should set a lid temperature before executing the profile using `set_lid_temperature()`.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2302, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1d73b0c5-6806-4d5b-a54f-52874070537a": {"__data__": {"id_": "1d73b0c5-6806-4d5b-a54f-52874070537a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d1445793-9701-4b67-836d-6945c31b6fab", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "908cb9a1f7432fff199b6fe85e271cdc943914d87134cae0aa033f78db2ea915", "class_name": "RelatedNodeInfo"}}, "text": "Changes with the GEN2 Thermocycler Module\n\nAll methods of `ThermocyclerContext` work with both the GEN1 and GEN2 Thermocycler. One practical difference is that the GEN2 module has a plate lift feature to make it easier to remove the plate manually or with the Opentrons Flex Gripper. To activate the plate lift, press the button on the Thermocycler for three seconds while the lid is open. If you need to do this in the middle of a run, call `pause()`, lift and move the plate, and then resume the run.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 504, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "78962a20-8d36-4f05-8fd0-b886d95a1ab1": {"__data__": {"id_": "78962a20-8d36-4f05-8fd0-b886d95a1ab1", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "208c29fa-b14d-4b20-8c2e-4cfbc76658c1", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ad7f39acd0c4fc35fc51118c8ae367954a1fa58dd03a51f39f83031657171305", "class_name": "RelatedNodeInfo"}}, "text": "Multiple Modules of the Same Type\n\nYou can use multiple modules of the same type within a single protocol. The exception is the Thermocycler Module, which has only one supported deck location because of its size. Running protocols with multiple modules of the same type requires version 4\\.3 or newer of the Opentrons App and robot server.\n\nWhen working with multiple modules of the same type, load them in your protocol according to their USB port number. Deck coordinates are required by the `load_labware()` method, but location does not determine which module loads first. Your robot will use the module with the lowest USB port number _before_ using a module of the same type that\u2019s connected to higher numbered USB port. The USB port number (not deck location) determines module load sequence, starting with the lowest port number first.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 845, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1a164fab-96ca-46eb-9814-08452d18b867": {"__data__": {"id_": "1a164fab-96ca-46eb-9814-08452d18b867", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c58902b7-d175-49cc-b12e-e5d57bb46c0a", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "b10d835e199e86e2dbfe314d0dc42245960e23269a6e55489d0e3920e0feedb4", "class_name": "RelatedNodeInfo"}}, "text": "Flex\n\nIn this example, `temperature_module_1` loads first because it\u2019s connected to USB port 2\\. `temperature_module_2` loads next because it\u2019s connected to USB port 6\\.\n\n```\nfrom opentrons import protocol_api\n\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n  # Load Temperature Module 1 in deck slot D1 on USB port 2\n  temperature_module_1 = protocol.load_module(\n    module_name=\"temperature module gen2\",\n    location=\"D1\")\n\n  # Load Temperature Module 2 in deck slot C1 on USB port 6\n  temperature_module_2 = protocol.load_module(\n    module_name=\"temperature module gen2\",\n    location=\"C1\")\n\n```\n\nThe Temperature Modules are connected as shown here:", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 717, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e63d0cfd-7b4b-4a0a-b5b1-1a3f856b75d5": {"__data__": {"id_": "e63d0cfd-7b4b-4a0a-b5b1-1a3f856b75d5", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5acc5950-7cb8-4531-910f-c539038168b4", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "68332fc36802759fafef539edce44186f083b307db0e60adda9aefabf7e6be26", "class_name": "RelatedNodeInfo"}}, "text": "OT-2\n\nIn this example, `temperature_module_1` loads first because it\u2019s connected to USB port 1\\. `temperature_module_2` loads next because it\u2019s connected to USB port 3\\.\n\n```\nfrom opentrons import protocol_api\n\nmetadata = {\"apiLevel\": \"2.19\"}\n\n\ndef run(protocol: protocol_api.ProtocolContext):\n    # Load Temperature Module 1 in deck slot C1 on USB port 1\n    temperature_module_1 = protocol.load_module(\n        load_name=\"temperature module gen2\", location=\"1\"\n    )\n\n    # Load Temperature Module 2 in deck slot D3 on USB port 2\n    temperature_module_2 = protocol.load_module(\n        load_name=\"temperature module gen2\", location=\"3\"\n    )\n\n```\n\nThe Temperature Modules are connected as shown here:\n\nBefore running your protocol, it\u2019s a good idea to use the module controls in the Opentrons App to check that commands are being sent where you expect.\n\nSee the support article Using Modules of the Same Type for more information.\n\nHardware modules are powered and unpowered deck\\-mounted peripherals. The Flex and OT\\-2 are aware of deck\\-mounted powered modules when they\u2019re attached via a USB connection and used in an uploaded protocol. The robots do not know about unpowered modules until you use one in a protocol and upload it to the Opentrons App.\n\nPowered modules include the Heater\\-Shaker Module, Magnetic Module, Temperature Module, and Thermocycler Module. The 96\\-well Magnetic Block is an unpowered module.\n\nPages in this section of the documentation cover:\n\n> - Setting up modules and their labware.\n> - Working with the module contexts for each type of module.\n>\n> > - Heater\\-Shaker Module\n> >   - Magnetic Block\n> >   - Magnetic Module\n> >   - Temperature Module\n> >   - Thermocycler Module\n>\n> - Working with multiple modules of the same type in a single protocol.\n\nNote\n\nThroughout these pages, most code examples use coordinate deck slot locations (e.g. `\"D1\"`, `\"D2\"`), like those found on Flex. If you have an OT\\-2 and are using API version 2\\.14 or earlier, replace the coordinate with its numeric OT\\-2 equivalent. For example, slot D1 on Flex corresponds to slot 1 on an OT\\-2\\. See Deck Slots for more information.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2148, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6ff857f1-973d-43dd-8b89-960224fdb0d1": {"__data__": {"id_": "6ff857f1-973d-43dd-8b89-960224fdb0d1", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a94512db-7ba1-4546-96c5-46c118179f66", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "2f00c11b1341312198787db239d24633c2e95670a02b1e0202c692b5dbc2d435", "class_name": "RelatedNodeInfo"}}, "text": "Deck Slots\n\nDeck slots are where you place hardware items on the deck surface of your Opentrons robot. In the API, you load the corresponding items into your protocol with methods like `ProtocolContext.load_labware`, `ProtocolContext.load_module`, or `ProtocolContext.load_trash_bin`. When you call these methods, you need to specify which slot to load the item in.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 367, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bebea504-4f0c-43b7-9b4a-7ae822f8033b": {"__data__": {"id_": "bebea504-4f0c-43b7-9b4a-7ae822f8033b", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "42247bef-29bf-488e-9c35-cfbde445f7c2", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "aedc412596aa893d6a1cb46588f882d9f4bed77c0f7a647f32d8d9d7fe7342e8", "class_name": "RelatedNodeInfo"}}, "text": "Physical Deck Labels\n\nFlex uses a coordinate labeling system for slots A1 (back left) through D4 (front right). Columns 1 through 3 are in the _working area_ and are accessible by pipettes and the gripper. Column 4 is in the _staging area_ and is only accessible by the gripper. For more information on staging area slots, see Deck Configuration below.\n\nOT\\-2 uses a numeric labeling system for slots 1 (front left) through 11 (back center). The back right slot is occupied by the fixed trash.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 495, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "722b1b8b-a4c6-4266-bd9b-adb38c05e779": {"__data__": {"id_": "722b1b8b-a4c6-4266-bd9b-adb38c05e779", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7a5223ad-8618-4c77-8174-a0aa8c67cbad", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "eaf89a063aff9373faeb73942b6b383bd9cfc9d51682028fa26d448da6f2b1fa", "class_name": "RelatedNodeInfo"}}, "text": "API Deck Labels\n\nThe API accepts values that correspond to the physical deck slot labels on a Flex or OT\\-2 robot. Specify a slot in either format:\n\n- A coordinate like `\"A1\"`. This format must be a string.\n- A number like `\"10\"` or `10`. This format can be a string or an integer.\n\nAs of API version 2\\.15, the Flex and OT\\-2 formats are interchangeable. You can use either format, regardless of which robot your protocol is for. You could even mix and match formats within a protocol, although this is not recommended.\n\nFor example, these two `load_labware()` commands are equivalent:\n\n```\nprotocol.load_labware(\"nest_96_wellplate_200ul_flat\", \"A1\")\n\n```\n\nNew in version 2\\.15\\.\n\n```\nprotocol.load_labware(\"nest_96_wellplate_200ul_flat\", 10)\n\n```\n\nNew in version 2\\.0\\.\n\nBoth of these commands would require you to load the well plate in the back left slot of the robot.\n\nThe correspondence between deck labels is based on the relative locations of the slots. The full list of slot equivalencies is as follows:\n\n| Flex  | A1  | A2  | A3    | B1  | B2  | B3  | C1  | C2  | C3  | D1  | D2  | D3  |\n| ----- | --- | --- | ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| OT\\-2 | 10  | 11  | Trash | 7   | 8   | 9   | 4   | 5   | 6   | 1   | 2   | 3   |\n\nSlots A4, B4, C4, and D4 on Flex have no equivalent on OT\\-2\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1331, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ebb78474-a429-4968-9c44-9ffd62980a32": {"__data__": {"id_": "ebb78474-a429-4968-9c44-9ffd62980a32", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9198039c-fe34-4d2d-90c9-dc39b8a80fc4", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "3f0a94710655fe62d5a1a2f1ecaf5a107eda1f0ca40a5b713405655d1d574c4f", "class_name": "RelatedNodeInfo"}}, "text": "Deck Configuration\n\nA Flex running robot system version 7\\.1\\.0 or higher lets you specify its deck configuration on the touchscreen or in the Opentrons App. This tells the robot the positions of unpowered _deck fixtures_: items that replace standard deck slots. The following table lists currently supported deck fixtures and their allowed deck locations.\n\n| Fixture            | Slots         |\n| ------------------ | ------------- |\n| Staging area slots | A3\u2013D3         |\n| Trash bin          | A1\u2013D1, A3\\-D3 |\n| Waste chute        | D3            |\n\nWhich fixtures you need to configure depend on both load methods and the effects of other methods called in your protocol. The following sections explain how to configure each type of fixture.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 748, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6129bcca-6dca-4c47-9abe-fef3ad391a92": {"__data__": {"id_": "6129bcca-6dca-4c47-9abe-fef3ad391a92", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "91ea4229-4514-4e32-9db5-c1b1c4643864", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "5acb38cb9d979f5d06fa3bcfd0de158562a3fa040f4a3850b0195db1a9b520e7", "class_name": "RelatedNodeInfo"}}, "text": "Staging Area Slots\n\nSlots A4 through D4 are the staging area slots. Pipettes can\u2019t reach the staging area, but these slots are always available in the API for loading and moving labware. Using a slot in column 4 as the `location` argument of `load_labware()` or the `new_location` argument of `move_labware()` will require the corresponding staging area slot in the robot\u2019s deck configuration:\n\n```\nplate_1 = protocol.load_labware(\n    load_name=\"corning_96_wellplate_360ul_flat\", location=\"C3\"\n)  # no staging slots required\nplate_2 = protocol.load_labware(\n    load_name=\"corning_96_wellplate_360ul_flat\", location=\"D4\"\n)  # one staging slot required\nprotocol.move_labware(\n    labware=plate_1, new_location=\"C4\"\n)  # two staging slots required\n\n```\n\nNew in version 2\\.16\\.\n\nSince staging area slots also include a standard deck slot in column 3, they are physically incompatible with powered modules in the same row of column 3\\. For example, if you try to load a module in C3 and labware in C4, the API will raise an error:\n\n```\ntemp_mod = protocol.load_module(\n    module_name=\"temperature module gen2\",\n    location=\"C3\"\n)\nstaging_plate = protocol.load_labware(\n    load_name=\"corning_96_wellplate_360ul_flat\", location=\"C4\"\n)  # deck conflict error\n\n```\n\nIt is possible to use slot D4 along with the waste chute. See the Waste Chute section below for details.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1368, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8585ac52-3bee-4b6e-ad4e-42950a64eac3": {"__data__": {"id_": "8585ac52-3bee-4b6e-ad4e-42950a64eac3", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8b4d949b-1c03-4f6d-b762-181d5bb8aaee", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "93953926eba1308cd3a2b92d06e7f0fdb66378494dc0b2d7fd972e51e6281020", "class_name": "RelatedNodeInfo"}}, "text": "Trash Bin\n\nIn version 2\\.15 of the API, Flex can only have a single trash bin in slot A3\\. You do not have to (and cannot) load the trash in version 2\\.15 protocols.\n\nStarting in API version 2\\.16, you must load trash bin fixtures in your protocol in order to use them. Use `load_trash_bin()` to load a movable trash bin. This example loads a single bin in the default location:\n\n```\ndefault_trash = protocol.load_trash_bin(location = \"A3\")\n\n```\n\nNew in version 2\\.16\\.\n\nCall `load_trash_bin()` multiple times to add more than one bin. See Adding Trash Containers for more information on using pipettes with multiple trash bins.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 630, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "46a697fe-c86c-47dc-8671-bbf42a63fd10": {"__data__": {"id_": "46a697fe-c86c-47dc-8671-bbf42a63fd10", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7b31efe2-ee89-4579-b759-61dbb22030a7", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "8d90b0af8d5c4c15f7bca1ce8737f67c3536ec2b9d46945f6c0e4a5681c049b8", "class_name": "RelatedNodeInfo"}}, "text": "Waste Chute\n\nThe waste chute accepts various materials from Flex pipettes or the Flex Gripper and uses gravity to transport them outside of the robot for disposal. Pipettes can dispose of liquid or drop tips into the chute. The gripper can drop tip racks and other labware into the chute.\n\nTo use the waste chute, first use `load_waste_chute()` to load it in slot D3:\n\n```\nchute = protocol.load_waste_chute()\n\n```\n\nNew in version 2\\.16\\.\n\nThe `load_waste_chute()` method takes no arguments, since D3 is the only valid location for the chute. However, there are multiple variant configurations of the waste chute, depending on how other methods in your protocol use it.\n\nThe waste chute is installed either on a standard deck plate adapter or on a deck plate adapter with a staging area. If any `load_labware()` or `move_labware()` calls in your protocol reference slot D4, you have to use the deck plate adapter with staging area.\n\nThe waste chute has a removable cover with a narrow opening which helps prevent aerosols and droplets from contaminating the working area. 1\\- and 8\\-channel pipettes can dispense liquid, blow out, or drop tips through the opening in the cover. Any of the following require you to remove the cover.\n\n> - `dispense()`, `blow_out()`, or `drop_tip()` with a 96\\-channel pipette.\n> - `move_labware()` with the chute as `new_location` and `use_gripper=True`.\n\nIf your protocol _does not_ call any of these methods, your deck configuration should include the cover.\n\nIn total, there are four possible deck configurations for the waste chute.\\* Waste chute only\n\n- Waste chute with cover\n- Waste chute with staging area slot\n- Waste chute with staging area slot and cover", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1698, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b45d6705-cd5a-46b6-95bf-fc2590ceae85": {"__data__": {"id_": "b45d6705-cd5a-46b6-95bf-fc2590ceae85", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6c261d99-e848-4553-920f-ba01e4a108ab", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "f6dfcdff9281abd0d277ac5e6e75e7a784a5c5e2997c70f2568edae4448aad36", "class_name": "RelatedNodeInfo"}}, "text": "Deck Conflicts\n\nA deck conflict check occurs when preparing to run a Python protocol on a Flex running robot system version 7\\.1\\.0 or higher. The Opentrons App and touchscreen will prevent you from starting the protocol run until any conflicts are resolved. You can resolve them one of two ways:\n\n> - Physically move hardware around the deck, and update the deck configuration.\n> - Alter your protocol to work with the current deck configuration, and resend the protocol to your Flex.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 487, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "455bda67-681a-4c2c-b3f1-a46656284212": {"__data__": {"id_": "455bda67-681a-4c2c-b3f1-a46656284212", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "490a1ee7-85e9-4f30-b09a-3b5156bde184", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "d0f0c5c31704c02c3118a0c8756a4bb67337199b6c3c18a5859769b71b684300", "class_name": "RelatedNodeInfo"}}, "text": "Pipettes", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 10, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eaa38dc3-16d5-4fc1-bfc4-8bc5201ef35a": {"__data__": {"id_": "eaa38dc3-16d5-4fc1-bfc4-8bc5201ef35a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c0b93724-2c51-48ea-881d-a675e7b84f73", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "5d82a20d18494f63ea947574b63a6b835c56ed318cf133e23b50234ecf806903", "class_name": "RelatedNodeInfo"}}, "text": "Loading Pipettes\n\nWhen writing a protocol, you must inform the Protocol API about the pipettes you will be using on your robot. The `ProtocolContext.load_instrument()` function provides this information and returns an `InstrumentContext` object.\n\nAs noted above, you call the `load_instrument()` method to load a pipette. This method also requires the pipette\u2019s API load name, its left or right mount position, and (optionally) a list of associated tip racks. Even if you don\u2019t use the pipette anywhere else in your protocol, the Opentrons App and the robot won\u2019t let you start the protocol run until all pipettes loaded by `load_instrument()` are attached properly.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 668, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e4397436-7339-45ad-b584-1eaafff7c407": {"__data__": {"id_": "e4397436-7339-45ad-b584-1eaafff7c407", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "80cfdd44-fcd3-4767-9605-e28c5672c4ac", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "5dc1caadc8b72e868753cb2b5069ccabd03c6681d8ffe5303da273d25493f3e7", "class_name": "RelatedNodeInfo"}}, "text": "API Load Names\n\nThe pipette\u2019s API load name (`instrument_name`) is the first parameter of the `load_instrument()` method. It tells your robot which attached pipette you\u2019re going to use in a protocol. The tables below list the API load names for the currently available Flex and OT\\-2 pipettes.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 295, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eb86d96f-7552-402f-9542-3eaad70ad36e": {"__data__": {"id_": "eb86d96f-7552-402f-9542-3eaad70ad36e", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5ec31165-dffd-4cf1-a2d8-43fc9def9a40", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "488fc07d59174a3ba619d643717eae7c06f5f63dc799a8a2d1d3d463318d7615", "class_name": "RelatedNodeInfo"}}, "text": "Flex Pipettes\n\n| Pipette Model            | Volume (\u00b5L)          | API Load Name         |     |\n| ------------------------ | -------------------- | --------------------- | --- |\n| Flex 1\\-Channel Pipette  | 1\u201350                 | `flex_1channel_50`    |     |\n| 5\u20131000                   | `flex_1channel_1000` |                       |\n| Flex 8\\-Channel Pipette  | 1\u201350                 | `flex_8channel_50`    |     |\n| 5\u20131000                   | `flex_8channel_1000` |                       |\n| Flex 96\\-Channel Pipette | 5\u20131000               | `flex_96channel_1000` |     |", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 578, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "eba67ed7-ccd8-454e-950d-0b2daf8be6ce": {"__data__": {"id_": "eba67ed7-ccd8-454e-950d-0b2daf8be6ce", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9767c140-225f-4161-a0f6-2009754c94c8", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "a99b37dd12a772a1655d09351df60a192b1e8db34a0e7b235b3dc55a66a48c56", "class_name": "RelatedNodeInfo"}}, "text": "OT-2 Pipettes\n\n| Pipette Model              | Volume (\u00b5L)       | API Load Name       |\n| -------------------------- | ----------------- | ------------------- |\n| P20 Single\\-Channel GEN2   | 1\\-20             | `p20_single_gen2`   |\n| P20 Multi\\-Channel GEN2    | `p20_multi_gen2`  |\n| P300 Single\\-Channel GEN2  | 20\\-300           | `p300_single_gen2`  |\n| P300 Multi\\-Channel GEN2   | `p300_multi_gen2` |\n| P1000 Single\\-Channel GEN2 | 100\\-1000         | `p1000_single_gen2` |\n\nSee the OT\\-2 Pipette Generations section if you\u2019re using GEN1 pipettes on an OT\\-2\\. The GEN1 family includes the P10, P50, and P300 single\\- and multi\\-channel pipettes, along with the P1000 single\\-channel model.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 700, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1b154b3f-58e2-48d9-bb8b-072729a01454": {"__data__": {"id_": "1b154b3f-58e2-48d9-bb8b-072729a01454", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "947c0910-1b00-4ba5-9046-be95eb1f44b0", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "28684a7bb3e6e42b058ac975150aad22bab7dded6616aab626cb44d3fcfd64fb", "class_name": "RelatedNodeInfo"}}, "text": "Loading Flex 1\\- and 8\\-Channel Pipettes\n\nThis code sample loads a Flex 1\\-Channel Pipette in the left mount and a Flex 8\\-Channel Pipette in the right mount. Both pipettes are 1000 \u00b5L. Each pipette uses its own 1000 \u00b5L tip rack.\n\n```\nfrom opentrons import protocol_api\n\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\":\"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    tiprack1 = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_1000ul\", location=\"D1\")\n    tiprack2 = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_1000ul\", location=\"C1\")\n    left = protocol.load_instrument(\n        instrument_name=\"flex_1channel_1000\",\n        mount=\"left\",\n        tip_racks=[tiprack1])\n    right = protocol.load_instrument(\n        instrument_name=\"flex_8channel_1000\",\n        mount=\"right\",\n        tip_racks=[tiprack2])\n\n```\n\nIf you\u2019re writing a protocol that uses the Flex Gripper, you might think that this would be the place in your protocol to declare that. However, the gripper doesn\u2019t require `load_instrument`! Whether your gripper requires a protocol is determined by the presence of `ProtocolContext.move_labware()` commands. See Moving Labware for more details.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1216, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9b8022da-08b4-4471-bcba-100c6996adea": {"__data__": {"id_": "9b8022da-08b4-4471-bcba-100c6996adea", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "87f281d4-5221-4688-91fd-022e020b9131", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "738d8a8f7d9f42d9df88b045fdd9468f093f760a89f206994ae1324aad3a3b21", "class_name": "RelatedNodeInfo"}}, "text": "Loading a Flex 96\\-Channel Pipette\n\nThis code sample loads the Flex 96\\-Channel Pipette. Because of its size, the Flex 96\\-Channel Pipette requires the left _and_ right pipette mounts. You cannot use this pipette with 1\\- or 8\\-Channel Pipette in the same protocol or when these instruments are attached to the robot. Load the 96\\-channel pipette as follows:\n\n```\ndef run(protocol: protocol_api.ProtocolContext):\n    pipette = protocol.load_instrument(\n        instrument_name=\"flex_96channel_1000\"\n    )\n\n```\n\nIn protocols specifying API version 2\\.15, also include `mount=\"left\"` as a parameter of `load_instrument()`.\n\nNew in version 2\\.15\\.\n\nChanged in version 2\\.16: The `mount` parameter is optional.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 708, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9e49aa4f-872f-4e52-b4d8-2d427dd64a6a": {"__data__": {"id_": "9e49aa4f-872f-4e52-b4d8-2d427dd64a6a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7afba3f6-4616-4a9f-a8dc-77603366355a", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "54ba93b4cc21e03e110833dd5adff0bede3c14ea5794bd265b4b8ed1f11bd811", "class_name": "RelatedNodeInfo"}}, "text": "Loading OT\\-2 Pipettes\n\nThis code sample loads a P1000 Single\\-Channel GEN2 pipette in the left mount and a P300 Single\\-Channel GEN2 pipette in the right mount. Each pipette uses its own 1000 \u00b5L tip rack.\n\n```\nfrom opentrons import protocol_api\n\nmetadata = {\"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    tiprack1 = protocol.load_labware(\n        load_name=\"opentrons_96_tiprack_1000ul\", location=1)\n    tiprack2 = protocol.load_labware(\n        load_name=\"opentrons_96_tiprack_1000ul\", location=2)\n    left = protocol.load_instrument(\n        instrument_name=\"p1000_single_gen2\",\n        mount=\"left\",\n        tip_racks=[tiprack1])\n    right = protocol.load_instrument(\n        instrument_name=\"p300_multi_gen2\",\n        mount=\"right\",\n        tip_racks=[tiprack1])\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 824, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5cf4292a-f5f9-4d89-954f-d622498eb7c8": {"__data__": {"id_": "5cf4292a-f5f9-4d89-954f-d622498eb7c8", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "275b9a1c-df4e-4a13-b66d-aa0d91623187", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "fc5054a9434c7af06abc8d57de99bb3fe5188ba55933177956021049b43446e7", "class_name": "RelatedNodeInfo"}}, "text": "Adding Tip Racks\n\nThe `load_instrument()` method includes the optional argument `tip_racks`. This parameter accepts a list of tip rack labware objects, which lets you to specify as many tip racks as you want. You can also edit a pipette\u2019s tip racks after loading it by setting its `InstrumentContext.tip_racks` property.\n\nNote\n\nSome methods, like `configure_nozzle_layout()`, reset a pipette\u2019s tip racks. See Partial Tip Pickup for more information.\n\nThe advantage of using `tip_racks` is twofold. First, associating tip racks with your pipette allows for automatic tip tracking throughout your protocol. Second, it removes the need to specify tip locations in the `InstrumentContext.pick_up_tip()` method. For example, let\u2019s start by loading loading some labware and instruments like this:\n\n```\ndef run(protocol: protocol_api.ProtocolContext):\n    tiprack_left = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_200ul\", location=\"D1\")\n    tiprack_right = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_200ul\", location=\"D2\")\n    left_pipette = protocol.load_instrument(\n        instrument_name=\"flex_8channel_1000\", mount=\"left\")\n    right_pipette = protocol.load_instrument(\n        instrument_name=\"flex_8channel_1000\",\n        mount=\"right\",\n        tip_racks=[tiprack_right])\n\n```\n\nLet\u2019s pick up a tip with the left pipette. We need to specify the location as an argument of `pick_up_tip()`, since we loaded the left pipette without a `tip_racks` argument.\n\n```\nleft_pipette.pick_up_tip(tiprack_left[\"A1\"])\nleft_pipette.drop_tip()\n\n```\n\nBut now you have to specify `tiprack_left` every time you call `pick_up_tip`, which means you\u2019re doing all your own tip tracking:\n\n```\nleft_pipette.pick_up_tip(tiprack_left[\"A2\"])\nleft_pipette.drop_tip()\nleft_pipette.pick_up_tip(tiprack_left[\"A3\"])\nleft_pipette.drop_tip()\n\n```\n\nHowever, because you specified a tip rack location for the right pipette, the robot will automatically pick up from location `A1` of its associated tiprack:\n\n```\nright_pipette.pick_up_tip()\nright_pipette.drop_tip()\n\n```\n\nAdditional calls to `pick_up_tip` will automatically progress through the tips in the right rack:\n\n```\nright_pipette.pick_up_tip()  # picks up from A2\nright_pipette.drop_tip()\nright_pipette.pick_up_tip()  # picks up from A3\nright_pipette.drop_tip()\n\n```\n\nNew in version 2\\.0\\.\n\nSee also Building Block Commands and Complex Commands.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2416, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a5e7ea33-3ab1-40d6-bd11-65f09aee9b12": {"__data__": {"id_": "a5e7ea33-3ab1-40d6-bd11-65f09aee9b12", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7030ba58-c661-4098-a404-e8982afc283f", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "8b81eb36061fe528a67b7629bf4915b653da03899aae0af4d63abe233a396068", "class_name": "RelatedNodeInfo"}}, "text": "Adding Trash Containers\n\nThe API automatically assigns a `trash_container` to pipettes, if one is available in your protocol. The `trash_container` is where the pipette will dispose tips when you call `drop_tip()` with no arguments. You can change the trash container, if you don\u2019t want to use the default.\n\nOne example of when you might want to change the trash container is a Flex protocol that goes through a lot of tips. In a case where the protocol uses two pipettes, you could load two trash bins and assign one to each pipette:\n\n```\nleft_pipette = protocol.load_instrument(\n    instrument_name=\"flex_8channel_1000\", mount=\"left\"\n)\nright_pipette = protocol.load_instrument(\n    instrument_name=\"flex_8channel_50\", mount=\"right\"\n)\nleft_trash = load_trash_bin(\"A3\")\nright_trash = load_trash_bin(\"B3\")\nleft_pipette.trash_container = left_trash\nright_pipette.trash_container = right_trash\n\n```\n\nAnother example is a Flex protocol that uses a waste chute. Say you want to only dispose labware in the chute, and you want the pipette to drop tips in a trash bin. You can implicitly get the trash bin to be the pipette\u2019s `trash_container` based on load order, or you can ensure it by setting it after all the load commands:\n\n```\npipette = protocol.load_instrument(\n    instrument_name=\"flex_1channel_1000\",\n    mount=\"left\"\n)\nchute = protocol.load_waste_chute()  # default because loaded first\ntrash = protocol.load_trash_bin(\"A3\")\npipette.trash_container = trash  # overrides default\n\n```\n\nNew in version 2\\.0\\.\n\nChanged in version 2\\.16: Added support for `TrashBin` and `WasteChute` objects.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1594, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7696e8f3-bd2b-4bee-8522-e042718e1223": {"__data__": {"id_": "7696e8f3-bd2b-4bee-8522-e042718e1223", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "dfdf4f76-0f19-41fc-ac76-c1885dba6401", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "f461991db9b6bf0b0e896c6a97941dadec441b2156b3a8efcb5aa38b21ee5f61", "class_name": "RelatedNodeInfo"}}, "text": "Pipette Characteristics\n\nEach Opentrons pipette has different capabilities, which you\u2019ll want to take advantage of in your protocols. This page covers some fundamental pipette characteristics.\n\nMulti\\-Channel Movement gives examples of how multi\\-channel pipettes move around the deck by using just one of their channels as a reference point. Taking this into account is important for commanding your pipettes to perform actions in the correct locations.\n\nPipette Flow Rates discusses how quickly each type of pipette can handle liquids. The defaults are designed to operate quickly, based on the pipette\u2019s hardware and assuming that you\u2019re handling aqueous liquids. You can speed up or slow down a pipette\u2019s flow rate to suit your protocol\u2019s needs.\n\nFinally, the volume ranges of pipettes affect what you can do with them. The volume ranges for current pipettes are listed on the Loading Pipettes page. The OT\\-2 Pipette Generations section of this page describes how the API behaves when running protocols that specify older OT\\-2 pipettes.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1044, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1b4e2318-b2e7-49fe-8557-fd1eb3335a2d": {"__data__": {"id_": "1b4e2318-b2e7-49fe-8557-fd1eb3335a2d", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9cd1c731-02a5-4eb9-a77a-c2c47a97fde0", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "a9dc918a713d4fda513dc93713455aadd384b0e65129b18f8c9154d44d3530db", "class_name": "RelatedNodeInfo"}}, "text": "Multi\\-Channel Movement\n\nAll building block and complex commands work with single\\- and multi\\-channel pipettes.\n\nTo keep the protocol API consistent when using single\\- and multi\\-channel pipettes, commands treat the back left channel of a multi\\-channel pipette as its _primary channel_. Location arguments of pipetting commands use the primary channel. The `InstrumentContext.configure_nozzle_layout()` method can change the pipette\u2019s primary channel, using its `start` parameter. See Partial Tip Pickup for more information.\n\nWith a pipette\u2019s default settings, you can generally access the wells indicated in the table below. Moving to any other well may cause the pipette to crash.\n\n| Channels | 96\\-well plate   | 384\\-well plate  |\n| -------- | ---------------- | ---------------- |\n| 1        | Any well, A1\u2013H12 | Any well, A1\u2013P24 |\n| 8        | A1\u2013A12           | A1\u2013B24           |\n| 96       | A1 only          | A1\u2013B2            |\n\nAlso, you should apply any location offset, such as `Well.top()` or `Well.bottom()`, to the well accessed by the primary channel. Since all of the pipette\u2019s channels move together, each channel will have the same offset relative to the well that it is over.\n\nFinally, because each multi\\-channel pipette has only one motor, they always aspirate and dispense on all channels simultaneously.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1335, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f74db465-fd34-4fbf-8c47-54ebe58055bd": {"__data__": {"id_": "f74db465-fd34-4fbf-8c47-54ebe58055bd", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2fb81f50-58ea-4f20-9d89-f9b46d015d60", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "aa1b8b9239af6e0942a9c501ffca70d7d1c05ef722c31d4e669e55e89c1abb25", "class_name": "RelatedNodeInfo"}}, "text": "8\\-Channel, 96\\-Well Plate Example\n\nTo demonstrate these concepts, let\u2019s write a protocol that uses a Flex 8\\-Channel Pipette and a 96\\-well plate. We\u2019ll then aspirate and dispense a liquid to different locations on the same well plate. To start, let\u2019s load a pipette in the right mount and add our labware.\n\n```\nfrom opentrons import protocol_api\n\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\":\"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    # Load a tiprack for 1000 \u00b5L tips\n    tiprack1 = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_1000ul\", location=\"D1\")\n    # Load a 96-well plate\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\", location=\"C1\")\n    # Load an 8-channel pipette on the right mount\n    right = protocol.load_instrument(\n        instrument_name=\"flex_8channel_1000\",\n        mount=\"right\",\n        tip_racks=[tiprack1])\n\n```\n\nAfter loading our instruments and labware, let\u2019s tell the robot to pick up a pipette tip from location `A1` in `tiprack1`:\n\n```\nright.pick_up_tip()\n\n```\n\nWith the backmost pipette channel above location A1 on the tip rack, all eight channels are above the eight tip rack wells in column 1\\.\n\nAfter picking up a tip, let\u2019s tell the robot to aspirate 300 \u00b5L from the well plate at location `A2`:\n\n```\nright.aspirate(volume=300, location=plate[\"A2\"])\n\n```\n\nWith the backmost pipette tip above location A2 on the well plate, all eight channels are above the eight wells in column 2\\.\n\nFinally, let\u2019s tell the robot to dispense 300 \u00b5L into the well plate at location `A3`:\n\n```\nright.dispense(volume=300, location=plate[\"A3\"].top())\n\n```\n\nWith the backmost pipette tip above location A3, all eight channels are above the eight wells in column 3\\. The pipette will dispense liquid into all the wells simultaneously.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1835, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e256bf26-9f69-4769-9b27-936bc70c69f6": {"__data__": {"id_": "e256bf26-9f69-4769-9b27-936bc70c69f6", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0f9e27a5-ff6c-4fc2-aa7f-7fee480f1057", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "5225d2548a58bba4752c4fe826ba6e715fb3e2c05215501da9a2b235921cc4ce", "class_name": "RelatedNodeInfo"}}, "text": "8\\-Channel, 384\\-Well Plate Example\n\nIn general, you should specify wells in the first row of a well plate when using multi\\-channel pipettes. An exception to this rule is when using 384\\-well plates. The greater well density means the nozzles of a multi\\-channel pipette can only access every other well in a column. Specifying well A1 accesses every other well starting with the first (rows A, C, E, G, I, K, M, and O). Similarly, specifying well B1 also accesses every other well, but starts with the second (rows B, D, F, H, J, L, N, and P).\n\nTo demonstrate these concepts, let\u2019s write a protocol that uses a Flex 8\\-Channel Pipette and a 384\\-well plate. We\u2019ll then aspirate and dispense a liquid to different locations on the same well plate. To start, let\u2019s load a pipette in the right mount and add our labware.\n\n```\ndef run(protocol: protocol_api.ProtocolContext):\n    # Load a tiprack for 200 \u00b5L tips\n    tiprack1 = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_200ul\", location=\"D1\")\n    # Load a well plate\n    plate = protocol.load_labware(\n        load_name=\"corning_384_wellplate_112ul_flat\", location=\"D2\")\n    # Load an 8-channel pipette on the right mount\n    right = protocol.load_instrument(\n        instrument_name=\"flex_8channel_1000\",\n        mount=\"right\",\n        tip_racks=[tiprack1])\n\n```\n\nAfter loading our instruments and labware, let\u2019s tell the robot to pick up a pipette tip from location `A1` in `tiprack1`:\n\n```\nright.pick_up_tip()\n\n```\n\nWith the backmost pipette channel above location A1 on the tip rack, all eight channels are above the eight tip rack wells in column 1\\.\n\nAfter picking up a tip, let\u2019s tell the robot to aspirate 100 \u00b5L from the well plate at location `A1`:\n\n```\nright.aspirate(volume=100, location=plate[\"A1\"])\n\n```\n\nThe eight pipette channels will only aspirate from every other well in the column: A1, C1, E1, G1, I1, K1, M1, and O1\\.\n\nFinally, let\u2019s tell the robot to dispense 100 \u00b5L into the well plate at location `B1`:\n\n```\nright.dispense(volume=100, location=plate[\"B1\"])\n\n```\n\nThe eight pipette channels will only dispense into every other well in the column: B1, D1, F1, H1, J1, L1, N1, and P1\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2182, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "39e5dd2f-279d-4c90-92ee-31588e96d480": {"__data__": {"id_": "39e5dd2f-279d-4c90-92ee-31588e96d480", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "738137b4-f8a0-4cf8-93ca-a82448c99510", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "8d2570364e2a92205b130376200d683d44108c84401a35658eabbed3e53777bd", "class_name": "RelatedNodeInfo"}}, "text": "Pipette Flow Rates\n\nMeasured in \u00b5L/s, the flow rate determines how much liquid a pipette can aspirate, dispense, and blow out. Opentrons pipettes have their own default flow rates. The API lets you change the flow rate on a loaded `InstrumentContext` by altering the `InstrumentContext.flow_rate` properties listed below.\n\n- Aspirate: `InstrumentContext.flow_rate.aspirate`\n- Dispense: `InstrumentContext.flow_rate.dispense`\n- Blow out: `InstrumentContext.flow_rate.blow_out`\n\nThese flow rate properties operate independently. This means you can specify different flow rates for each property within the same protocol. For example, let\u2019s load a simple protocol and set different flow rates for the attached pipette.\n\n```\ndef run(protocol: protocol_api.ProtocolContext):\n    tiprack1 = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_1000ul\", location=\"D1\")\n    pipette = protocol.load_instrument(\n        instrument_name=\"flex_1channel_1000\",\n        mount=\"left\",\n        tip_racks=[tiprack1])\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\", location=\"D3\")\n    pipette.pick_up_tip()\n\n```\n\nLet\u2019s tell the robot to aspirate, dispense, and blow out the liquid using default flow rates. Notice how you don\u2019t need to specify a `flow_rate` attribute to use the defaults:\n\n```\npipette.aspirate(200, plate[\"A1\"])  # 160 \u00b5L/s\npipette.dispense(200, plate[\"A2\"])  # 160 \u00b5L/s\npipette.blow_out()                  #  80 \u00b5L/s\n\n```\n\nNow let\u2019s change the flow rates for each action:\n\n```\npipette.flow_rate.aspirate = 50\npipette.flow_rate.dispense = 100\npipette.flow_rate.blow_out = 75\npipette.aspirate(200, plate[\"A1\"])  #  50 \u00b5L/s\npipette.dispense(200, plate[\"A2\"])  # 100 \u00b5L/s\npipette.blow_out()                  #  75 \u00b5L/s\n\n```\n\nThese flow rates will remain in effect until you change the `flow_rate` attribute again _or_ call `configure_for_volume()`. Calling `configure_for_volume()` always resets all pipette flow rates to the defaults for the mode that it sets.\n\nNote\n\nIn API version 2\\.13 and earlier, `InstrumentContext.speed` offered similar functionality to `.flow_rate`. It attempted to set the plunger speed in mm/s. Due to technical limitations, that speed could only be approximate. You must use `.flow_rate` in version 2\\.14 and later, and you should consider replacing older code that sets `.speed`.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2385, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e48ede79-a022-4c5f-be16-db06f3238807": {"__data__": {"id_": "e48ede79-a022-4c5f-be16-db06f3238807", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1bf1a1eb-4f3a-43bf-bc0d-eeec6740e5b6", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "574f427b14265184c6090778a671e6fe65c4e423821ef2b56f37a3617a4e8994", "class_name": "RelatedNodeInfo"}}, "text": "Flex Pipette Flow Rates\n\nThe default flow rates for Flex pipettes depend on the maximum volume of the pipette and the capacity of the currently attached tip. For each pipette\u2013tip configuration, the default flow rate is the same for aspirate, dispense, and blowout actions.\n\n| Pipette Model                       | Tip Capacity (\u00b5L) | Flow Rate (\u00b5L/s) |\n| ----------------------------------- | ----------------- | ---------------- |\n| 50 \u00b5L (1\\- and 8\\-channel)          | All capacities    | 57               |\n| 1000 \u00b5L (1\\-, 8\\-, and 96\\-channel) | 50                | 478              |\n| 1000 \u00b5L (1\\-, 8\\-, and 96\\-channel) | 200               | 716              |\n| 1000 \u00b5L (1\\-, 8\\-, and 96\\-channel) | 1000              | 716              |\n\nAdditionally, all Flex pipettes have a well bottom clearance of 1 mm for aspirate and dispense actions.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 854, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3f2092cf-0e96-43d8-97eb-48a58384e898": {"__data__": {"id_": "3f2092cf-0e96-43d8-97eb-48a58384e898", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "dd468da5-f245-409c-925a-5fcf27cf380e", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "610c2866f7b03bdf74b6f645513faae231d97b0a30b65d1a1eb6da34139f623c", "class_name": "RelatedNodeInfo"}}, "text": "OT\\-2 Pipette Flow Rates\n\nThe following table provides data on the default aspirate, dispense, and blowout flow rates (in \u00b5L/s) for OT\\-2 GEN2 pipettes. Default flow rates are the same across all three actions.\n\n| Pipette Model              | Volume (\u00b5L) | Flow Rates (\u00b5L/s)                                           |\n| -------------------------- | ----------- | ----------------------------------------------------------- |\n| P20 Single\\-Channel GEN2   | 1\u201320        | _ API v2\\.6 or higher: 7\\.56 _ API v2\\.5 or lower: 3\\.78    |\n| P300 Single\\-Channel GEN2  | 20\u2013300      | _ API v2\\.6 or higher: 92\\.86 _ API v2\\.5 or lower: 46\\.43  |\n| P1000 Single\\-Channel GEN2 | 100\u20131000    | _ API v2\\.6 or higher: 274\\.7 _ API v2\\.5 or lower: 137\\.35 |\n| P20 Multi\\-Channel GEN2    | 1\u201320        | 7\\.6                                                        |\n| P300 Multi\\-Channel GEN2   | 20\u2013300      | 94                                                          |\n\nAdditionally, all OT\\-2 GEN2 pipettes have a default head speed of 400 mm/s and a well bottom clearance of 1 mm for aspirate and dispense actions.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1110, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8ec4eccb-5a2d-453d-bc1e-f9f5d9d33d4f": {"__data__": {"id_": "8ec4eccb-5a2d-453d-bc1e-f9f5d9d33d4f", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "26406906-933e-4c1d-95d3-e9ed1e19e876", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "139728a05a8ba761e38b5f9e6fe6af01a8cfa542423cb983693ea25aa8e0a729", "class_name": "RelatedNodeInfo"}}, "text": "OT\\-2 Pipette Generations\n\nThe OT\\-2 works with the GEN1 and GEN2 pipette models. The newer GEN2 pipettes have different volume ranges than the older GEN1 pipettes. With some exceptions, the volume ranges for GEN2 pipettes overlap those used by the GEN1 models. If your protocol specifies a GEN1 pipette, but you have a GEN2 pipette with a compatible volume range, you can still run your protocol. The OT\\-2 will consider the GEN2 pipette to have the same minimum volume as the GEN1 pipette. The following table lists the volume compatibility between the GEN2 and GEN1 pipettes.\n\n| GEN2 Pipette               | GEN1 Pipette               | GEN1 Volume  |\n| -------------------------- | -------------------------- | ------------ |\n| P20 Single\\-Channel GEN2   | P10 Single\\-Channel GEN1   | 1\\-10 \u00b5L     |\n| P20 Multi\\-Channel GEN2    | P10 Multi\\-Channel GEN1    | 1\\-10 \u00b5L     |\n| P300 Single\\-Channel GEN2  | P300 Single\\-Channel GEN1  | 30\\-300 \u00b5L   |\n| P300 Multi\\-Channel GEN2   | P300 Multi\\-Channel GEN1   | 20\\-200 \u00b5L   |\n| P1000 Single\\-Channel GEN2 | P1000 Single\\-Channel GEN1 | 100\\-1000 \u00b5L |\n\nThe single\\- and multi\\-channel P50 GEN1 pipettes are the exceptions here. If your protocol uses a P50 GEN1 pipette, there is no backward compatibility with a related GEN2 pipette. To replace a P50 GEN1 with a corresponding GEN2 pipette, edit your protocol to load a P20 Single\\-Channel GEN2 (for volumes below 20 \u00b5L) or a P300 Single\\-Channel GEN2 (for volumes between 20 and 50 \u00b5L).", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1492, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "735fba49-276e-4e4e-83ea-4ab6bcd8a376": {"__data__": {"id_": "735fba49-276e-4e4e-83ea-4ab6bcd8a376", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7ee82b10-a89f-43b8-8114-aa631e2d60bd", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "6728585e408efb5ba8dac9275ce4aab672607533459610ae6ee630cdfc6b31c4", "class_name": "RelatedNodeInfo"}}, "text": "Partial Tip Pickup\n\nThe 96\\-channel pipette occupies both pipette mounts on Flex, so it\u2019s not possible to attach another pipette at the same time. Partial tip pickup lets you perform some of the same actions that you would be able to perform with a second pipette. As of version 2\\.16 of the API, you can configure the 96\\-channel pipette to pick up a single column of tips, similar to the behavior of an 8\\-channel pipette.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 426, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ae9188c0-56fb-4efb-9736-b8f2e655514d": {"__data__": {"id_": "ae9188c0-56fb-4efb-9736-b8f2e655514d", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "de3923b4-ebd1-447c-8bca-07ac4828682d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ba500d057340d6a9f077449eb43af701129de88c2ef5d56185b55d7cce791fee", "class_name": "RelatedNodeInfo"}}, "text": "Nozzle Layout\n\nUse the `configure_nozzle_layout()` method to choose how many tips the 96\\-channel pipette will pick up. The method\u2019s `style` parameter accepts special layout constants. You must import these constants at the top of your protocol, or you won\u2019t be able to configure the pipette for partial tip pickup.\n\nAt minimum, import the API from the `opentrons` package:\n\n```\nfrom opentrons import protocol_api\n\n```\n\nThen when you call `configure_nozzle_layout` later in your protocol, you can set `style=protocol_api.COLUMN`.\n\nFor greater convenience, also import the individual layout constants that you plan to use in your protocol:\n\n```\nfrom opentrons.protocol_api import COLUMN, ALL\n\n```\n\nThen when you call `configure_nozzle_layout` later in your protocol, you can set `style=COLUMN`.\n\nHere is the start of a protocol that performs both imports, loads a 96\\-channel pipette, and sets it to pick up a single column of tips.\n\n```\nfrom opentrons import protocol_api\nfrom opentrons.protocol_api import COLUMN, ALL\n\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    column_rack = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_1000ul\",\n        location=\"D3\"\n    )\n    trash = protocol.load_trash_bin(\"A3\")\n    pipette = protocol.load_instrument(\"flex_96channel_1000\")\n    pipette.configure_nozzle_layout(\n        style=COLUMN,\n        start=\"A12\",\n        tip_racks=[column_rack]\n    )\n\n```\n\nNew in version 2\\.16\\.\n\nLet\u2019s unpack some of the details of this code.\n\nFirst, we\u2019ve given a special name to the tip rack, `column_rack`. You can name your tip racks whatever you like, but if you\u2019re performing full pickup and partial pickup in the same protocol, you\u2019ll need to keep them separate. See Tip Rack Adapters below.\n\nNext, we load the 96\\-channel pipette. Note that `load_instrument()` only has a single argument. The 96\\-channel pipette occupies both mounts, so `mount` is omissible. The `tip_racks` argument is always optional. But it would have no effect to declare it here, because every call to `configure_nozzle_layout()` resets the pipette\u2019s `InstrumentContext.tip_racks` property.\n\nFinally, we configure the nozzle layout, with three arguments.\n\n> - The `style` parameter directly accepts the `COLUMN` constant, since we imported it at the top of the protocol.\n> - The `start` parameter accepts a nozzle name, representing the back\\-left nozzle in the layout, as a string. `\"A12\"` tells the pipette to use its rightmost column of nozzles for pipetting.\n> - The `tip_racks` parameter tells the pipette which racks to use for tip tracking, just like adding tip racks when loading a pipette.\n\nIn this configuration, pipetting actions will use a single column:\n\n```\n# configured in COLUMN mode\npipette.pick_up_tip()  # picks up A1-H1 from tip rack\npipette.drop_tip()\npipette.pick_up_tip()  # picks up A2-H2 from tip rack\n\n```\n\nWarning\n\n`InstrumentContext.pick_up_tip()` always accepts a `location` argument, regardless of nozzle configuration. Do not pass a value that would lead the pipette to line up over more unused tips than specified by the current layout. For example, setting `COLUMN` layout and then calling `pipette.pick_up_tip(tip_rack[\"A2\"])` on a full tip rack will lead to unexpected pipetting behavior and potential crashes.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 3334, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f58d65a3-c321-4cc5-93aa-8755f30356a3": {"__data__": {"id_": "f58d65a3-c321-4cc5-93aa-8755f30356a3", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ee18039d-52dc-45e9-a0b4-ead228bdff51", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "b037204ffdb00c2830745475180b9c9221640a9047fa5b632291c8168bb363d4", "class_name": "RelatedNodeInfo"}}, "text": "Tip Rack Adapters\n\nYou can use both partial and full tip pickup in the same protocol. This requires having some tip racks directly on the deck, and some tip racks in the tip rack adapter.\n\nDo not use a tip rack adapter when performing partial tip pickup. Instead, place the tip rack on the deck. During partial tip pickup, the 96\\-channel pipette lowers onto the tip rack in a horizontally offset position. If the tip rack were in its adapter, the pipette would collide with the adapter\u2019s posts, which protrude above the top of the tip rack. If you configure the pipette for partial pickup and then call `pick_up_tip()` on a tip rack that\u2019s loaded onto an adapter, the API will raise an error.\n\nOn the other hand, you must use the tip rack adapter for full tip pickup. If the 96\\-channel pipette is in a full layout, either by default or by configuring `style=ALL`, and you then call `pick_up_tip()` on a tip rack that\u2019s not in an adapter, the API will raise an error.\n\nWhen switching between full and partial pickup, you may want to organize your tip racks into lists, depending on whether they\u2019re loaded on adapters or not.\n\n```\ntips_1 = protocol.load_labware(\n    \"opentrons_flex_96_tiprack_1000ul\", \"C1\"\n)\ntips_2 = protocol.load_labware(\n    \"opentrons_flex_96_tiprack_1000ul\", \"D1\"\n)\ntips_3 = protocol.load_labware(\n    \"opentrons_flex_96_tiprack_1000ul\", \"C3\",\n    adapter=\"opentrons_flex_96_tiprack_adapter\"\n)\ntips_4 = protocol.load_labware(\n    \"opentrons_flex_96_tiprack_1000ul\", \"D3\",\n    adapter=\"opentrons_flex_96_tiprack_adapter\"\n)\n\npartial_tip_racks = [tips_1, tips_2]\nfull_tip_racks = [tips_3, tips_4]\n\n```\n\nTip\n\nIt\u2019s also good practice to keep separate lists of tip racks when using multiple partial tip pickup configurations (i.e., using both column 1 and column 12 in the same protocol). This improves positional accuracy when picking up tips. Additionally, use Labware Position Check in the Opentrons App to ensure that the partial configuration is well\\-aligned to the rack.\n\nNow, when you configure the nozzle layout, you can reference the appropriate list as the value of `tip_racks`:\n\n```\npipette.configure_nozzle_layout(\n    style=COLUMN,\n    start=\"A12\",\n    tip_racks=partial_tip_racks\n)\n# partial pipetting commands go here\n\npipette.configure_nozzle_layout(\n    style=ALL,\n    tip_racks=full_tip_racks\n)\npipette.pick_up_tip()  # picks up full rack in C1\n\n```\n\nThis keeps tip tracking consistent across each type of pickup. And it reduces the risk of errors due to the incorrect presence or absence of a tip rack adapter.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2549, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a368c95a-3a65-4ab4-83cc-6fdcbe6aa03a": {"__data__": {"id_": "a368c95a-3a65-4ab4-83cc-6fdcbe6aa03a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "70c76525-7e7d-4049-b5d8-3f63a012f784", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "0aee4937a8779a497ff0097a8bc28896cf1385823c1f22275b849fb720dc601e", "class_name": "RelatedNodeInfo"}}, "text": "Tip Pickup and Conflicts\n\nDuring partial tip pickup, 96\\-channel pipette moves into spaces above adjacent slots. To avoid crashes, the API prevents you from performing partial tip pickup when there is tall labware in these spaces. The current nozzle layout determines which labware can safely occupy adjacent slots.\n\nThe API will raise errors for potential labware crashes when using a column nozzle configuration. Nevertheless, it\u2019s a good idea to do the following when working with partial tip pickup:\n\n> - Plan your deck layout carefully. Make a diagram and visualize everywhere the pipette will travel.\n> - Simulate your protocol and compare the run preview to your expectations of where the pipette will travel.\n> - Perform a dry run with only tip racks on the deck. Have the Emergency Stop Pendant handy in case you see an impending crash.\n\nFor column pickup, Opentrons recommends using the nozzles in column 12 of the pipette:\n\n```\npipette.configure_nozzle_layout(\n    style=COLUMN,\n    start=\"A12\",\n)\n\n```\n\nWhen using column 12, the pipette overhangs space to the left of wherever it is picking up tips or pipetting. For this reason, it\u2019s a good idea to organize tip racks front to back on the deck. If you place them side by side, the rack to the right will be inaccessible. For example, let\u2019s load three tip racks in the front left corner of the deck:\n\n```\ntips_C1 = protocol.load_labware(\"opentrons_flex_96_tiprack_1000ul\", \"C1\")\ntips_D1 = protocol.load_labware(\"opentrons_flex_96_tiprack_1000ul\", \"D1\")\ntips_D2 = protocol.load_labware(\"opentrons_flex_96_tiprack_1000ul\", \"D2\")\n\n```\n\nNow the pipette will be able to access the racks in column 1 only. `pick_up_tip(tips_D2[\"A1\"])` will raise an error due to the tip rack immediately to its left, in slot D1\\. There a couple of ways to avoid this error:\n\n> - Load the tip rack in a different slot, with no tall labware to its left.\n> - Use all the tips in slot D1 first, and then use `move_labware()` to make space for the pipette before picking up tips from D2\\.\n\nYou would get a similar error trying to aspirate from or dispense into a well plate in slot D3, since there is a tip rack to the left.\n\nTip\n\nWhen using column 12 for partial tip pickup and pipetting, generally organize your deck with the shortest labware on the left side of the deck, and the tallest labware on the right side.\n\nIf your application can\u2019t accommodate a deck layout that works well with column 12, you can configure the 96\\-channel pipette to pick up tips with column 1:\n\n```\npipette.configure_nozzle_layout(\n    style=COLUMN,\n    start=\"A1\",\n)\n\n```\n\nNote\n\nWhen using a column 1 layout, the pipette can\u2019t reach the rightmost portion of labware in slots A3\u2013D3\\. Any well that is within 29 mm of the right edge of the slot may be inaccessible. Use a column 12 layout if you need to pipette in that area.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2842, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7ee064be-b859-467d-81ec-33fdfc3b1016": {"__data__": {"id_": "7ee064be-b859-467d-81ec-33fdfc3b1016", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "85fcb5e9-b1d9-4123-82e6-2817dc6ffc41", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "d6a13fab23f0ad49831231fc94e60089f2f9140ae2a1fb7d7da22fedfeb9aaab", "class_name": "RelatedNodeInfo"}}, "text": "Volume Modes\n\nThe Flex 1\\-Channel 50 \u00b5L and Flex 8\\-Channel 50 \u00b5L pipettes must operate in a low\\-volume mode to accurately dispense very small volumes of liquid. Set the volume mode by calling `InstrumentContext.configure_for_volume()` with the amount of liquid you plan to aspirate, in \u00b5L:\n\n```\npipette50.configure_for_volume(1)\npipette50.pick_up_tip()\npipette50.aspirate(1, plate[\"A1\"])\n\n```\n\nNew in version 2\\.15\\.\n\nPassing different values to `configure_for_volume()` changes the minimum and maximum volume of Flex 50 \u00b5L pipettes as follows:\n\n| Value  | Minimum Volume (\u00b5L) | Maximum Volume (\u00b5L) |\n| ------ | ------------------- | ------------------- |\n| 1\u20134\\.9 | 1                   | 30                  |\n| 5\u201350   | 5                   | 50                  |\n\nNote\n\nThe pipette must not contain liquid when you call `configure_for_volume()`, or the API will raise an error.\n\nAlso, if the pipette is in a well location that may contain liquid, it will move upward to ensure it is not immersed in liquid before changing its mode. Calling `configure_for_volume()` _before_ `pick_up_tip()` helps to avoid this situation.\n\nIn a protocol that handles many different volumes, it\u2019s a good practice to call `configure_for_volume()` once for each `transfer()` or `aspirate()`, specifying the volume that you are about to handle. When operating with a list of volumes, nest `configure_for_volume()` inside a `for` loop to ensure that the pipette is properly configured for each volume:\n\n```\nvolumes = [1, 2, 3, 4, 1, 5, 2, 8]\nsources = plate.columns()[0]\ndestinations = plate.columns()[1]\nfor i in range(8):\n    pipette50.configure_for_volume(volumes[i])\n    pipette50.pick_up_tip()\n    pipette50.aspirate(volume=volumes[i], location=sources[i])\n    pipette50.dispense(location=destinations[i])\n    pipette50.drop_tip()\n\n```\n\nIf you know that all your liquid handling will take place in a specific mode, then you can call `configure_for_volume()` just once with a representative volume. Or if all the volumes correspond to the pipette\u2019s default mode, you don\u2019t have to call `configure_for_volume()` at all.\n\nOpentrons pipettes are configurable devices used to move liquids throughout the working area during the execution of protocols. Flex and OT\\-2 each have their own pipettes, which are available for use in the Python API.\n\nPages in this section of the documentation cover:\n\n> - Loading pipettes into your protocol.\n> - Pipette characteristics, such as how fast they can move liquid and how they move around the deck.\n> - The partial tip pickup configuration for the Flex 96\\-Channel Pipette, which uses only 8 channels for pipetting. Full and partial tip pickup can be combined in a single protocol.\n> - The volume modes of Flex 50 \u00b5L pipettes, which must operate in low\\-volume mode to accurately dispense very small volumes of liquid.\n\nFor information about liquid handling, see Building Block Commands and Complex Commands.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2932, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8ae7c165-538d-433e-accb-f72376223d00": {"__data__": {"id_": "8ae7c165-538d-433e-accb-f72376223d00", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ad85347d-56b3-4b9e-b525-1c68bb3af2b4", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "61dc0c0ed8801d6a9de329779fa1bafd57a22fc02a82b35c28eb8d5c14f482dc", "class_name": "RelatedNodeInfo"}}, "text": "Building Block Commands", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 25, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "35dbef31-7560-4bb0-ab3f-c4d089df63a1": {"__data__": {"id_": "35dbef31-7560-4bb0-ab3f-c4d089df63a1", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "056228b5-64c0-406c-a793-4a764ea7c966", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ce235cb9c8f1c54b82a495b0d79891e3953505d52d511421e0bd0c9210aec161", "class_name": "RelatedNodeInfo"}}, "text": "Manipulating Pipette Tips\n\nYour robot needs to attach a disposable tip to the pipette before it can aspirate or dispense liquids. The API provides three basic functions that help the robot attach and manage pipette tips during a protocol run. These methods are `InstrumentContext.pick_up_tip()`, `InstrumentContext.drop_tip()`, and `InstrumentContext.return_tip()`. Respectively, these methods tell the robot to pick up a tip from a tip rack, drop a tip into the trash (or another location), and return a tip to its location in the tip rack.\n\nThe following sections demonstrate how to use each method and include sample code. The examples used here assume that you\u2019ve loaded the pipettes and labware from the basic protocol template.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 735, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "274c2e90-294f-4632-9529-8d1bd8dc38f5": {"__data__": {"id_": "274c2e90-294f-4632-9529-8d1bd8dc38f5", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "433c2ddc-f2fc-4fe6-81bc-857d2c867fbb", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "66e2ff5409721882ba7ad558323fd246804e2f5e4c9890e1783ae280c10dd817", "class_name": "RelatedNodeInfo"}}, "text": "Picking Up a Tip\n\nTo pick up a tip, call the `pick_up_tip()` method without any arguments:\n\n```\npipette.pick_up_tip()\n\n```\n\nWhen added to the protocol template, this simple statement works because the API knows which tip rack is associated with `pipette`, as indicated by `tip_racks=tiprack_1]` in the [`load_instrument()` call. And it knows the on\\-deck location of the tip rack (slot D3 on Flex, slot 3 on OT\\-2\\) from the `location` argument of `load_labware()`. Given this information, the robot moves to the tip rack and picks up a tip from position A1 in the rack. On subsequent calls to `pick_up_tip()`, the robot will use the next available tip. For example:\n\n```\npipette.pick_up_tip()  # picks up tip from rack location A1\npipette.drop_tip()     # drops tip in trash bin\npipette.pick_up_tip()  # picks up tip from rack location B1\npipette.drop_tip()     # drops tip in trash bin\n\n```\n\nIf you omit the `tip_rack` argument from the `pipette` variable, the API will raise an error. In that case, you must pass the tip rack\u2019s location to `pick_up_tip` like this:\n\n```\npipette.pick_up_tip(tiprack_1[\"A1\"])\npipette.drop_tip()\npipette.pick_up_tip(tiprack_1[\"B1\"])\n\n```\n\nIn most cases, it\u2019s best to associate tip racks with a pipette and let the API automatically track pickup location for you. This also makes it easy to pick up tips when iterating over a loop, as shown in the next section.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1418, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a7cd0404-ee8f-413a-9f2e-9fd9a855cd2b": {"__data__": {"id_": "a7cd0404-ee8f-413a-9f2e-9fd9a855cd2b", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "93449ef4-22f0-4dd2-b16c-4eff22225a23", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "957ee4c39ae3932546e139ef3d574a3db06d6a5f26e1f2cc4b29d82c8b846313", "class_name": "RelatedNodeInfo"}}, "text": "Automating Tip Pick Up\n\nWhen used with Python\u2019s `range`') class, a `for` loop brings automation to the tip pickup and tracking process. It also eliminates the need to call `pick_up_tip()` multiple times. For example, this snippet tells the robot to sequentially use all the tips in a 96\\-tip rack:\n\n```\nfor i in range(96):\n    pipette.pick_up_tip()\n    # liquid handling commands\n    pipette.drop_tip()\n\n```\n\nIf your protocol requires a lot of tips, add a second tip rack to the protocol. Then, associate it with your pipette and increase the number of repetitions in the loop. The robot will work through both racks.\n\nFirst, add another tip rack to the sample protocol:\n\n```\ntiprack_2 = protocol.load_labware(\n    load_name=\"opentrons_flex_96_tiprack_1000ul\",\n    location=\"C3\"\n)\n\n```\n\nNext, change the pipette\u2019s `tip_rack` property to include the additional rack:\n\n```\npipette = protocol.load_instrument(\n    instrument_name=\"flex_1channel_1000\",\n    mount=\"left\",\n    tip_racks=[tiprack_1, tiprack_2],\n)\n\n```\n\nFinally, iterate over a larger range:\n\n```\nfor i in range(192):\n    pipette.pick_up_tip()\n    # liquid handling commands\n    pipette.drop_tip()\n\n```\n\nFor a more advanced \u201creal\\-world\u201d example, review the off\\-deck location protocol on the Moving Labware page. This example also uses a `for` loop to iterate through a tip rack, but it includes other commands that pause the protocol and let you replace an on\\-deck tip rack with another rack stored in an off\\-deck location.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1488, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1c4e4b47-60d0-4d35-9030-d35f408ecd8a": {"__data__": {"id_": "1c4e4b47-60d0-4d35-9030-d35f408ecd8a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "39e04556-8133-46da-82af-b94eaaf9246c", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "165cc071eb5fc261bdb161651f413971109c69bab5e566546697a995fe233d6a", "class_name": "RelatedNodeInfo"}}, "text": "Dropping a Tip\n\nTo drop a tip in the pipette\u2019s trash container, call the `drop_tip()` method with no arguments:\n\n```\npipette.pick_up_tip()\n\n```\n\nYou can specify where to drop the tip by passing in a location. For example, this code drops a tip in the trash bin and returns another tip to to a previously used well in a tip rack:\n\n```\npipette.pick_up_tip()            # picks up tip from rack location A1\npipette.drop_tip()               # drops tip in default trash container\npipette.pick_up_tip()            # picks up tip from rack location B1\npipette.drop_tip(tiprack[\"A1\"])  # drops tip in rack location A1\n\n```\n\nNew in version 2\\.0\\.\n\nAnother use of the `location` parameter is to drop a tip in a specific trash container. For example, calling `pipette.drop_tip(chute)` will dispose tips in the waste chute, even if the pipette\u2019s default trash container is a trash bin:\n\n```\npipette.pick_up_tip()    # picks up tip from rack location A1\npipette.drop_tip()       # drops tip in default trash container\npipette.pick_up_tip()    # picks up tip from rack location B1\npipette.drop_tip(chute)  # drops tip in waste chute\n\n```\n\nNew in version 2\\.16\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1150, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bb15903b-c9ed-411a-abd0-37decf346589": {"__data__": {"id_": "bb15903b-c9ed-411a-abd0-37decf346589", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "62b84c1a-fc21-4f5a-9a62-3c2112825822", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "9e30ae8a45d3dd0fb1a2e2077cdd7856b3b44fbdbcc6837c9c682e033ea07139", "class_name": "RelatedNodeInfo"}}, "text": "Returning a Tip\n\nTo return a tip to its original location, call the `return_tip()` method with no arguments:\n\n```\npipette.return_tip()\n\n```\n\nNew in version 2\\.0\\.\n\nNote\n\nYou can\u2019t return tips with a pipette that\u2019s configured to use partial tip pickup. This restriction ensures that the pipette has clear access to unused tips. For example, a 96\\-channel pipette in column configuration can\u2019t reach column 2 unless column 1 is empty.\n\nIf you call `return_tip()` while using partial tip pickup, the API will raise an error. Use `drop_tip()` to dispose the tips instead.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 569, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9f318eb7-ae4a-4c0b-bf22-060331433447": {"__data__": {"id_": "9f318eb7-ae4a-4c0b-bf22-060331433447", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "71f82895-2605-4b82-95f3-b5868d02c89a", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "bc04c684a9499dd8ec706bcddd24488db5f27c92f302bbc584e1bc6016b7bc97", "class_name": "RelatedNodeInfo"}}, "text": "Working With Used Tips\n\nCurrently, the API considers tips as \u201cused\u201d after being picked up. For example, if the robot picked up a tip from rack location A1 and then returned it to the same location, it will not attempt to pick up this tip again, unless explicitly specified. Instead, the robot will pick up a tip starting from rack location B1\\. For example:\n\n```\npipette.pick_up_tip()                # picks up tip from rack location A1\npipette.return_tip()                 # drops tip in rack location A1\npipette.pick_up_tip()                # picks up tip from rack location B1\npipette.drop_tip()                   # drops tip in trash bin\npipette.pick_up_tip(tiprack_1[\"A1\"]) # picks up tip from rack location A1\n\n```\n\nEarly API versions treated returned tips as unused items. They could be picked up again without an explicit argument. For example:\n\n```\npipette.pick_up_tip()  # picks up tip from rack location A1\npipette.return_tip()   # drops tip in rack location A1\npipette.pick_up_tip()  # picks up tip from rack location A1\n\n```\n\nChanged in version 2\\.2\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1066, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "36d84cd6-4742-4b94-b645-8ca424991552": {"__data__": {"id_": "36d84cd6-4742-4b94-b645-8ca424991552", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9d95ad51-9696-49da-a394-e7c7ba6a42cd", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "72bf29dba3918cc203795b76b875c2157dac97ee6362b0628792fd32f57ef721", "class_name": "RelatedNodeInfo"}}, "text": "Liquid Control\n\nAfter attaching a tip, your robot is ready to aspirate, dispense, and perform other liquid handling tasks. The API includes methods that help you perform these actions and the following sections show how to use them. The examples used here assume that you\u2019ve loaded the pipettes and labware from the basic protocol template.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 342, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "08668273-877f-4994-85a5-08c17e6dd48e": {"__data__": {"id_": "08668273-877f-4994-85a5-08c17e6dd48e", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6ef4f03a-25c7-42ed-832e-f02835e75036", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "a8c502b2b9080c8b6bf55fd17efc65d2bc9c5c27fca0b9d2d7a9bfaa5c8c2acd", "class_name": "RelatedNodeInfo"}}, "text": "Aspirate\n\nTo draw liquid up into a pipette tip, call the `InstrumentContext.aspirate()` method. Using this method, you can specify the aspiration volume in \u00b5L, the well location, and pipette flow rate. Other parameters let you position the pipette within a well. For example, this snippet tells the robot to aspirate 200 \u00b5L from well location A1\\.\n\n```\npipette.pick_up_tip()\npipette.aspirate(200, plate[\"A1\"])\n\n```\n\nIf the pipette doesn\u2019t move, you can specify an additional aspiration action without including a location. To demonstrate, this code snippet pauses the protocol, automatically resumes it, and aspirates a second time from `plate[\"A1\"]`).\n\n```\npipette.pick_up_tip()\npipette.aspirate(200, plate[\"A1\"])\nprotocol.delay(seconds=5) # pause for 5 seconds\npipette.aspirate(100)     # aspirate 100 \u00b5L at current position\n\n```\n\nNow our pipette holds 300 \u00b5L.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 864, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7e80d414-ee7e-4470-97b7-d57a69c98c1a": {"__data__": {"id_": "7e80d414-ee7e-4470-97b7-d57a69c98c1a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8a74fd72-a112-47ff-b2b4-c9b2234f04e2", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "bc3d345b2fc0f8fc120d24bdc73c9d2932edadecec8a4b314a26c41eeb59a017", "class_name": "RelatedNodeInfo"}}, "text": "Aspirate by Well or Location\n\nThe `aspirate()` method includes a `location` parameter that accepts either a `Well` or a `Location`.\n\nIf you specify a well, like `plate\"A1\"]`, the pipette will aspirate from a default position 1 mm above the bottom center of that well. To change the default clearance, first set the `aspirate` attribute of [`well_bottom_clearance`:\n\n```\npipette.pick_up_tip\npipette.well_bottom_clearance.aspirate = 2  # tip is 2 mm above well bottom\npipette.aspirate(200, plate[\"A1\"])\n\n```\n\nYou can also aspirate from a location along the center vertical axis within a well using the `Well.top()` and `Well.bottom()` methods. These methods move the pipette to a specified distance relative to the top or bottom center of a well:\n\n```\npipette.pick_up_tip()\ndepth = plate[\"A1\"].bottom(z=2) # tip is 2 mm above well bottom\npipette.aspirate(200, depth)\n\n```\n\nSee also:\n\n- Default Positions for information about controlling pipette height for a particular pipette.\n- Position Relative to Labware for information about controlling pipette height from within a well.\n- Move To for information about moving a pipette to any reachable deck location.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1159, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fa263542-a122-4cef-bd74-22d3f1420fd0": {"__data__": {"id_": "fa263542-a122-4cef-bd74-22d3f1420fd0", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2f04de43-4fc8-4069-8263-547ae79352ce", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "806ea853ce43c7137bf890959278ea26c4fdf7aac9291c14fc9ca8344f666f3c", "class_name": "RelatedNodeInfo"}}, "text": "Aspiration Flow Rates\n\nFlex and OT\\-2 pipettes aspirate at default flow rates measured in \u00b5L/s. Specifying the `rate` parameter multiplies the flow rate by that value. As a best practice, don\u2019t set the flow rate higher than 3x the default. For example, this code causes the pipette to aspirate at twice its normal rate:\n\n```\npipette.aspirate(200, plate[\"A1\"], rate=2.0)\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 399, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "20908338-4015-4269-832f-e3e1dcf71509": {"__data__": {"id_": "20908338-4015-4269-832f-e3e1dcf71509", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c0559dd5-4c70-4267-8023-0d08aad51e56", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "a99d5b765b3b9901bbe4d175de0441ba344b6bf0850b18949280326ff30c2e8d", "class_name": "RelatedNodeInfo"}}, "text": "Dispense\n\nTo dispense liquid from a pipette tip, call the `InstrumentContext.dispense()` method. Using this method, you can specify the dispense volume in \u00b5L, the well location, and pipette flow rate. Other parameters let you position the pipette within a well. For example, this snippet tells the robot to dispense 200 \u00b5L into well location B1\\.\n\n```\npipette.dispense(200, plate[\"B1\"])\n\n```\n\nNote\n\nIn API version 2\\.16 and earlier, you could pass a `volume` argument to `dispense()` greater than what was aspirated into the pipette. In this case, the API would ignore `volume` and dispense the pipette\u2019s `current_volume`. The robot _would not_ move the plunger lower as a result.\n\nIn version 2\\.17 and later, passing such values raises an error.\n\nTo move the plunger a small extra amount, add a push out. Or to move it a large amount, use blow out.\n\nIf the pipette doesn\u2019t move, you can specify an additional dispense action without including a location. To demonstrate, this code snippet pauses the protocol, automatically resumes it, and dispense a second time from location B1\\.\n\n```\npipette.dispense(100, plate[\"B1\"])\nprotocol.delay(seconds=5) # pause for 5 seconds\npipette.dispense(100)     # dispense 100 \u00b5L at current position\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1241, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "943bae3c-558e-443b-b22b-86c12dbe2d23": {"__data__": {"id_": "943bae3c-558e-443b-b22b-86c12dbe2d23", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2c076cb7-fcef-430c-8641-30f6ed41c927", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "d5f6c6fadb52c83b1520ab271d60f27705994a698915d5d727fd016c0c7274f7", "class_name": "RelatedNodeInfo"}}, "text": "Dispense by Well or Location\n\nThe `dispense()` method includes a `location` parameter that accepts either a `Well` or a `Location`.\n\nIf you specify a well, like `plate\"B1\"]`, the pipette will dispense from a default position 1 mm above the bottom center of that well. To change the default clearance, you would call [`well_bottom_clearance`:\n\n```\npipette.well_bottom_clearance.dispense=2 # tip is 2 mm above well bottom\npipette.dispense(200, plate[\"B1\"])\n\n```\n\nYou can also dispense from a location along the center vertical axis within a well using the `Well.top()` and `Well.bottom()` methods. These methods move the pipette to a specified distance relative to the top or bottom center of a well:\n\n```\ndepth = plate[\"B1\"].bottom(z=2) # tip is 2 mm above well bottom\npipette.dispense(200, depth)\n\n```\n\nSee also:\n\n- Default Positions for information about controlling pipette height for a particular pipette.\n- Position Relative to Labware for formation about controlling pipette height from within a well.\n- Move To for information about moving a pipette to any reachable deck location.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1089, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "25b03630-eb7c-4900-93a9-4cc07507cb3a": {"__data__": {"id_": "25b03630-eb7c-4900-93a9-4cc07507cb3a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "fa6bc619-a56b-43fd-865c-6472c19bc6ba", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ec8d1dcedfe4c200deb1920bd0b003a41b8503dd3a45b765d0e371fa0e278f7e", "class_name": "RelatedNodeInfo"}}, "text": "Dispense Flow Rates\n\nFlex and OT\\-2 pipettes dispense at default flow rates measured in \u00b5L/s. Adding a number to the `rate` parameter multiplies the flow rate by that value. As a best practice, don\u2019t set the flow rate higher than 3x the default. For example, this code causes the pipette to dispense at twice its normal rate:\n\n```\npipette.dispense(200, plate[\"B1\"], rate=2.0)\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 405, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2cdc37cd-553d-49d6-b41b-8b244d45b0f0": {"__data__": {"id_": "2cdc37cd-553d-49d6-b41b-8b244d45b0f0", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b1f77d73-ca31-4d05-886d-1ac6a8d9b504", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "e9fe8bdd4367444bc482a2c8b38dee9799a080ad1b0e8d46518b4535e2612498", "class_name": "RelatedNodeInfo"}}, "text": "Push Out After Dispense\n\nThe optional `push_out` parameter of `dispense()` helps ensure all liquid leaves the tip. Use `push_out` for applications that require moving the pipette plunger lower than the default, without performing a full blow out.\n\nFor example, this dispense action moves the plunger the equivalent of an additional 5 \u00b5L beyond where it would stop if `push_out` was set to zero or omitted:\n\n```\npipette.pick_up_tip()\npipette.aspirate(100, plate[\"A1\"])\npipette.dispense(100, plate[\"B1\"], push_out=5)\npipette.drop_tip()\n\n```\n\nNew in version 2\\.15\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 564, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4761f7e5-b053-4411-b9e2-7ba8378c77d7": {"__data__": {"id_": "4761f7e5-b053-4411-b9e2-7ba8378c77d7", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b970750f-1675-40ba-b19d-4d2f957a5c50", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "75b253cf2f17851e713cb8afdfb3489b97b3d8a6f30400a435bd21d71318f465", "class_name": "RelatedNodeInfo"}}, "text": "Blow Out\n\nTo blow an extra amount of air through the pipette\u2019s tip, call the `InstrumentContext.blow_out()` method. You can use a specific well in a well plate or reservoir as the blowout location. If no location is specified, the pipette will blowout from its current well position:\n\n```\npipette.blow_out()\n\n```\n\nYou can also specify a particular well as the blowout location:\n\n```\npipette.blow_out(plate[\"B1\"])\n\n```\n\nMany protocols use a trash container for blowing out the pipette. You can specify the pipette\u2019s current trash container as the blowout location by using the `InstrumentContext.trash_container` property:\n\n```\npipette.blow_out(pipette.trash_container)\n\n```\n\nNew in version 2\\.0\\.\n\nChanged in version 2\\.16: Added support for `TrashBin` and `WasteChute` locations.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 782, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "447ce0d5-b648-48c4-9ced-6122888a42c3": {"__data__": {"id_": "447ce0d5-b648-48c4-9ced-6122888a42c3", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8e44d0f1-9c4b-411a-8fbe-5bc482d4d881", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "f85092971ebb30748320a0d9b3b9186bee34856f20f68766df21306a52dadd13", "class_name": "RelatedNodeInfo"}}, "text": "Touch Tip\n\nThe `InstrumentContext.touch_tip()` method moves the pipette so the tip touches each wall of a well. A touch tip procedure helps knock off any droplets that might cling to the pipette\u2019s tip. This method includes optional arguments that allow you to control where the tip will touch the inner walls of a well and the touch speed. Calling `touch_tip()` without arguments causes the pipette to touch the well walls from its current location:\n\n```\npipette.touch_tip()\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 481, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6edaf77a-8894-4be9-9942-1a1015d8b7f3": {"__data__": {"id_": "6edaf77a-8894-4be9-9942-1a1015d8b7f3", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "02190c46-16c5-40a9-a186-d5a23f7b61da", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "c1f5e8541a14b349ee12553e09f121903132dfa8165a540d51a5ea1865fbfe5a", "class_name": "RelatedNodeInfo"}}, "text": "Touch Location\n\nThese optional location arguments give you control over where the tip will touch the side of a well.\n\nThis example demonstrates touching the tip in a specific well:\n\n```\npipette.touch_tip(plate[\"B1\"])\n\n```\n\nThis example uses an offset to set the touch tip location 2mm below the top of the current well:\n\n```\npipette.touch_tip(v_offset=-2)\n\n```\n\nThis example moves the pipette 75% of well\u2019s total radius and 2 mm below the top of well:\n\n```\npipette.touch_tip(plate[\"B1\"],\n                  radius=0.75,\n                  v_offset=-2)\n\n```\n\nThe `touch_tip` feature allows the pipette to touch the edges of a well gently instead of crashing into them. It includes the `radius` argument. When `radius=1` the robot moves the centerline of the pipette\u2019s plunger axis to the edge of a well. This means a pipette tip may sometimes touch the well wall too early, causing it to bend inwards. A smaller radius helps avoid premature wall collisions and a lower speed produces gentler motion. Different liquid droplets behave differently, so test out these parameters in a single well before performing a full protocol run.\n\nWarning\n\n_Do not_ set the `radius` value greater than `1.0`. When `radius` is \\> `1.0`, the robot will forcibly move the pipette tip across a well wall or edge. This type of aggressive movement can damage the pipette tip and the pipette.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1368, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6e0158cf-eced-4e52-8cf0-6241543215cc": {"__data__": {"id_": "6e0158cf-eced-4e52-8cf0-6241543215cc", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "98dce572-7468-41d5-addb-f2a32905a70a", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "13a8d45142f3266c2a410d74402a8286be1a3fb40350553efc763e5c997f9bfd", "class_name": "RelatedNodeInfo"}}, "text": "Touch Speed\n\nTouch speed controls how fast the pipette moves in mm/s during a touch tip step. The default movement speed is 60 mm/s, the minimum is 1 mm/s, and the maximum is 80 mm/s. Calling `touch_tip` without any arguments moves a tip at the default speed in the current well:\n\n```\npipette.touch_tip()\n\n```\n\nThis example specifies a well location and sets the speed to 20 mm/s:\n\n```\npipette.touch_tip(plate[\"B1\"], speed=20)\n\n```\n\nThis example uses the current well and sets the speed to 80 mm/s:\n\n```\npipette.touch_tip(speed=80)\n\n```\n\nNew in version 2\\.0\\.\n\nChanged in version 2\\.4: Lowered minimum speed to 1 mm/s.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 620, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f788c73e-fc82-41f7-a154-785bc298ed01": {"__data__": {"id_": "f788c73e-fc82-41f7-a154-785bc298ed01", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b8cbd1c3-2bf7-4f46-ad77-ca7a8303e3be", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "442ba27a47bb69f6c2fc850a3e35ffdacee9e89e703e39fa5636951291f16ae6", "class_name": "RelatedNodeInfo"}}, "text": "Mix\n\nThe `mix()` method aspirates and dispenses repeatedly in a single location. It\u2019s designed to mix the contents of a well together using a single command rather than using multiple `aspirate()` and `dispense()` calls. This method includes arguments that let you specify the number of times to mix, the volume (in \u00b5L) of liquid, and the well that contains the liquid you want to mix.\n\nThis example draws 100 \u00b5L from the current well and mixes it three times:\n\n```\npipette.mix(repetitions=3, volume=100)\n\n```\n\nThis example draws 100 \u00b5L from well B1 and mixes it three times:\n\n```\npipette.mix(3, 100, plate[\"B1\"])\n\n```\n\nThis example draws an amount equal to the pipette\u2019s maximum rated volume and mixes it three times:\n\n```\npipette.mix(repetitions=3)\n\n```\n\nNote\n\nIn API versions 2\\.2 and earlier, during a mix, the pipette moves up and out of the target well. In API versions 2\\.3 and later, the pipette does not move while mixing.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 956, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a02eecf2-3ca5-4f3c-a71d-b33c01f5ce9e": {"__data__": {"id_": "a02eecf2-3ca5-4f3c-a71d-b33c01f5ce9e", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "81341fc4-5c06-4e33-a5b8-7c2e955c5caf", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "bbedf81fccf34d015ce11f9ff05a3d5795de6e02cb413a8d4fb81871fe5a81de", "class_name": "RelatedNodeInfo"}}, "text": "Air Gap\n\nThe `InstrumentContext.air_gap()` method tells the pipette to draw in air before or after a liquid. Creating an air gap helps keep liquids from seeping out of a pipette after drawing it from a well. This method includes arguments that give you control over the amount of air to aspirate and the pipette\u2019s height (in mm) above the well. By default, the pipette moves 5 mm above a well before aspirating air. Calling `air_gap()` with no arguments uses the entire remaining volume in the pipette.\n\nThis example aspirates 200 \u00b5L of air 5 mm above the current well:\n\n```\npipette.air_gap(volume=200)\n\n```\n\nThis example aspirates 200 \u00b5L of air 20 mm above the the current well:\n\n```\npipette.air_gap(volume=200, height=20)\n\n```\n\nThis example aspirates enough air to fill the remaining volume in a pipette:\n\n```\npipette.air_gap()\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 859, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bfe37647-1bd7-4ac1-b6da-c1ef5086a9bc": {"__data__": {"id_": "bfe37647-1bd7-4ac1-b6da-c1ef5086a9bc", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3cc395af-f75c-4492-a756-c967a6b6284b", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "b358064d33dacaee3359a8d8ff547a905780107af3ac6be9819662807ebcf7d2", "class_name": "RelatedNodeInfo"}}, "text": "Utility Commands\n\nWith utility commands, you can control various robot functions such as pausing or delaying a protocol, checking the robot\u2019s door, turning robot lights on/off, and more. The following sections show you how to these utility commands and include sample code. The examples used here assume that you\u2019ve loaded the pipettes and labware from the basic protocol template.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 383, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9391479d-6527-4890-8bab-ecffb1ce806b": {"__data__": {"id_": "9391479d-6527-4890-8bab-ecffb1ce806b", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b84ad7be-dc5a-42d0-9a66-24f4f26179fb", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "cbfd64ac05f83b4adb27d89510e52fb3dbfa06c6a91971fa7f9c3ac52fc80af6", "class_name": "RelatedNodeInfo"}}, "text": "Delay and Resume\n\nCall the `ProtocolContext.delay()` method to insert a timed delay into your protocol. This method accepts time increments in seconds, minutes, or combinations of both. Your protocol resumes automatically after the specified time expires.\n\nThis example delays a protocol for 10 seconds:\n\n```\nprotocol.delay(seconds=10)\n\n```\n\nThis example delays a protocol for 5 minutes:\n\n```\nprotocol.delay(minutes=5)\n\n```\n\nThis example delays a protocol for 5 minutes and 10 seconds:\n\n```\nprotocol.delay(minutes=5, seconds=10)\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 535, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "987c20df-db1d-448f-9db4-24ea8d0f5d77": {"__data__": {"id_": "987c20df-db1d-448f-9db4-24ea8d0f5d77", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c9c4d5ce-90db-4058-a256-709bfd81e7fa", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "8091ed68ab3fecc636c683f45f6075af90543f95626f7ccbfba5a8723f4e9ef3", "class_name": "RelatedNodeInfo"}}, "text": "Pause Until Resumed\n\nCall the `ProtocolContext.pause()` method to stop a protocol at a specific step. Unlike a delay, `pause()` does not restart your protocol automatically. To resume, you\u2019ll respond to a prompt on the touchscreen or in the Opentrons App. This method also lets you specify an optional message that provides on\\-screen or in\\-app instructions on how to proceed. This example inserts a pause and includes a brief message:\n\n```\nprotocol.pause(\"Remember to get more pipette tips\")\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 523, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "958e505b-c16c-4776-bd32-24d1724a1fb2": {"__data__": {"id_": "958e505b-c16c-4776-bd32-24d1724a1fb2", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4a354c2f-6277-44de-98c5-e384b3ae276a", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "97e01198a6e81350d1c6155a52cdf99af068ed8185a3f69225c51bddb7db783a", "class_name": "RelatedNodeInfo"}}, "text": "Homing\n\nHoming commands the robot to move the gantry, a pipette, or a pipette plunger to a defined position. For example, homing the gantry moves it to the back right of the working area. With the available homing methods you can home the gantry, home the mounted pipette and plunger, and home the pipette plunger. These functions take no arguments.\n\nTo home the gantry, call `ProtocolContext.home()`:\n\n```\nprotocol.home()\n\n```\n\nTo home a specific pipette\u2019s Z axis and plunger, call `InstrumentContext.home()`:\n\n```\npipette = protocol.load_instrument(\"flex_1channel_1000\", \"right\")\npipette.home()\n\n```\n\nTo home a specific pipette\u2019s plunger only, you can call `InstrumentContext.home_plunger()`:\n\n```\npipette = protocol.load_instrument(\"flex_1channel_1000\", \"right\")\npipette.home_plunger()\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 818, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e94b0750-5dfb-482f-82d7-9f1b5715c82c": {"__data__": {"id_": "e94b0750-5dfb-482f-82d7-9f1b5715c82c", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "786e4627-7138-4261-abf2-d6e78d2eb035", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "8a61ada08593b531afc1b55244a0f680ed5e04c1f988e89257613a50116bdac4", "class_name": "RelatedNodeInfo"}}, "text": "Comment\n\nCall the `ProtocolContext.comment()` method if you want to write and display a brief message in the Opentrons App during a protocol run:\n\n```\nprotocol.comment(\"Hello, world!\")\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 214, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "89e965f1-da2d-4990-8fe5-c8cbbb6af07e": {"__data__": {"id_": "89e965f1-da2d-4990-8fe5-c8cbbb6af07e", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "65b12f50-b533-45c2-bca4-b35ff946d9a6", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "21bd7ec4adc9ae0df8a567791e28ccae150691f934c6e66a5084299bd3170917", "class_name": "RelatedNodeInfo"}}, "text": "Control and Monitor Robot Rail Lights\n\nCall the `ProtocolContext.set_rail_lights()` method to turn the robot\u2019s rail lights on or off during a protocol. This method accepts Boolean `True` (lights on) or `False` (lights off) arguments. Rail lights are off by default.\n\nThis example turns the rail lights on:\n\n```\nprotocol.set_rail_lights(True)\n\n```\n\nThis example turns the rail lights off:\n\n```\nprotocol.set_rail_lights(False)\n\n```\n\nNew in version 2\\.5\\.\n\nYou can also check whether the rail lights are on or off in the protocol by using `ProtocolContext.rail_lights_on`. This method returns `True` when lights are on and `False` when the lights are off.\n\nNew in version 2\\.5\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 677, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "760edde3-6283-4fe1-bf3f-de2b24d32a08": {"__data__": {"id_": "760edde3-6283-4fe1-bf3f-de2b24d32a08", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "44935100-ebd2-4717-a006-836d1d4588a5", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "97229f1e4f1953588ff5d095dc1b891f72336cee138fdb0a318985da6264a3da", "class_name": "RelatedNodeInfo"}}, "text": "OT\\-2 Door Safety Switch\n\nIntroduced with robot software version 3\\.19, the safety switch feature prevents the OT\\-2, and your protocol, from running if the door is open. To operate properly, the front door and top window of your OT\\-2 must be closed. You can toggle the door safety switch on or off from **Robot Settings \\> Advanced \\> Usage Settings**.\n\nTo check if the robot\u2019s door is closed at a specific point during a protocol run, call `ProtocolContext.door_closed`. It returns a Boolean `True` (door closed) or `False` (door open) response.\n\n```\nprotocol.door_closed\n\n```\n\nWarning\n\n`door_closed` is a status check only. It does not control the robot\u2019s behavior. If you wish to implement a custom method to pause or resume a protocol using `door_closed`, disable the door safety feature first (not recommended).\n\nNew in version 2\\.5\\.\n\nBuilding block commands execute some of the most basic actions that your robot can complete. But basic doesn\u2019t mean these commands lack capabilities. They perform important tasks in your protocols. They\u2019re also foundational to the complex commands that help you combine multiple actions into fewer lines of code.\n\nPages in this section of the documentation cover:\n\n- Manipulating Pipette Tips: Get started with commands for picking up pipette tips, dropping tips, returning tips, and working with used tips.\n- Liquid Control: Learn about aspirating and dispensing liquids, blow out and touch tip procedures, mixing, and creating air gaps.\n- Utility Commands: Control various robot functions such as pausing or delaying a protocol, checking the robot\u2019s door, turning robot lights on/off, and more.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1641, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4d32fa53-2eda-4b24-8864-169bed3f4d4d": {"__data__": {"id_": "4d32fa53-2eda-4b24-8864-169bed3f4d4d", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d0918ce4-809f-4013-a000-a014386408d3", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "0486fff6a7fa650f0786ffd39d091616f2d601a2db0f07f4b65620716cfba58a", "class_name": "RelatedNodeInfo"}}, "text": "Complex Commands", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 18, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9f1d5414-b59d-45b5-a11f-d0aaa4c9cb05": {"__data__": {"id_": "9f1d5414-b59d-45b5-a11f-d0aaa4c9cb05", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a76f9c33-a3e3-4d08-8f60-36cdc658e598", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "a240431dc1d69e68db901474f230ef27d0315ec494d24387dae2a2bef82fc97f", "class_name": "RelatedNodeInfo"}}, "text": "Sources and Destinations\n\nThe `InstrumentContext.transfer()`, `InstrumentContext.distribute()`, and `InstrumentContext.consolidate()` methods form the family of complex liquid handling commands. These methods require `source` and `dest` (destination) arguments to move liquid from one well, or group of wells, to another. In contrast, the building block commands `aspirate()` and `dispense()` only operate in a single location.\n\nFor example, this command performs a simple transfer between two wells on a plate:\n\n```\npipette.transfer(\n    volume=100,\n    source=plate[\"A1\"],\n    dest=plate[\"A2\"],\n)\n\n```\n\nNew in version 2\\.0\\.\n\nThis page covers the restrictions on sources and destinations for complex commands, their different patterns of aspirating and dispensing, and how to optimize them for different use cases.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 818, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1e57889f-94f4-4957-8032-01b263707951": {"__data__": {"id_": "1e57889f-94f4-4957-8032-01b263707951", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b2470960-5eca-4cc8-97e1-50f28c3bed68", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "4712b1eccba9e053fb7a36337aabe3d7f608fd19c6a688197d5f8a38269449ae", "class_name": "RelatedNodeInfo"}}, "text": "Source and Destination Arguments\n\nAs noted above, the `transfer()`, `distribute()`, and `consolidate()` methods require `source` and `dest` (destination) arguments to aspirate and dispense liquid. However, each method handles liquid sources and destinations differently. Understanding how complex commands work with source and destination wells is essential to using these methods effectively.\n\n`transfer()` is the most versatile complex liquid handling function, because it has the fewest restrictions on what wells it can operate on. You will likely use transfer commands in many of your protocols.\n\nCertain liquid handling cases focus on moving liquid to or from a single well. `distribute()` limits its source to a single well, while `consolidate()` limits its destination to a single well. Distribute commands also make changes to liquid\\-handling behavior to improve the accuracy of dispensing.\n\nThe following table summarizes the source and destination restrictions for each method.\n\n| Method          | Accepted wells                                                                                                                                         |\n| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `transfer()`    | _ **Source:** Any number of wells. _ **Destination:** Any number of wells. \\* The larger group of wells must be evenly divisible by the smaller group. |\n| `distribute()`  | _ **Source:** Exactly one well. _ **Destination:** Any number of wells.                                                                                |\n| `consolidate()` | _ **Source:** Any number of wells. _ **Destination:** Exactly one well.                                                                                |\n\nA single well can be passed by itself or as a list with one item: `source=plate[\"A1\"]` and `source=[plate[\"A1\"]]` are equivalent.\n\nThe section on many\\-to\\-many transfers below covers how `transfer()` works when specifying sources and destinations of different sizes. However, if they don\u2019t meet the even divisibility requirement, the API will raise an error. You can work around such situations by making multiple calls to `transfer()` in sequence or by using a list of volumes to skip certain wells.\n\nFor distributing and consolidating, the API will not raise an error if you use a list of wells as the argument that is limited to exactly one well. Instead, the API will ignore everything except the first well in the list. For example, the following command will only aspirate from well A1:\n\n```\npipette.distribute(\n    volume=100,\n    source=[plate[\"A1\"], plate[\"A2\"]],  # A2 ignored\n    dest=plate.columns()[1],\n)\n\n```\n\nOn the other hand, a transfer command with the same arguments would aspirate from both A1 and A2\\. The next section examines the exact order of aspiration and dispensing for all three methods.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2976, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8d2a4862-6f0f-417f-8629-86b8221847de": {"__data__": {"id_": "8d2a4862-6f0f-417f-8629-86b8221847de", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3c378130-152a-4b34-b40c-2c5f5ff5fcfb", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "8efa656e947dcee1e9d95b632e6c0590aa3ba6bb879c6f6a104a939537ebaada", "class_name": "RelatedNodeInfo"}}, "text": "Transfer Patterns\n\nEach complex command uses a different pattern of aspiration and dispensing. In addition, when you provide multiple wells as both the source and destination for `transfer()`, it maps the source list onto the destination list in a certain way.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 262, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a365e57e-2d37-490a-82f3-304ec91656c2": {"__data__": {"id_": "a365e57e-2d37-490a-82f3-304ec91656c2", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d4c1d5b3-4e70-47a6-8200-e01c1da468cc", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "c1a43b92709df650ea2f1c965060d93d4cbf4a783f3638c73ce08123e8007cbe", "class_name": "RelatedNodeInfo"}}, "text": "Aspirating and Dispensing\n\n`transfer()` always alternates between aspirating and dispensing, regardless of how many wells are in the source and destination. Its default behavior is:\n\n> 1. Pick up a tip.\n> 2. Aspirate from the first source well.\n> 3. Dispense in the first destination well.\n> 4. Repeat the pattern of aspirating and dispensing, as needed.\n> 5. Drop the tip in the trash.\n\nThis transfer aspirates six times and dispenses six times.\n\n`distribute()` always fills the tip with as few aspirations as possible, and then dispenses to the destination wells in order. Its default behavior is:\n\n> 1. Pick up a tip.\n> 2. Aspirate enough to dispense in all the destination wells. This aspirate includes a disposal volume.\n> 3. Dispense in the first destination well.\n> 4. Continue to dispense in destination wells.\n> 5. Drop the tip in the trash.\n\nSee Tip Refilling below for cases where the total amount to be dispensed is greater than the capacity of the tip.\n\nThis distribute aspirates one time and dispenses three times.\n\n`consolidate()` aspirates multiple times in a row, and then dispenses as few times as possible in the destination well. Its default behavior is:\n\n> 1. Pick up a tip.\n> 2. Aspirate from the first source well.\n> 3. Continue aspirating from source wells.\n> 4. Dispense in the destination well.\n> 5. Drop the tip in the trash.\n\nSee Tip Refilling below for cases where the total amount to be aspirated is greater than the capacity of the tip.\n\nThis consolidate aspirates three times and dispenses one time.\n\nNote\n\nBy default, all three commands begin by picking up a tip and conclude by dropping a tip. In general, don\u2019t call `pick_up_tip()` just before a complex command, or the API will raise an error. You can override this behavior with the tip handling complex parameter, by setting `new_tip=\"never\"`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1833, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "19bae759-6c89-4b62-b3b9-b7906d2e5f26": {"__data__": {"id_": "19bae759-6c89-4b62-b3b9-b7906d2e5f26", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7502d682-0968-41fa-b55d-5819eacd8d62", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "f9abc2b23629740c093c1dd66b3a0872ece7e194400fe2a85a5f383e828668a8", "class_name": "RelatedNodeInfo"}, "3": {"node_id": "e0570867-358c-441c-9040-508c6c446a13", "node_type": "1", "metadata": {}, "hash": "54837e5549dc16a6a45b7fcfc3f5985ca6774fa0f4495bffc6810da7bb6499a2", "class_name": "RelatedNodeInfo"}}, "text": "Many\\-to\\-Many\n\n`transfer()` lets you specify both `source` and `dest` arguments that contain multiple wells. This section covers how the method determines which wells to aspirate from and dispense to in these cases.\n\nWhen the source and destination both contain the same number of wells, the mapping between wells is straightforward. You can imagine writing out the two lists one above each other, with each unique well in the source list paired to a unique well in the destination list. For example, here is the code for using one row as the source and another row as the destination, and the resulting correspondence between wells:\n\n```\npipette.transfer(\n    volume=50,\n    source=plate.rows()[0],\n    dest=plate.rows()[1],\n)\n\n```\n\n| Source      | A1  | A2  | A3  | A4  | A5  | A6  | A7  | A8  | A9  | A10 | A11 | A12 |\n| ----------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Destination | B1  | B2  | B3  | B4  | B5  | B6  | B7  | B8  | B9  | B10 | B11 | B12 |\n\nThere\u2019s no requirement that the source and destination lists be mutually exclusive. In fact, this command adapted from the tutorial deliberately uses slices of the same list, saved to the variable `row`, with the effect that each aspiration happens in the same location as the previous dispense:\n\n```\nrow = plate.rows()[0]\npipette.transfer(\n    volume=50,\n    source=row[:11],\n    dest=row[1:],\n)\n\n```\n\n| Source      | A1  | A2  | A3  | A4  | A5  | A6  | A7  | A8  | A9  | A10 | A11 |\n| ----------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Destination | A2  | A3  | A4  | A5  | A6  | A7  | A8  | A9  | A10 | A11 | A12 |\n\nWhen the source and destination lists contain different numbers of wells, `transfer()` will always aspirate and dispense as many times as there are wells in the _longer_ list. The shorter list will be \u201cstretched\u201d to cover the length of the longer list. Here is an example of transferring from 3 wells to a full row of 12 wells:\n\n```\npipette.transfer(\n    volume=50,\n    source=[plate[\"A1\"], plate[\"A2\"], plate[\"A3\"]],\n    dest=plate.rows()[1],\n)\n\n```\n\n| Source      | A1  | A1  | A1  | A1  | A2  | A2  | A2  | A2  | A3  | A3  | A3  | A3  |\n| ----------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| Destination | B1  | B2  | B3  | B4  | B5  | B6  | B7  | B8  | B9  | B10 | B11 | B12 |\n\nThis is why the longer list must be evenly divisible by the shorter list. Changing the destination in this example to a column instead of a row will cause the API to raise an error, because 8 is not evenly divisible by 3:\n\n```\npipette.transfer(\n    volume=50,\n    source=[plate[\"A1\"], plate[\"A2\"], plate[\"A3\"]],\n    dest=plate.columns()[3],  # labware column 4\n)\n# error: source and destination lists must be divisible\n\n```\n\nThe API raises this error rather than presuming which wells to aspirate from three times and which only two times. If you want to aspirate three times from A1, three times from A2, and two times from A3, use multiple `transfer()` commands in sequence:\n\n```\npipette.transfer(50, plate[\"A1\"], plate.columns()[3][:3])\npipette.transfer(50, plate[\"A2\"], plate.columns()[3][3:6])\npipette.transfer(50, plate[\"A3\"], plate.columns()[3][6:])\n\n```\n\nFinally, be aware of the ordering of source and destination lists when constructing them with well accessor methods.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 3348, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e0570867-358c-441c-9040-508c6c446a13": {"__data__": {"id_": "e0570867-358c-441c-9040-508c6c446a13", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7502d682-0968-41fa-b55d-5819eacd8d62", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "f9abc2b23629740c093c1dd66b3a0872ece7e194400fe2a85a5f383e828668a8", "class_name": "RelatedNodeInfo"}, "2": {"node_id": "19bae759-6c89-4b62-b3b9-b7906d2e5f26", "node_type": "1", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "31e606f642d54b815c33415193f9645ddb0eb908c9d1571036cecdcf03f1680b", "class_name": "RelatedNodeInfo"}}, "text": "If you want to aspirate three times from A1, three times from A2, and two times from A3, use multiple `transfer()` commands in sequence:\n\n```\npipette.transfer(50, plate[\"A1\"], plate.columns()[3][:3])\npipette.transfer(50, plate[\"A2\"], plate.columns()[3][3:6])\npipette.transfer(50, plate[\"A3\"], plate.columns()[3][6:])\n\n```\n\nFinally, be aware of the ordering of source and destination lists when constructing them with well accessor methods. For example, at first glance this code may appear to take liquid from each well in the first row of a plate and move it to each of the other wells in the same column:\n\n```\npipette.transfer(\n    volume=20,\n    source=plate.rows()[0],\n    dest=plate.rows()[1:],\n)\n\n```\n\nHowever, because the well ordering of `Labware.rows()` goes _across_ the plate instead of _down_ the plate, liquid from A1 will be dispensed in B1\u2013B7, liquid from A2 will be dispensed in B8\u2013C2, etc. The intended task is probably better accomplished by repeating transfers in a `for` loop:\n\n```\nfor i in range(12):\n    pipette.transfer(\n        volume=20,\n        source=plate.rows()[0][i],\n        dest=plate.columns()[i][1:],\n    )\n\n```\n\nHere the repeat index `i` picks out:\n\n> - The individual well in the first row, for the source.\n> - The corresponding column, which is sliced to form the destination.", "mimetype": "text/plain", "start_char_idx": 2909, "end_char_idx": 4222, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "06201254-cb72-4eb1-8b64-97e0868f3d04": {"__data__": {"id_": "06201254-cb72-4eb1-8b64-97e0868f3d04", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "054a4d03-49f9-488e-a175-d02a58d43684", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "0d08225769ac76a13d84a371f390d1ec1d6b5f23848ec9ff806441101a607ee0", "class_name": "RelatedNodeInfo"}}, "text": "Optimizing Patterns\n\nChoosing the right complex command optimizes gantry movement and helps save time in your protocol. For example, say you want to take liquid from a reservoir and put 50 \u00b5L in each well of the first row of a plate. You could use `transfer()`, like this:\n\n```\npipette.transfer(\n    volume=50,\n    source=reservoir[\"A1\"],\n    destination=plate.rows()[0],\n)\n\n```\n\nThis will produce 12 aspirate steps and 12 dispense steps. The steps alternate, with the pipette moving back and forth between the reservoir and plate each time. Using `distribute()` with the same arguments is more optimal in this scenario:\n\n```\npipette.distribute(\n    volume=50,\n    source=reservoir[\"A1\"],\n    destination=plate.rows()[0],\n)\n\n```\n\nThis will produce _just 1_ aspirate step and 12 dispense steps (when using a 1000 \u00b5L pipette). The pipette will aspirate enough liquid to fill all the wells, plus a disposal volume. Then it will move to A1 of the plate, dispense, move the short distance to A2, dispense, and so on. This greatly reduces gantry movement and the time to perform this action. And even if you\u2019re using a smaller pipette, `distribute()` will fill the pipette, dispense as many times as possible, and only then return to the reservoir to refill (see Tip Refilling for more information).", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1295, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d8ac4e0e-87b5-4865-a5c3-5892761f4a62": {"__data__": {"id_": "d8ac4e0e-87b5-4865-a5c3-5892761f4a62", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "19b4116c-3dcd-4ac5-b3cc-1698f683978c", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "5ec942d98249f5124ef76fc1706815d7be5cf7bcc46dd30ce5ef27f9fb37eb64", "class_name": "RelatedNodeInfo"}}, "text": "Order of Operations\n\nComplex commands perform a series of building block commands in order. In fact, the run preview for your protocol in the Opentrons App lists all of these commands as separate steps. This lets you examine what effect your complex commands will have before running them.\n\nThis page describes what steps you should expect the robot to perform when using different complex commands with different required and optional parameters.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 449, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fe1b8578-c937-469c-9795-a670e7574baa": {"__data__": {"id_": "fe1b8578-c937-469c-9795-a670e7574baa", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "22e1b81d-b8ab-445f-a1dc-cdb48180e8d0", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "d8839fde88c1688aa3a481e02bd3e47f1b07330a48fd8930687fddc24b3e3e98", "class_name": "RelatedNodeInfo"}}, "text": "Step Sequence\n\nThe order of steps is fixed within complex commands. Aspiration and dispensing are the only required actions. You can enable or disable all of the other actions with complex liquid handling parameters. A complex command designed to perform every possible action will proceed in this order:\n\n> 1. Pick up tip\n> 2. Mix at source\n> 3. Aspirate from source\n> 4. Touch tip at source\n> 5. Air gap\n> 6. Dispense into destination\n> 7. Mix at destination\n> 8. Touch tip at destination\n> 9. Blow out\n> 10. Drop tip\n\nThe command may repeat some or all of these steps in order to move liquid as requested. `transfer()` repeats as many times as there are wells in the longer of its `source` or `dest` argument. `distribute()` and `consolidate()` try to repeat as few times as possible. See Tip Refilling below for how they behave when they do need to repeat.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 862, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "209a9f86-d422-4a7e-b0d3-3eca082315d0": {"__data__": {"id_": "209a9f86-d422-4a7e-b0d3-3eca082315d0", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c3a5fde2-555a-4d11-8ebc-a55b5a25bf74", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "4660814a84c95b61aaf30ca60679452fe9a51c9639b03c90ecfb67823c1c347c", "class_name": "RelatedNodeInfo"}}, "text": "Example Orders\n\nThe smallest possible number of steps in a complex command is just two: aspirating and dispensing. This is possible by omitting the tip pickup and drop steps:\n\n```\npipette.transfer(\n    volume=100,\n    source=plate[\"A1\"],\n    dest=plate[\"B1\"],\n    new_tip=\"never\",\n)\n\n```\n\nHere\u2019s another example, a distribute command that adds touch tip steps (and does not turn off tip handling). The code for this command is:\n\n```\npipette.distribute(\n    volume=100,\n    source=[plate[\"A1\"]],\n    dest=[plate[\"B1\"], plate[\"B2\"]],\n    touch_tip=True,\n)\n\n```\n\nCompared to the list of all possible actions, this code will only perform the following:\n\n> 1. Pick up tip\n> 2. Aspirate from source\n> 3. Touch tip at source\n> 4. Dispense into destination\n> 5. Touch tip at destination\n> 6. Blow out\n> 7. Drop tip\n\nLet\u2019s unpack this. Picking up and dropping tips is default behavior for `distribute()`. Specifying `touch_tip=True` adds two steps, as it is performed at both the source and destination. And it\u2019s also default behavior for `distribute()` to aspirate a disposal volume, which is blown out before dropping the tip. The exact order of steps in the run preview should look similar to this:\n\n```\nPicking up tip from A1 of tip rack on 3\nAspirating 220.0 uL from A1 of well plate on 2 at 92.86 uL/sec\nTouching tip\nDispensing 100.0 uL into B1 of well plate on 2 at 92.86 uL/sec\nTouching tip\nDispensing 100.0 uL into B2 of well plate on 2 at 92.86 uL/sec\nTouching tip\nBlowing out at A1 of Opentrons Fixed Trash on 12\nDropping tip into A1 of Opentrons Fixed Trash on 12\n\n```\n\nSince dispensing and touching the tip are both associated with the destination wells, those steps are performed at each of the two destination wells.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1724, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "99082fad-0df8-4057-bf02-a7769a2cc2b5": {"__data__": {"id_": "99082fad-0df8-4057-bf02-a7769a2cc2b5", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1313a23b-3cfe-46aa-a8c0-b25a18daf5d4", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "1083b8dcc8a85022447ea8993662c87a911160427b4e542844eecdee79f40a9e", "class_name": "RelatedNodeInfo"}}, "text": "Tip Refilling\n\nOne factor that affects the exact order of steps for a complex command is whether the amount of liquid being moved can fit in the tip at once. If it won\u2019t fit, you don\u2019t have to adjust your command. The API will handle it for you by including additional steps to refill the tip when needed.\n\nFor example, say you need to move 100 \u00b5L of liquid from one well to another, but you only have a 50 \u00b5L pipette attached to your robot. To accomplish this with building block commands, you\u2019d need multiple aspirates and dispenses. `aspirate(volume=100)` would raise an error, since it exceeds the tip\u2019s volume. But you can accomplish this with a single transfer command:\n\n```\npipette50.transfer(\n    volume=100,\n    source=plate[\"A1\"],\n    dest=plate[\"B1\"],\n)\n\n```\n\nTo effect the transfer, the API will aspirate and dispense the maximum volume of the pipette (50 \u00b5L) twice:\n\n```\nPicking up tip from A1 of tip rack on D3\nAspirating 50.0 uL from A1 of well plate on D2 at 57 uL/sec\nDispensing 50.0 uL into B1 of well plate on D2 at 57 uL/sec\nAspirating 50.0 uL from A1 of well plate on D2 at 57 uL/sec\nDispensing 50.0 uL into B1 of well plate on D2 at 57 uL/sec\nDropping tip into A1 of Opentrons Fixed Trash on A3\n\n```\n\nYou can change `volume` to any value (above the minimum volume of the pipette) and the API will automatically calculate how many times the pipette needs to aspirate and dispense. `volume=50` would require just one repetition. `volume=75` would require two, split into 50 \u00b5L and 25 \u00b5L. `volume=1000` would repeat 20 times \u2014 not very efficient, but perhaps more useful than having to swap to a different pipette!\n\nRemember that `distribute()` includes a disposal volume by default, and this can affect the number of times the pipette refills its tip. Say you want to distribute 80 \u00b5L to each of the 12 wells in row A of a plate. That\u2019s 960 \u00b5L total \u2014 less than the capacity of the pipette \u2014 but the 100 \u00b5L disposal volume will cause the pipette to refill.\n\n```\nPicking up tip from A1 of tip rack on 3\nAspirating 980.0 uL from A1 of well plate on 2 at 274.7 uL/sec\nDispensing 80.0 uL into B1 of well plate on 2 at 274.7 uL/sec\nDispensing 80.0 uL into B2 of well plate on 2 at 274.7 uL/sec\n...\nDispensing 80.0 uL into B11 of well plate on 2 at 274.7 uL/sec\nBlowing out at A1 of Opentrons Fixed Trash on 12\nAspirating 180.0 uL from A1 of well plate on 2 at 274.7 uL/sec\nDispensing 80.0 uL into B12 of well plate on 2 at 274.7 uL/sec\nBlowing out at A1 of Opentrons Fixed Trash on 12\nDropping tip into A1 of Opentrons Fixed Trash on 12\n\n```\n\nThis command will blow out 200 total \u00b5L of liquid in the trash. If you need to conserve liquid, use complex liquid handling parameters to reduce or eliminate the disposal volume, or to blow out in a location other than the trash.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2789, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a5dc03a3-2f1d-42ad-8166-55156a8edb8a": {"__data__": {"id_": "a5dc03a3-2f1d-42ad-8166-55156a8edb8a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0602591e-396f-465a-9c22-d5c36a90d6cc", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "6663f5882057b7c96b3ae869405096318ede3240b60ec9396bc133cef7d8ac18", "class_name": "RelatedNodeInfo"}}, "text": "List of Volumes\n\nComplex commands can aspirate or dispense different amounts for different wells, rather than the same amount across all wells. To do this, set the `volume` parameter to a list of volumes instead of a single number. The list must be the same length as the longer of `source` or `dest`, or the API will raise an error. For example, this command transfers a different amount of liquid into each of wells B1, B2, and B3:\n\n```\npipette.transfer(\n    volume=[20, 40, 60],\n    source=plate[\"A1\"],\n    dest=[plate[\"B1\"], plate[\"B2\"], plate[\"B3\"]],\n)\n\n```\n\nSetting any item in the list to `0` will skip aspirating and dispensing for the corresponding well. This example takes the command from above and skips B2:\n\n```\npipette.transfer(\n    volume=[20, 0, 60],\n    source=plate[\"A1\"],\n    dest=[plate[\"B1\"], plate[\"B2\"], plate[\"B3\"]],\n)\n\n```\n\nThe pipette dispenses in B1 and B3, and does not move to B2 at all.\n\n```\nPicking up tip from A1 of tip rack on 3\nAspirating 20.0 uL from A1 of well plate on 2 at 274.7 uL/sec\nDispensing 20.0 uL into B1 of well plate on 2 at 274.7 uL/sec\nAspirating 60.0 uL from A1 of well plate on 2 at 274.7 uL/sec\nDispensing 60.0 uL into B3 of well plate on 2 at 274.7 uL/sec\nDropping tip into A1 of Opentrons Fixed Trash on 12\n\n```\n\nThis is such a simple example that you might prefer to use two `transfer()` commands instead. Lists of volumes become more useful when they are longer than a couple elements. For example, you can specify `volume` as a list with 96 items and `dest=plate.wells()` to individually control amounts to dispense (and wells to skip) across an entire plate.\n\nNote\n\nWhen the optional `new_tip` parameter is set to `\"always\"`, the pipette will pick up and drop a tip even for skipped wells. If you don\u2019t want to waste tips, pre\\-process your list of sources or destinations and use the result as the argument of your complex command.\n\nNew in version 2\\.0: Skip wells for `transfer()` and `distribute()`.\n\nNew in version 2\\.8: Skip wells for `consolidate()`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2017, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a1cdd82d-9202-4797-a40b-8caaa7fc936d": {"__data__": {"id_": "a1cdd82d-9202-4797-a40b-8caaa7fc936d", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ebc0feff-aaf6-4ffc-ac64-2982fef76e83", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "f1b861db7863cce4b0705da13c34623e556a138cc85016e92a816bbcc4e9a718", "class_name": "RelatedNodeInfo"}}, "text": "Complex Liquid Handling Parameters\n\nComplex commands accept a number of optional parameters that give you greater control over the exact steps they perform.\n\nThis page describes the accepted values and behavior of each parameter. The parameters are organized in the order that they first add a step. Some parameters, such as `touch_tip`, add multiple steps. See Order of Operations for more details on the sequence of steps performed by complex commands.\n\nThe API reference entry for `InstrumentContext.transfer()` also lists the parameters and has more information on their implementation as keyword arguments.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 613, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1271b4fc-c0a0-4b0a-a77e-2c2244945e94": {"__data__": {"id_": "1271b4fc-c0a0-4b0a-a77e-2c2244945e94", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "31a4e240-38b8-456d-a455-3d5248c6e1a0", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "aaa95b549565b9deca03ee9a6d9ae125c022679bf802982cb7ba9e9b22099796", "class_name": "RelatedNodeInfo"}}, "text": "Tip Handling\n\nThe `new_tip` parameter controls if and when complex commands pick up new tips from the pipette\u2019s tip racks. It has three possible values:\n\n| Value      | Behavior                                                                                                                       |\n| ---------- | ------------------------------------------------------------------------------------------------------------------------------ |\n| `\"once\"`   | _ Pick up a tip at the start of the command. _ Use the tip for all liquid handling. \\* Drop the tip at the end of the command. |\n| `\"always\"` | Pick up and drop a tip for each set of aspirate and dispense steps.                                                            |\n| `\"never\"`  | Do not pick up or drop tips at all.                                                                                            |\n\n`\"once\"` is the default behavior for all complex commands.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 958, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b053faf0-1df3-474e-b3de-d99871c100e0": {"__data__": {"id_": "b053faf0-1df3-474e-b3de-d99871c100e0", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b7f5453b-2915-46a6-ae88-7942b1b94adf", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ff9bbb1cd7dfa70fb2e3748f6231aa644b2a326925208200c6e9ea7022b758d2", "class_name": "RelatedNodeInfo"}}, "text": "Tip Handling Requirements\n\n`\"once\"` and `\"always\"` require that the pipette has an associated tip rack, or the API will raise an error (because it doesn\u2019t know where to pick up a tip from). If the pipette already has a tip attached, the API will also raise an error when it tries to pick up a tip.\n\n```\npipette.pick_up_tip()\npipette.transfer(\n    volume=100,\n    source=plate[\"A1\"],\n    dest=[plate[\"B1\"], plate[\"B2\"], plate[\"B3\"]],\n    new_tip=\"never\",  # \"once\", \"always\", or None will error\n)\n\n```\n\nConversely, `\"never\"` requires that the pipette has picked up a tip, or the API will raise an error (because it will attempt to aspirate without a tip attached).", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 665, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7a173dbf-e717-4e76-905a-c068c7fc5405": {"__data__": {"id_": "7a173dbf-e717-4e76-905a-c068c7fc5405", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2e42ee72-4454-4064-a16a-2eba745e40d8", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "f76e1e192bc16142b1dc66de71e41cfdafe450642ab5a57338677ba29af37314", "class_name": "RelatedNodeInfo"}}, "text": "Avoiding Cross\\-Contamination\n\nOne reason to set `new_tip=\"always\"` is to avoid cross\\-contamination between wells. However, you should always do a dry run of your protocol to test that the pipette is picking up and dropping tips in the way that your application requires.\n\n`transfer()` will pick up a new tip before _every_ aspirate when `new_tip=\"always\"`. This includes when tip refilling requires multiple aspirations from a single source well.\n\n`distribute()` and `consolidate()` only pick up one tip, even when `new_tip=\"always\"`. For example, this distribute command returns to the source well a second time, because the amount to be distributed (400 \u00b5L total plus disposal volume) exceeds the pipette capacity (300 \u00b5L):\n\n```\npipette.distribute(\n    volume=200,\n    source=plate[\"A1\"],\n    dest=[plate[\"B1\"], plate[\"B2\"]],\n    new_tip=\"always\",\n)\n\n```\n\nBut it _does not_ pick up a new tip after dispensing into B1:\n\n```\nPicking up tip from A1 of tip rack on 3\nAspirating 220.0 uL from A1 of well plate on 2 at 92.86 uL/sec\nDispensing 200.0 uL into B1 of well plate on 2 at 92.86 uL/sec\nBlowing out at A1 of Opentrons Fixed Trash on 12\nAspirating 220.0 uL from A1 of well plate on 2 at 92.86 uL/sec\nDispensing 200.0 uL into B2 of well plate on 2 at 92.86 uL/sec\nBlowing out at A1 of Opentrons Fixed Trash on 12\nDropping tip into A1 of Opentrons Fixed Trash on 12\n\n```\n\nIf this poses a contamination risk, you can work around it in a few ways:\n\n> - Use `transfer()` with `new_tip=\"always\"` instead.\n> - Set `well_bottom_clearance` high enough that the tip doesn\u2019t contact liquid in the destination well.\n> - Use building block commands instead of complex commands.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1671, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "979c7dfb-e1e5-43b2-98a9-d2cba83f8b32": {"__data__": {"id_": "979c7dfb-e1e5-43b2-98a9-d2cba83f8b32", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cb272b09-7494-49ae-9d3d-1bd5094576ea", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ec10efcf81f370c7fb7c801142b0a7da9ad772f394948632d5353e25a54510b8", "class_name": "RelatedNodeInfo"}}, "text": "Mix Before\n\nThe `mix_before` parameter controls mixing in source wells before each aspiration. Its value must be a `tuple`') with two numeric values. The first value is the number of repetitions, and the second value is the amount of liquid to mix in \u00b5L.\n\nFor example, this transfer command will mix 50 \u00b5L of liquid 3 times before each of its aspirations:\n\n```\npipette.transfer(\n    volume=100,\n    source=plate[\"A1\"],\n    dest=[plate[\"B1\"], plate[\"B2\"]],\n    mix_before=(3, 50),\n)\n\n```\n\nNew in version 2\\.0\\.\n\nMixing occurs before every aspiration, including when tip refilling is required.\n\nNote\n\n`consolidate()` ignores any value of `mix_before`. Mixing on the second and subsequent aspirations of a consolidate command would defeat its purpose: to aspirate multiple times in a row, from different wells, _before_ dispensing.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 830, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dad2ce53-e8f4-4253-81e1-b73105b59874": {"__data__": {"id_": "dad2ce53-e8f4-4253-81e1-b73105b59874", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "74a1f56a-7bcb-4762-85ac-f6af487535ea", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "79330dd3518991feaf21ce37c67383bcc0fcddaa1da1830e380c4e88e6c7adbb", "class_name": "RelatedNodeInfo"}}, "text": "Disposal Volume\n\nThe `disposal_volume` parameter controls how much extra liquid is aspirated as part of a `distribute()` command. Including a disposal volume can improve the accuracy of each dispense. The pipette blows out the disposal volume of liquid after dispensing. To skip aspirating and blowing out extra liquid, set `disposal_volume=0`.\n\nBy default, `disposal_volume` is the minimum volume of the pipette, but you can set it to any amount:\n\n```\npipette.distribute(\n    volume=100,\n    source=plate[\"A1\"],\n    dest=[plate[\"B1\"], plate[\"B2\"]],\n    disposal_volume=10,  # reduce from default 20 \u00b5L to 10 \u00b5L\n)\n\n```\n\nNew in version 2\\.0\\.\n\nIf the amount to aspirate plus the disposal volume exceeds the tip\u2019s capacity, `distribute()` will use a tip refilling strategy. In such cases, the pipette will aspirate and blow out the disposal volume _for each aspiration_. For example, this command will require tip refilling with a 1000 \u00b5L pipette:\n\n```\npipette.distribute(\n    volume=120,\n    source=reservoir[\"A1\"],\n    dest=[plate.columns()[0]],\n    disposal_volume=50,\n)\n\n```\n\nThe amount to dispense in the destination is 960 \u00b5L (120 \u00b5L for each of 8 wells in the column). Adding the 50 \u00b5L disposal volume exceeds the 1000 \u00b5L capacity of the tip. The command will be split across two aspirations, each with the full disposal volume of 50 \u00b5L. The pipette will dispose _a total of 100 \u00b5L_ during the command.\n\nNote\n\n`transfer()` will not aspirate additional liquid if you set `disposal_volume`. However, it will perform a very small blow out after each dispense.\n\n`consolidate()` ignores `disposal_volume` completely.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1618, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b48d96b3-3329-4b95-9a4f-eb6c3e048f2d": {"__data__": {"id_": "b48d96b3-3329-4b95-9a4f-eb6c3e048f2d", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "de0fa9ea-7a5d-4b63-bbbe-1a31b5f1985a", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "bf4530913e79b7b9891399d65adab1fde6b523db5c19e890b88e45ba6b1a6cce", "class_name": "RelatedNodeInfo"}}, "text": "Touch Tip\n\nThe `touch_tip` parameter accepts a Boolean value. When `True`, a touch tip step occurs after every aspirate and dispense.\n\nFor example, this transfer command aspirates, touches the tip at the source, dispenses, and touches the tip at the destination:\n\n```\npipette.transfer(\n    volume=100,\n    dest=plate[\"A1\"],\n    source=plate[\"B1\"],\n    touch_tip=True,\n)\n\n```\n\nNew in version 2\\.0\\.\n\nTouch tip occurs after every aspiration, including when tip refilling is required.\n\nThis parameter always uses default motion behavior for touch tip. Use the touch tip building block command if you need to:\n\n> - Only touch the tip after aspirating or dispensing, but not both.\n> - Control the speed, radius, or height of the touch tip motion.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 743, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "971d2f6e-0ced-4f90-b8c4-34720d7fe693": {"__data__": {"id_": "971d2f6e-0ced-4f90-b8c4-34720d7fe693", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a21839e3-b820-439b-b5da-b5d43688d75d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "38be6536575ca35435fc4cf1a6a1a04037844b85c13f11c3d1fda1b394f286e2", "class_name": "RelatedNodeInfo"}}, "text": "Air Gap\n\nThe `air_gap` parameter controls how much air to aspirate and hold in the bottom of the tip when it contains liquid. The parameter\u2019s value is the amount of air to aspirate in \u00b5L.\n\nAir\\-gapping behavior is different for each complex command. The different behaviors all serve the same purpose, which is to never leave the pipette holding liquid at the very bottom of the tip. This helps keep liquids from seeping out of the pipette.\n\n| Method          | Air\\-gapping behavior                                                                                                   |\n| --------------- | ----------------------------------------------------------------------------------------------------------------------- |\n| `transfer()`    | _ Air gap after each aspiration. _ Pipette is empty after dispensing.                                                   |\n| `distribute()`  | _ Air gap after each aspiration. _ Air gap after dispensing if the pipette isn\u2019t empty.                                 |\n| `consolidate()` | _ Air gap after each aspiration. This may create multiple air gaps within the tip. _ Pipette is empty after dispensing. |\n\nFor example, this transfer command will create a 20 \u00b5L air gap after each of its aspirations. When dispensing, it will clear the air gap and dispense the full 100 \u00b5L of liquid:\n\n```\npipette.transfer(\n    volume=100,\n    source=plate[\"A1\"],\n    dest=plate[\"B1\"],\n    air_gap=20,\n)\n\n```\n\nNew in version 2\\.0\\.\n\nWhen consolidating, air gaps still occur after every aspiration. In this example, the tip will use 210 \u00b5L of its capacity (50 \u00b5L of liquid followed by 20 \u00b5L of air, repeated three times):\n\n```\npipette.consolidate(\n    volume=50,\n    source=[plate[\"A1\"], plate[\"A2\"], plate[\"A3\"]],\n    dest=plate[\"B1\"],\n    air_gap=20,\n)\n\n```\n\n```\nPicking up tip from A1 of tip rack on 3\nAspirating 50.0 uL from A1 of well plate on 2 at 92.86 uL/sec\nAir gap\n    Aspirating 20.0 uL from A1 of well plate on 2 at 92.86 uL/sec\nAspirating 50.0 uL from A2 of well plate on 2 at 92.86 uL/sec\nAir gap\n    Aspirating 20.0 uL from A2 of well plate on 2 at 92.86 uL/sec\nAspirating 50.0 uL from A3 of well plate on 2 at 92.86 uL/sec\nAir gap\n    Aspirating 20.0 uL from A3 of well plate on 2 at 92.86 uL/sec\nDispensing 210.0 uL into B1 of well plate on 2 at 92.86 uL/sec\nDropping tip into A1 of Opentrons Fixed Trash on 12\n\n```\n\nIf adding an air gap would exceed the pipette\u2019s maximum volume, the complex command will use a tip refilling strategy. For example, this command uses a 300 \u00b5L pipette to transfer 300 \u00b5L of liquid plus an air gap:\n\n```\npipette.transfer(\n    volume=300,\n    source=plate[\"A1\"],\n    dest=plate[\"B1\"],\n    air_gap=20,\n)\n\n```\n\nAs a result, the transfer is split into two aspirates of 150 \u00b5L, each with their own 20 \u00b5L air gap:\n\n```\nPicking up tip from A1 of tip rack on 3\nAspirating 150.0 uL from A1 of well plate on 2 at 92.86 uL/sec\nAir gap\n        Aspirating 20.0 uL from A1 of well plate on 2 at 92.86 uL/sec\nDispensing 170.0 uL into B1 of well plate on 2 at 92.86 uL/sec\nAspirating 150.0 uL from A1 of well plate on 2 at 92.86 uL/sec\nAir gap\n        Aspirating 20.0 uL from A1 of well plate on 2 at 92.86 uL/sec\nDispensing 170.0 uL into B1 of well plate on 2 at 92.86 uL/sec\nDropping tip into A1 of Opentrons Fixed Trash on 12\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 3295, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "555b90fe-9611-49b2-98cc-fda44a97ac67": {"__data__": {"id_": "555b90fe-9611-49b2-98cc-fda44a97ac67", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0ee51a65-8fcc-4525-9c0c-78d5067a5322", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "126012edb30cdc14fd82639cf3bf13366deaa827b51753453c548d799f7dfb0b", "class_name": "RelatedNodeInfo"}}, "text": "Mix After\n\nThe `mix_after` parameter controls mixing in source wells after each dispense. Its value must be a `tuple`') with two numeric values. The first value is the number of repetitions, and the second value is the amount of liquid to mix in \u00b5L.\n\nFor example, this transfer command will mix 50 \u00b5L of liquid 3 times after each of its dispenses:\n\n```\npipette.transfer(\n    volume=100,\n    source=plate[\"A1\"],\n    dest=[plate[\"B1\"], plate[\"B2\"]],\n    mix_after=(3, 50),\n)\n\n```\n\nNew in version 2\\.0\\.\n\nNote\n\n`distribute()` ignores any value of `mix_after`. Mixing after dispensing would combine (and potentially contaminate) the remaining source liquid with liquid present at the destination.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 694, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e6dd0714-06a1-468f-adfd-30da4147296a": {"__data__": {"id_": "e6dd0714-06a1-468f-adfd-30da4147296a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "125e959a-cb4b-4a7c-9b73-5f80b61a74ca", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "4130c618058b210e0166fe65d43673489c11cc16e0286c0bd628da83d3772b71", "class_name": "RelatedNodeInfo"}}, "text": "Blow Out\n\nThere are two parameters that control whether and where the pipette blows out liquid. The `blow_out` parameter accepts a Boolean value. When `True`, the pipette blows out remaining liquid when the tip is empty or only contains the disposal volume. The `blowout_location` parameter controls in which of three locations these blowout actions occur. The default blowout location is the trash. Blowout behavior is different for each complex command.\n\n| Method          | Blowout behavior and location                                                                       |\n| --------------- | --------------------------------------------------------------------------------------------------- |\n| `transfer()`    | _ Blow out after each dispense. _ Valid locations: `\"trash\"`, `\"source well\"`, `\"destination well\"` |\n| `distribute()`  | _ Blow out after the final dispense. _ Valid locations: `\"trash\"`, `\"source well\"`                  |\n| `consolidate()` | _ Blow out after the only dispense. _ Valid locations: `\"trash\"`, `\"destination well\"`              |\n\nFor example, this transfer command will blow out liquid in the trash twice, once after each dispense into a destination well:\n\n```\npipette.transfer(\n    volume=100,\n    source=[plate[\"A1\"], plate[\"A2\"]],\n    dest=[plate[\"B1\"], plate[\"B2\"]],\n    blow_out=True,\n)\n\n```\n\nNew in version 2\\.0\\.\n\nSet `blowout_location` when you don\u2019t want to waste any liquid by blowing it out into the trash. For example, you may want to make sure that every last bit of a sample is moved into a destination well. Or you may want to return every last bit of an expensive reagent to the source for use in later pipetting.\n\nIf you need to blow out in a different well, or at a specific location within a well, use the blow out building block command instead.\n\nWhen setting a blowout location, you _must_ also set `blow_out=True`, or the location will be ignored:\n\n```\npipette.transfer(\n    volume=100,\n    source=plate[\"A1\"],\n    dest=plate[\"B1\"],\n    blow_out=True,  # required to set location\n    blowout_location=\"destination well\",\n)\n\n```\n\nNew in version 2\\.8\\.\n\nWith `transfer()`, the pipette will not blow out at all if you only set `blowout_location`.\n\n`blow_out=True` is also required for distribute commands that blow out by virtue of having a disposal volume:\n\n```\npipette.distribute(\n    volume=100,\n    source=plate[\"A1\"],\n    dest=[plate[\"B1\"], plate[\"B2\"]],\n    disposal_volume=50,  # causes blow out\n    blow_out=True,       # still required to set location!\n    blowout_location=\"source well\",\n)\n\n```\n\nWith `distribute()`, the pipette will still blow out if you only set `blowout_location`, but in the default location of the trash.\n\nNote\n\nIf the tip already contains liquid before the complex command, the default blowout location will shift away from the trash. `transfer()` and `distribute()` shift to the source well, and `consolidate()` shifts to the destination well. For example, this transfer command will blow out in well B1 because it\u2019s the source:\n\n```\npipette.pick_up_tip()\npipette.aspirate(100, plate[\"A1\"])\npipette.transfer(\n    volume=100,\n    source=plate[\"B1\"],\n    dest=plate[\"C1\"],\n    new_tip=\"never\",\n    blow_out=True,\n    # no blowout_location\n)\npipette.drop_tip()\n\n```\n\nThis only occurs when you aspirate and then perform a complex command with `new_tip=\"never\"` and `blow_out=True`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 3370, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "87b0c517-7c71-400f-a839-1abbb6cc213a": {"__data__": {"id_": "87b0c517-7c71-400f-a839-1abbb6cc213a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2047cd2d-605a-40ce-8b89-ec793a70d05b", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "b7ff0d9dd8ff9d08c2a77ef46b880919e89a3603579465b651fb932033bb5a31", "class_name": "RelatedNodeInfo"}}, "text": "Trash Tips\n\nThe `trash` parameter controls what the pipette does with tips at the end of complex commands. When `True`, the pipette drops tips into the trash. When `False`, the pipette returns tips to their original locations in their tip rack.\n\nThe default is `True`, so you only have to set `trash` when you want the tip\\-returning behavior:\n\n```\npipette.transfer(\n    volume=100,\n    source=plate[\"A1\"],\n    dest=plate[\"B1\"],\n    trash=False,\n)\n\n```\n\nNew in version 2\\.0\\.\n\nComplex liquid handling commands combine multiple building block commands into a single method call. These commands make it easier to handle larger groups of wells and repeat actions without having to write your own control flow code. They integrate tip\\-handling behavior and can pick up, use, and drop multiple tips depending on how you want to handle your liquids. They can optionally perform other actions, like adding air gaps, knocking droplets off the tip, mixing, and blowing out excess liquid from the tip.\n\nThere are three complex liquid handling commands, each optimized for a different liquid handling scenario:\n\n> - `InstrumentContext.transfer()`\n> - `InstrumentContext.distribute()`\n> - `InstrumentContext.consolidate()`\n\nPages in this section of the documentation cover:\n\n> - Sources and Destinations: Which wells complex commands aspirate from and dispense to.\n> - Order of Operations: The order of basic commands that are part of a complex commmand.\n> - Complex Liquid Handling Parameters: Additional keyword arguments that affect complex command behavior.\n\nCode samples throughout these pages assume that you\u2019ve loaded the pipettes and labware from the basic protocol template.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1674, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "462ffaf5-b019-464f-a4e8-db5e5692995a": {"__data__": {"id_": "462ffaf5-b019-464f-a4e8-db5e5692995a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "54eb0dd2-0372-4480-8700-2b2ab5e05d29", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "389ac6a8ae1076818d871dddbd3aab5cbbfe1da17caa843f9c099a7315c967f6", "class_name": "RelatedNodeInfo"}}, "text": "Labware and Deck Positions\n\nThe API automatically determines how the robot needs to move when working with the instruments and labware in your protocol. But sometimes you need direct control over these activities. The API lets you do just that. Specifically, you can control movements relative to labware and deck locations. You can also manage the gantry\u2019s speed and trajectory as it traverses the working area. This document explains how to use API commands to take direct control of the robot and position it exactly where you need it.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 540, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "80cee061-8b84-4a7f-a486-268b776615b1": {"__data__": {"id_": "80cee061-8b84-4a7f-a486-268b776615b1", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4467e687-5999-4b63-9101-fe9d307cfc80", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "d2b09b8c892cac76d62cb1bb7df8ad201f0537ce0c4b8145b60a8f2a60f260dc", "class_name": "RelatedNodeInfo"}}, "text": "Position Relative to Labware\n\nWhen the robot positions itself relative to a piece of labware, where it moves is determined by the labware definition, the actions you want it to perform, and the labware offsets for a specific deck slot. This section describes how these positional components are calculated and how to change them.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 331, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4d36a5e1-62e2-4e01-8197-035f4ad72dd3": {"__data__": {"id_": "4d36a5e1-62e2-4e01-8197-035f4ad72dd3", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6b6772b3-9022-4a46-bc80-adfe89c9accb", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "2301bc89b7be7760daf436fbccb239c4d68bacf017786cf65509d52e8d29cfec", "class_name": "RelatedNodeInfo"}}, "text": "Top, Bottom, and Center\n\nEvery well on every piece of labware has three addressable positions: top, bottom, and center. The position is determined by the labware definition and what the labware is loaded on top of. You can use these positions as\\-is or calculate other positions relative to them.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 298, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4437d5d8-8c75-42cc-9cac-3efc7d7c1dab": {"__data__": {"id_": "4437d5d8-8c75-42cc-9cac-3efc7d7c1dab", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "40fbc029-2ad0-402e-81cd-8c0efe287788", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "0585e95a99d872137412e0505501b191d426d9a5649958b827627dd4b5fac464", "class_name": "RelatedNodeInfo"}}, "text": "Top\n\nLet\u2019s look at the `Well.top()` method. It returns a position level with the top of the well, centered in both horizontal directions.\n\n```\nplate[\"A1\"].top()  # the top center of the well\n\n```\n\nThis is a good position to use for a blow out operation or an activity where you don\u2019t want the tip to contact the liquid. In addition, you can adjust the height of this position with the optional argument `z`, which is measured in mm. Positive `z` numbers move the position up, negative `z` numbers move it down.\n\n```\nplate[\"A1\"].top(z=1)  # 1 mm above the top center of the well\nplate[\"A1\"].top(z=-1) # 1 mm below the top center of the well\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 669, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f7a6a9f5-c3d3-4eb2-831b-6b62b1f68842": {"__data__": {"id_": "f7a6a9f5-c3d3-4eb2-831b-6b62b1f68842", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "58c66e14-f22b-4a36-ab1f-9f57d4b818f9", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "549f6ef2cd987ac2734452afa0537d82ce07ee872232c79de3ccc2ec79d051d2", "class_name": "RelatedNodeInfo"}}, "text": "Bottom\n\nLet\u2019s look at the `Well.bottom()` method. It returns a position level with the bottom of the well, centered in both horizontal directions.\n\n```\nplate[\"A1\"].bottom()  # the bottom center of the well\n\n```\n\nThis is a good position for aspirating liquid or an activity where you want the tip to contact the liquid. Similar to the `Well.top()` method, you can adjust the height of this position with the optional argument `z`, which is measured in mm. Positive `z` numbers move the position up, negative `z` numbers move it down.\n\n```\nplate[\"A1\"].bottom(z=1)  # 1 mm above the bottom center of the well\nplate[\"A1\"].bottom(z=-1) # 1 mm below the bottom center of the well\n                         # this may be dangerous!\n\n```\n\nWarning\n\nNegative `z` arguments to `Well.bottom()` will cause the pipette tip to collide with the bottom of the well. Collisions may bend the tip (affecting liquid handling) and the pipette may be higher than expected on the z\\-axis until it picks up another tip.\n\nFlex can detect collisions, and even gentle contact may trigger an overpressure error and cause the protocol to fail. Avoid `z` values less than 1, if possible.\n\nThe OT\\-2 has no sensors to detect contact with a well bottom. The protocol will continue even after a collision.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1295, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fec09d0b-e735-417c-b5b5-a8955669bcd0": {"__data__": {"id_": "fec09d0b-e735-417c-b5b5-a8955669bcd0", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "30483c99-d763-4ad5-b049-71ea752763cd", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "833e8a4578d69aa43ba7adbd4ef4fd00e9ec2ba16e566f3c645e838259322220", "class_name": "RelatedNodeInfo"}}, "text": "Center\n\nLet\u2019s look at the `Well.center()` method. It returns a position centered in the well both vertically and horizontally. This can be a good place to start for precise control of positions within the well for unusual or custom labware.\n\n```\nplate[\"A1\"].center() # the vertical and horizontal center of the well\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 345, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "848bbcae-08b8-44a8-8134-f50329851c68": {"__data__": {"id_": "848bbcae-08b8-44a8-8134-f50329851c68", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6a51f9e0-f740-49ba-a5fb-21f5a4664960", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "4a10a0d5b33eea9f285904611cd5aed99ae146889c91e9c6acbb82a5b9c76eb0", "class_name": "RelatedNodeInfo"}}, "text": "Default Positions\n\nBy default, your robot will aspirate and dispense 1 mm above the bottom of wells. This default clearance may not be suitable for some labware geometries, liquids, or protocols. You can change this value by using the `Well.bottom()` method with the `z` argument, though it can be cumbersome to do so repeatedly.\n\nIf you need to change the aspiration or dispensing height for multiple operations, specify the distance in mm from the well bottom with the `InstrumentContext.well_bottom_clearance` object. It has two attributes: `well_bottom_clearance.aspirate` and `well_bottom_clearance.dispense`. These change the aspiration height and dispense height, respectively.\n\nModifying these attributes will affect all subsequent aspirate and dispense actions performed by the attached pipette, even those executed as part of a `transfer()` operation. This snippet from a sample protocol demonstrates how to work with and change the default clearance:\n\n```\n# aspirate 1 mm above the bottom of the well (default)\npipette.aspirate(50, plate[\"A1\"])\n# dispense 1 mm above the bottom of the well (default)\npipette.dispense(50, plate[\"A1\"])\n\n# change clearance for aspiration to 2 mm\npipette.well_bottom_clearance.aspirate = 2\n# aspirate 2 mm above the bottom of the well\npipette.aspirate(50, plate[\"A1\"])\n# still dispensing 1 mm above the bottom\npipette.dispense(50, plate[\"A1\"])\n\npipette.aspirate(50, plate[\"A1\"])\n# change clearance for dispensing to 10 mm\npipette.well_bottom_clearance.dispense = 10\n# dispense high above the well\npipette.dispense(50, plate[\"A1\"])\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1601, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9207d7fd-cc90-4a7b-852e-ac3f0ca9849c": {"__data__": {"id_": "9207d7fd-cc90-4a7b-852e-ac3f0ca9849c", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bd21fc9f-2e9d-4dae-9aa1-0127bd7991b0", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "218cf4866011d196a83c7edaf8f387cacde411318819bef300fc37abf7b39221", "class_name": "RelatedNodeInfo"}}, "text": "Using Labware Position Check\n\nAll positions relative to labware are adjusted automatically based on labware offset data. Calculate labware offsets by running Labware Position Check during protocol setup, either in the Opentrons App or on the Flex touchscreen. Version 6\\.0\\.0 and later of the robot software can apply previously calculated offsets on the same robot for the same labware type and deck slot, even across different protocols.\n\nYou should only adjust labware offsets in your Python code if you plan to run your protocol in Jupyter Notebook or from the command line. See Setting Labware Offsets in the Advanced Control article for information.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 657, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9aa12637-db34-4d7a-9784-ef31ac8a269b": {"__data__": {"id_": "9aa12637-db34-4d7a-9784-ef31ac8a269b", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ed55d837-9d25-42b2-9f2f-0988305f31b9", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "057de893b8d46eb78027e43f30ecc081544c4a7b16c1b66a0cbd667dee8d053e", "class_name": "RelatedNodeInfo"}}, "text": "Position Relative to Trash Containers\n\nMovement to `TrashBin` or `WasteChute` objects is based on the horizontal _center_ of the pipette. This is different than movement to labware, which is based on the primary channel (the back channel on 8\\-channel pipettes, and the back\\-left channel on 96\\-channel pipettes in default configuration). Using the center of the pipette ensures that all attached tips are over the trash container for blowing out, dropping tips, or other disposal operations.\n\nNote\n\nIn API version 2\\.15 and earlier, trash containers are `Labware` objects that have a single well. See `fixed_trash` and Position Relative to Labware above.\n\nYou can adjust the position of the pipette center with the `TrashBin.top()` and `WasteChute.top()` methods. These methods allow adjustments along the x\\-, y\\-, and z\\-axes. In contrast, `Well.top()`, covered above, only allows z\\-axis adjustment. With no adjustments, the \u201ctop\u201d position is centered on the x\\- and y\\-axes and is just below the opening of the trash container.\n\n```\ntrash = protocol.load_trash_bin(\"A3\")\n\ntrash  # pipette center just below trash top center\ntrash.top()  # same position\ntrash.top(z=10)  # 10 mm higher\ntrash.top(y=10)  # 10 mm towards back, default height\n\n```\n\nNew in version 2\\.18\\.\n\nAnother difference between the trash container `top()` methods and `Well.top()` is that they return an object of the same type, not a `Location`. This helps prevent performing undesired actions in trash containers. For example, you can `aspirate()` at a location or from a well, but not from a trash container. On the other hand, you can `blow_out()` at a location, well, trash bin, or waste chute.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1675, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "86f775c7-90ef-43f2-9908-db52c8a86cb0": {"__data__": {"id_": "86f775c7-90ef-43f2-9908-db52c8a86cb0", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4669cc34-fabd-4371-afd9-07fc961fb99c", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "0542e5b68245da149ecb00527d76fff38db5f968620af95095bcc1caec7b3ee1", "class_name": "RelatedNodeInfo"}}, "text": "Position Relative to the Deck\n\nThe robot\u2019s base coordinate system is known as _deck coordinates_. Many API functions use this coordinate system, and you can also reference it directly. It is a right\\-handed coordinate system always specified in mm, with the origin `(0, 0, 0)` at the front left of the robot. The positive `x` direction is to the right, the positive `y` direction is to the back, and the positive `z` direction is up.\n\nYou can identify a point in this coordinate system with a `types.Location` object, either as a standard Python `tuple`') of three floats, or as an instance of the `namedtuple`') `types.Point`.\n\nNote\n\nThere are technically multiple vertical axes. For example, `z` is the axis of the left pipette mount and `a` is the axis of the right pipette mount. There are also pipette plunger axes: `b` (left) and `c` (right). You usually don\u2019t have to refer to these axes directly, since most motion commands are issued to a particular pipette and the robot automatically selects the correct axis to move. Similarly, `types.Location` only deals with `x`, `y`, and `z` values.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1100, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d9f734fc-3226-4b81-babc-93d496d33951": {"__data__": {"id_": "d9f734fc-3226-4b81-babc-93d496d33951", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0c453eb8-561b-4931-abe3-ea257e314b77", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "cd1b6f876999622d3df707769d14c4037cf2b6f4e583f40898474b1092905935", "class_name": "RelatedNodeInfo"}}, "text": "Independent Movement\n\nFor convenience, many methods have location arguments and incorporate movement automatically. This section will focus on moving the pipette independently, without performing other actions like `aspirate()` or `dispense()`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 246, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6601d651-4e32-43fa-a001-7f1af2ed50a5": {"__data__": {"id_": "6601d651-4e32-43fa-a001-7f1af2ed50a5", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a5eb5759-6fcd-4fba-a0ce-2d697baf268d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "bc1beb563952301be3534766a5201c1110b6cf5651496950fba41d046ba9f8a3", "class_name": "RelatedNodeInfo"}}, "text": "Move To\n\nThe `InstrumentContext.move_to()` method moves a pipette to any reachable location on the deck. If the pipette has picked up a tip, it will move the end of the tip to that position; if it hasn\u2019t, it will move the pipette nozzle to that position.\n\nThe `move_to()` method requires the `Location` argument. The location can be automatically generated by methods like `Well.top()` and `Well.bottom()` or one you\u2019ve created yourself, but you can\u2019t move a pipette to a well directly:\n\n```\npipette.move_to(plate[\"A1\"])              # error; can't move to a well itself\npipette.move_to(plate[\"A1\"].bottom())     # move to the bottom of well A1\npipette.move_to(plate[\"A1\"].top())        # move to the top of well A1\npipette.move_to(plate[\"A1\"].bottom(z=2))  # move to 2 mm above the bottom of well A1\npipette.move_to(plate[\"A1\"].top(z=-2))    # move to 2 mm below the top of well A1\n\n```\n\nWhen using `move_to()`, by default the pipette will move in an arc: first upwards, then laterally to a position above the target location, and finally downwards to the target location. If you have a reason for doing so, you can force the pipette to move in a straight line to the target location:\n\n```\npipette.move_to(plate[\"A1\"].top(), force_direct=True)\n\n```\n\nWarning\n\nMoving without an arc runs the risk of the pipette colliding with objects on the deck. Be very careful when using this option, especially when moving longer distances.\n\nSmall, direct movements can be useful for working inside of a well, without having the tip exit and re\\-enter the well. This code sample demonstrates how to move the pipette to a well, make direct movements inside that well, and then move on to a different well:\n\n```\npipette.move_to(plate[\"A1\"].top())\npipette.move_to(plate[\"A1\"].bottom(1), force_direct=True)\npipette.move_to(plate[\"A1\"].top(-2), force_direct=True)\npipette.move_to(plate[\"A2\"].top())\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1910, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ddcbe981-2b7a-44be-af60-bcf555433f0b": {"__data__": {"id_": "ddcbe981-2b7a-44be-af60-bcf555433f0b", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4a760229-465c-427e-aa06-ee9c11b9d741", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "f9821f4dbae9b998daf5431ed7f1080f0fefb8901e2b54eaeb9f21c777e1f7d9", "class_name": "RelatedNodeInfo"}}, "text": "Points and Locations\n\nWhen instructing the robot to move, it\u2019s important to consider the difference between the `Point` and `Location` types.\n\n- Points are ordered tuples or named tuples: `Point(10, 20, 30)`, `Point(x=10, y=20, z=30)`, and `Point(z=30, y=20, x=10)` are all equivalent.\n- Locations are a higher\\-order tuple that combines a point with a reference object: a well, a piece of labware, or `None` (the deck).\n\nThis distinction is important for the `Location.move()` method, which operates on a location, takes a point as an argument, and outputs an updated location. To use this method, include `from opentrons import types` at the start of your protocol. The `move()` method does not mutate the location it is called on, so to perform an action at the updated location, use it as an argument of another method or save it to a variable. For example:\n\n```\n# get the location at the center of well A1\ncenter_location = plate[\"A1\"].center()\n\n# get a location 1 mm right, 1 mm back, and 1 mm up from the center of well A1\nadjusted_location = center_location.move(types.Point(x=1, y=1, z=1))\n\n# aspirate 1 mm right, 1 mm back, and 1 mm up from the center of well A1\npipette.aspirate(50, adjusted_location)\n\n# dispense at the same location\npipette.dispense(50, center_location.move(types.Point(x=1, y=1, z=1)))\n\n```\n\nNote\n\nThe additional `z` arguments of the `top()` and `bottom()` methods (see Position Relative to Labware above) are shorthand for adjusting the top and bottom locations with `move()`. You still need to use `move()` to adjust these positions along the x\\- or y\\-axis:\n\n```\n# the following are equivalent\npipette.move_to(plate[\"A1\"].bottom(z=2))\npipette.move_to(plate[\"A1\"].bottom().move(types.Point(z=2)))\n\n# adjust along the y-axis\npipette.move_to(plate[\"A1\"].bottom().move(types.Point(y=2)))\n\n```\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1847, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e0b0b4a4-8b9a-4bfa-a123-93385461cdd5": {"__data__": {"id_": "e0b0b4a4-8b9a-4bfa-a123-93385461cdd5", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5fa5cbaf-0f35-4b9d-adff-e85c226123ee", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ad03d881a38faabf604fac07d14645f814796790837f25c85bd6acbf8f1d7898", "class_name": "RelatedNodeInfo"}}, "text": "Movement Speeds\n\nIn addition to instructing the robot where to move a pipette, you can also control the speed at which it moves. Speed controls can be applied either to all pipette motions or to movement along a particular axis.\n\nNote\n\nLike all mechanical systems, Opentrons robots have resonant frequencies that depend on their construction and current configuration. It\u2019s possible to set a speed that causes your robot to resonate, producing louder sounds than typical operation. This is safe, but if you find it annoying, increase or decrease the speed slightly.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 567, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ecea9bbd-03e7-48bb-a9f9-5336c4334872": {"__data__": {"id_": "ecea9bbd-03e7-48bb-a9f9-5336c4334872", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "47fea022-bdde-408e-884b-15d4b71026b9", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "0f2c471f349296e90c89c0c70b16890e881a203cb1a902945b49fc5267878dc1", "class_name": "RelatedNodeInfo"}}, "text": "Gantry Speed\n\nThe robot\u2019s gantry usually moves as fast as it can given its construction. The default speed for Flex varies between 300 and 350 mm/s. The OT\\-2 default is 400 mm/s. However, some experiments or liquids may require slower movements. In this case, you can reduce the gantry speed for a specific pipette by setting `InstrumentContext.default_speed` like this:\n\n```\npipette.move_to(plate[\"A1\"].top())  # move to the first well at default speed\npipette.default_speed = 100         # reduce pipette speed\npipette.move_to(plate[\"D6\"].top())  # move to the last well at the slower speed\n\n```\n\nWarning\n\nThese default speeds were chosen because they\u2019re the maximum speeds that Opentrons knows will work with the gantry. Your robot may be able to move faster, but you shouldn\u2019t increase this value unless instructed by Opentrons Support.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 866, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ba98213b-5769-456f-a73c-9548722f822c": {"__data__": {"id_": "ba98213b-5769-456f-a73c-9548722f822c", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "801c7121-6498-45f9-9982-5ac4493b7d5c", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "a012e70ec7d969f854a561ac9e36422cff3aa2e740d9d3ae4c02e5f8b77f32f2", "class_name": "RelatedNodeInfo"}}, "text": "Axis Speed Limits\n\nIn addition to controlling the overall gantry speed, you can set speed limits for each of the individual axes: `x` (gantry left/right motion), `y` (gantry forward/back motion), `z` (left pipette up/down motion), and `a` (right pipette up/down motion). Unlike `default_speed`, which is a pipette property, axis speed limits are stored in a protocol property `ProtocolContext.max_speeds`; therefore the `x` and `y` values affect all movements by both pipettes. This property works like a dictionary, where the keys are axes, assigning a value to a key sets a max speed, and deleting a key or setting it to `None` resets that axis\u2019s limit to the default:\n\n```\n    protocol.max_speeds[\"x\"] = 50    # limit x-axis to 50 mm/s\n    del protocol.max_speeds[\"x\"]     # reset x-axis limit\n    protocol.max_speeds[\"a\"] = 10    # limit a-axis to 10 mm/s\n    protocol.max_speeds[\"a\"] = None  # reset a-axis limit\n\n```\n\nNote that `max_speeds` can\u2019t set limits for the pipette plunger axes (`b` and `c`); instead, set the flow rates or plunger speeds as described in Pipette Flow Rates.\n\nNew in version 2\\.0\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1114, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a64438d1-9e57-4325-8a98-99fc03559c27": {"__data__": {"id_": "a64438d1-9e57-4325-8a98-99fc03559c27", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7770cd55-5f3b-4e8e-aee9-ecf39b046832", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "a3644b8cefceed6ec9f7f173407b54b8218c190a54b39ef05f93939abc5226bb", "class_name": "RelatedNodeInfo"}}, "text": "Runtime Parameters", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 20, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "24c3a50c-42cd-4c3e-8001-e7332dccb190": {"__data__": {"id_": "24c3a50c-42cd-4c3e-8001-e7332dccb190", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2de75324-dbdf-4dfd-b349-8d4646785a32", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "703354e3699707a253938e44028b22d13caf251a4d7de66ec7002fcfc8231876", "class_name": "RelatedNodeInfo"}}, "text": "Choosing Good Parameters\n\nThe first decision you need to make when adding parameters to your protocol is \u201cWhat should be parameterized?\u201d Your goals in adding parameters should be the following:\n\n1. **Add flexibility.** Accommodate changes from run to run or from lab to lab.\n2. **Work efficiently.** Don\u2019t burden run setup with too many choices or confusing options.\n3. **Avoid errors.** Ensure that every combination of parameters produces an analyzable, runnable protocol.\n\nThe trick to choosing good parameters is reasoning through the choices the protocol\u2019s users may make. If any of them lead to nonsensical outcomes or errors, adjust the parameters \u2014 or how your protocol uses parameter values \u2014 to avoid those situations.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 730, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e2cb319e-b352-4d4b-8f53-a8aa3675baf9": {"__data__": {"id_": "e2cb319e-b352-4d4b-8f53-a8aa3675baf9", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "771c14ae-b222-4117-b39d-2faea750ee5c", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "d7adf863256be61bbcc8cc5c8d3153bbc2f76dd1c7d2f8bba60539af5bd2a4b8", "class_name": "RelatedNodeInfo"}}, "text": "Build on a Task\n\nConsider what scientific task is at the heart of your protocol, and build parameters that contribute to, rather than diverge from it.\n\nFor example, it makes sense to add a parameter for number of samples to a DNA prep protocol that uses a particular reagent kit. But it wouldn\u2019t make sense to add a parameter for _which reagent kit_ to use for DNA prep. That kind of parameter would affect so many aspects of the protocol that it would make more sense to maintain a separate protocol for each kit.\n\nAlso consider how a small number of parameters can combine to produce many useful outputs. Take the serial dilution task from the Tutorial as an example. We could add just three parameters to it: number of dilutions, dilution factor, and number of rows. Now that single protocol can produce a whole plate that gradually dilutes, a 2\u00d74 grid that rapidly dilutes, and _thousands_ of other combinations.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 918, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6469cac0-fee6-4b34-8ea5-9073e683c617": {"__data__": {"id_": "6469cac0-fee6-4b34-8ea5-9073e683c617", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "fdabded4-fe83-400b-bec1-ce4c30cf9b1f", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "78a8f3cb6310ea6f1c4b793605a4c6237a434fd4309897e3f9b3f3a06d048775", "class_name": "RelatedNodeInfo"}}, "text": "Consider Contradictions\n\nHere\u2019s a common time\\-saving use of parameters: your protocol requires a 1\\-channel pipette and an 8\\-channel pipette, but it doesn\u2019t matter which mount they\u2019re attached to. Without parameters, you would have to assign the mounts in your protocol. Then if the robot is set up in the reverse configuration, you\u2019d have to either physically swap the pipettes or modify your protocol.\n\nOne way to get this information is to ask which mount the 1\\-channel pipette is on, and which mount the 8\\-channel pipette is on. But if a technician answers \u201cleft\u201d to both questions \u2014 even by accident \u2014 the API will raise an error, because you can\u2019t load two pipettes on a single mount. It\u2019s no better to flip things around by asking which pipette is on the left mount, and which pipette is on the right mount. Now the technician can say that both mounts have a 1\\-channel pipette. This is even more dangerous, because it _might not_ raise any errors in analysis. The protocol could run \u201csuccessfully\u201d on a robot with two 1\\-channel pipettes, but produce completely unintended results.\n\nThe best way to avoid these contradictions is to collapse the two questions into one, with limited choices. Where are the pipettes mounted? Either the 1\\-channel is on the left and the 8\\-channel on the right, or the 8\\-channel is on the left and the 1\\-channel is on the right. This approach is best for several reasons:\n\n- It avoids analysis errors.\n- It avoids potentially dangerous execution errors.\n- It only requires answering one question instead of two.\n- The phrasing of the question and answer makes it clear that the protocol requires exactly one of each pipette type.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1676, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d2653b40-5996-4076-a42f-f531ece9bd7f": {"__data__": {"id_": "d2653b40-5996-4076-a42f-f531ece9bd7f", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6505cecf-677c-4d91-bc21-4c3a911f2ac0", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "04f843bd6e6feb8e708ec3f62bc80a6bef2d0ea01bc8b95167f64723ba9a5b88", "class_name": "RelatedNodeInfo"}}, "text": "Set Boundaries\n\nNumerical parameters support minimum and maximum values, which you should set to avoid incorrect inputs that are outside of your protocol\u2019s possibile actions.\n\nConsider our earlier example of parameterizing serial dilution. Each of the three numerical parameters have logical upper and lower bounds, which we need to enforce to get sensible results.\n\n- _Number of dilutions_ must be between 0 and 11 on a 96\\-well plate. And it may make sense to require at least 1 dilution.\n- _Dilution factor_ is a ratio, which we can express as a decimal number that must be between 0 and 1\\.\n- _Number of rows_ must be between 1 and 8 on a 96\\-well plate.\n\nWhat if you wanted to perform a dilution with 20 repetitions? It\u2019s possible with two 96\\-well plates, or with a 384\\-well plate. You could set the maximum for the number of dilutions to 24 and allow for these possibilities \u2014 either switching the plate type or loading an additional plate based on the provided value.\n\nBut what if the technician wanted to do just 8 repetitions on a 384\\-well plate? That would require an additional parameter, an additional choice by the technician, and additional logic in your protocol code. It\u2019s up to you as the protocol author to decide if adding more parameters will make protocol setup overly difficult. Sometimes it\u2019s more efficient to work with two or three simple protocols rather than one that\u2019s long and complex.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1419, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9b41fc0e-a810-4ca3-95cc-e21c280031b0": {"__data__": {"id_": "9b41fc0e-a810-4ca3-95cc-e21c280031b0", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "453763d3-5a2c-4186-8f6a-d9f423a3c22e", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "070246027df44d6566f28cfbd8dff1c033bf36e368524e981a7c9660fc49d10f", "class_name": "RelatedNodeInfo"}}, "text": "Defining Parameters\n\nTo use parameters, you need to define them in a separate function within your protocol. Each parameter definition has two main purposes: to specify acceptable values, and to inform the protocol user what the parameter does.\n\nDepending on the type of parameter, you\u2019ll need to specify some or all of the following.\n\n| Attribute               | Details                                                                                                                                                                                                                                          |\n| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `variable_name`         | _ A unique name for referencing the parameter value elsewhere in the protocol. _ Must meet the usual requirements for naming objects in Python. |\n| `display_name`          | _ A label for the parameter shown in the Opentrons App or on the touchscreen. _ Maximum 30 characters.                                                                                                                                           |\n| `description`           | _ An optional longer explanation of what the parameter does, or how its values will affect the execution of the protocol. _ Maximum 100 characters.                                                                                              |\n| `default`               | \\* The value the parameter will have if the technician makes no changes to it during run setup.                                                                                                                                                  |\n| `minimum` and `maximum` | _ For numeric parameters only. _ Allows free entry of any value within the range (inclusive). _ Both values are required. _ Can\u2019t be used at the same time as `choices`.                                                                         |\n| `choices`               | _ For numeric or string parameters. _ Provides a fixed list of values to choose from. _ Each choice has its own display name and value. _ Can\u2019t be used at the same time as `minimum` and `maximum`.                                             |\n| `units`                 | _ Optional, for numeric parameters with `minimum` and `maximum` only. _ Displays after the number during run setup. _ Does not affect the parameter\u2019s value or protocol execution. _ Maximum 10 characters.                                      |", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2679, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b45f890e-3c4c-44b2-bf62-87f14ac48e9a": {"__data__": {"id_": "b45f890e-3c4c-44b2-bf62-87f14ac48e9a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "dcc12e56-bbb1-48dd-90f1-330686f8779d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "eccc10d69d04dd0d402228df59c4019bbce270da7c34f8a5d9e7ec94832c03ca", "class_name": "RelatedNodeInfo"}}, "text": "The `add_parameters()` Function\n\nAll parameter definitions are contained in a Python function, which must be named `add_parameters` and takes a single argument. Define `add_parameters()` before the `run()` function that contains protocol commands.\n\nThe examples on this page assume the following definition, which uses the argument name `parameters`. The type specification of the argument is optional.\n\n```\ndef add_parameters(parameters: protocol_api.Parameters):\n\n```\n\nWithin this function definition, call methods on `parameters` to define parameters. The next section demonstrates how each type of parameter has its own method.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 633, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "b238dc51-f74a-4dc9-a980-bb6f2d0facca": {"__data__": {"id_": "b238dc51-f74a-4dc9-a980-bb6f2d0facca", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2228b889-4a61-4d0e-ba33-07c97eed0389", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "318c45904750e3580b904e8efb4c8e84551b17302035050386482224baf12546", "class_name": "RelatedNodeInfo"}}, "text": "Types of Parameters\n\nThe API supports four types of parameters: Boolean (`bool`')), integer (`int`')), floating point number (`float`')), and string (`str`')). It is not possible to mix types within a single parameter.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 220, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "92e2dace-0784-4955-a484-939c74711ce2": {"__data__": {"id_": "92e2dace-0784-4955-a484-939c74711ce2", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "78c46e43-b93a-4000-991b-de6110b1ed12", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "542f8012ef4d9c2c873866d937375b092e7e14e9f309ef76b27fdae653dcf9f5", "class_name": "RelatedNodeInfo"}}, "text": "Boolean Parameters\n\nBoolean parameters are `True` or `False` only.\n\n```\nparameters.add_bool(\n    variable_name=\"dry_run\",\n    display_name=\"Dry Run\",\n    description=\"Skip incubation delays and shorten mix steps.\",\n    default=False\n)\n\n```\n\nDuring run setup, the technician can toggle between the two values. In the Opentrons App, Boolean parameters appear as a toggle switch. On the touchscreen, they appear as _On_ or _Off_, for `True` and `False` respectively.\n\nNew in version 2\\.18\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 489, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3b1dd7c8-d7bf-4ac0-9d6f-6b21ed196e4e": {"__data__": {"id_": "3b1dd7c8-d7bf-4ac0-9d6f-6b21ed196e4e", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e9f123f7-660d-4d8d-95f8-5e0bd024443c", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "3cca960fc3db5eba702a4e74c0d62f1b81cc6c3471c067a4987e961ad37ab414", "class_name": "RelatedNodeInfo"}}, "text": "Integer Parameters\n\nInteger parameters either accept a range of numbers or a list of numbers. You must specify one or the other; you can\u2019t create an open\\-ended prompt that accepts any integer.\n\nTo specify a range, include `minimum` and `maximum`.\n\n```\nparameters.add_int(\n    variable_name=\"volume\",\n    display_name=\"Aspirate volume\",\n    description=\"How much to aspirate from each sample.\",\n    default=20,\n    minimum=10,\n    maximum=100,\n    unit=\"\u00b5L\"\n)\n\n```\n\nDuring run setup, the technician can enter any integer value from the minimum up to the maximum. Entering a value outside of the range will show an error. At that point, they can correct their custom value or restore the default value.\n\nTo specify a list of numbers, include `choices`. Each choice is a dictionary with entries for display name and value. The display names let you briefly explain the effect each choice will have.\n\n```\nparameters.add_int(\n    variable_name=\"volume\",\n    display_name=\"Aspirate volume\",\n    description=\"How much to aspirate from each sample.\",\n    default=20,\n    choices=[\n        {\"display_name\": \"Low (10 \u00b5L)\", \"value\": 10},\n        {\"display_name\": \"Medium (20 \u00b5L)\", \"value\": 20},\n        {\"display_name\": \"High (50 \u00b5L)\", \"value\": 50},\n    ]\n)\n\n```\n\nDuring run setup, the technician can choose from a menu of the provided choices.\n\nNew in version 2\\.18\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1360, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d8453891-ae22-412c-888d-98e7f50c361e": {"__data__": {"id_": "d8453891-ae22-412c-888d-98e7f50c361e", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "abf11ad1-2619-4914-abcd-4ecc455d6b8c", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "81d281abf8d11060774312b4769475486027c0e653bee18ce50a81d557d98a1b", "class_name": "RelatedNodeInfo"}}, "text": "Float Parameters\n\nFloat parameters either accept a range of numbers or a list of numbers. You must specify one or the other; you can\u2019t create an open\\-ended prompt that accepts any floating point number.\n\nSpecifying a range or list is done exactly the same as in the integer examples above. The only difference is that all values must be floating point numbers.\n\n```\nparameters.add_float(\n    variable_name=\"volume\",\n    display_name=\"Aspirate volume\",\n    description=\"How much to aspirate from each sample.\",\n    default=5.0,\n    choices=[\n        {\"display_name\": \"Low (2.5 \u00b5L)\", \"value\": 2.5},\n        {\"display_name\": \"Medium (5 \u00b5L)\", \"value\": 5.0},\n        {\"display_name\": \"High (10 \u00b5L)\", \"value\": 10.0},\n    ]\n)\n\n```\n\nNew in version 2\\.18\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 750, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "641f39eb-43fb-4f67-9f85-b27979fdcf89": {"__data__": {"id_": "641f39eb-43fb-4f67-9f85-b27979fdcf89", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5044523e-0216-4f21-8097-9a0e34005ebc", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "3bf74cf9cc933e3dc581635ddc1b7e164e24c64733c8caae56376bfcdf53f6d6", "class_name": "RelatedNodeInfo"}}, "text": "String Parameters\n\nString parameters only accept a list of values. You can\u2019t currently prompt for free text entry of a string value.\n\nTo specify a list of strings, include `choices`. Each choice is a dictionary with entries for display name and value. Only the display name will appear during run setup.\n\nA common use for string display names is to provide an easy\\-to\\-read version of an API load name. You can also use them to briefly explain the effect each choice will have.\n\n```\nparameters.add_str(\n    variable_name=\"pipette\",\n    display_name=\"Pipette type\",\n    choices=[\n        {\"display_name\": \"1-Channel 50 \u00b5L\", \"value\": \"flex_1channel_50\"},\n        {\"display_name\": \"8-Channel 50 \u00b5L\", \"value\": \"flex_8channel_50\"},\n    ],\n    default=\"flex_1channel_50\",\n)\n\n```\n\nDuring run setup, the technician can choose from a menu of the provided choices.\n\nNew in version 2\\.18\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 881, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "06ff69ea-ea3f-4e05-9702-a4f42083162c": {"__data__": {"id_": "06ff69ea-ea3f-4e05-9702-a4f42083162c", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ff71afa6-6817-4c42-ab3e-c84632ee6845", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ba91f30caff14af6bbc551dcc14d507e5bf0523382dd3b035a31614848d301f9", "class_name": "RelatedNodeInfo"}}, "text": "Using Parameters\n\nOnce you\u2019ve defined parameters, their values are accessible anywhere within the `run()` function of your protocol.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 134, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "33862ba6-3d98-43a6-8b48-45d72ec0c9f7": {"__data__": {"id_": "33862ba6-3d98-43a6-8b48-45d72ec0c9f7", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "b373300d-6b21-4b71-ba8b-5169cd22a3c3", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "d0c1bd5e6c0ac385fd1c3483c9d4f52a751827cebd4bd4f78caec1541d07131d", "class_name": "RelatedNodeInfo"}}, "text": "The `params` Object\n\nProtocols with parameters have a `ProtocolContext.params` object, which contains the values of all parameters as set during run setup. Each attribute of `params` corresponds to the `variable_name` of a parameter.\n\nFor example, consider a protocol that defines the following three parameters:\n\n- `add_bool` with `variable_name=\"dry_run\"`\n- `add_int` with `variable_name=\"sample_count\"`\n- `add_float` with `variable_name=\"volume\"`\n\nThen `params` will gain three attributes: `params.dry_run`, `params.sample_count`, and `params.volume`. You can use these attributes anywhere you want to access their values, including directly as arguments of methods.\n\n```\nif protocol.params.dry_run is False:\n    pipette.mix(repetitions=10, volume=protocol.params.volume)\n\n```\n\nYou can also save parameter values to variables with names of your choosing.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 859, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5105ccff-853c-4348-81c4-0d3619922165": {"__data__": {"id_": "5105ccff-853c-4348-81c4-0d3619922165", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "43561dff-5a70-44c5-b85c-6b103665a579", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "70a8bf5f99747417628f60047a9e25046e6a77095aa012214c0ec235a5474829", "class_name": "RelatedNodeInfo"}}, "text": "Parameter Types\n\nEach attribute of `params` has the type corresponding to its parameter definition. Keep in mind the parameter\u2019s type when using its value in different contexts.\n\nSay you wanted to add a comment to the run log, stating how many samples the protocol will process. Since `sample_count` is an `int`, you\u2019ll need to cast it to a `str` or the API will raise an error.\n\n```\nprotocol.comment(\n    \"Processing \" + str(protocol.params.sample_count) + \" samples.\"\n)\n\n```\n\nAlso be careful with `int` types when performing calculations: dividing an `int` by an `int` with the `/` operator always produces a `float`, even if there is no remainder. The sample count use case converts a sample count to a column count by dividing by 8 \u2014 but it uses the `//` integer division operator, so the result can be used for creating ranges, slicing lists, and as `int` argument values without having to cast it in those contexts.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 923, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "243dfa73-42aa-4ac7-9d0f-dbfcfac806d8": {"__data__": {"id_": "243dfa73-42aa-4ac7-9d0f-dbfcfac806d8", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "006e6506-be88-4e19-b0f1-9558e4ad6ade", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "722140cb6a3ce4edd634042892d031b8ff9502aeff9b92873dfef4a4aaf80a24", "class_name": "RelatedNodeInfo"}}, "text": "Limitations\n\nSince `params` is only available within the `run()` function, there are certain aspects of a protocol that parameter values can\u2019t affect. These include, but are not limited to the following:\n\n| Information                      | Location                                        |\n| -------------------------------- | ----------------------------------------------- |\n| `import` statements              | At the beginning of the protocol.               |\n| Robot type (Flex or OT\\-2\\)      | In the `requirements` dictionary.               |\n| API version                      | In the `requirements` or `metadata` dictionary. |\n| Protocol name                    | In the `metadata` dictionary.                   |\n| Protocol description             | In the `metadata` dictionary.                   |\n| Protocol author                  | In the `metadata` dictionary.                   |\n| Other runtime parameters         | In the `add_parameters()` function.             |\n| Non\\-nested function definitions | Anywhere outside of `run()`.                    |\n\nAdditionally, keep in mind that updated parameter values are applied by reanalyzing the protocol. This means you can\u2019t depend on updated values for any action that takes place _prior to reanalysis_.\n\nAn example of such an action is applying labware offset data. Say you have a parameter that changes the type of well plate you load in a particular slot:\n\n```\n# within add_parameters()\nparameters.add_str(\n    variable_name=\"plate_type\",\n    display_name=\"Well plate type\",\n    choices=[\n        {\"display_name\": \"Corning\", \"value\": \"corning_96_wellplate_360ul_flat\"},\n        {\"display_name\": \"NEST\", \"value\": \"nest_96_wellplate_200ul_flat\"},\n    ],\n    default=\"corning_96_wellplate_360ul_flat\",\n)\n\n# within run()\nplate = protocol.load_labware(\n    load_name=protocol.params.plate_type, location=\"D2\"\n)\n\n```\n\nWhen performing run setup, you\u2019re prompted to apply offsets before selecting parameter values. This is your only opportunity to apply offsets, so they\u2019re applied for the default parameter values \u2014 in this case, the Corning plate. If you then change the \u201cWell plate type\u201d parameter to the NEST plate, the NEST plate will have default offset values (0\\.0 on all axes). You can fix this by running Labware Position Check, since it takes place after reanalysis, or by using `Labware.set_offset()` in your protocol.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2398, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "50f9d152-9614-4f62-a600-ae7721e4f42c": {"__data__": {"id_": "50f9d152-9614-4f62-a600-ae7721e4f42c", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "219da5b9-f055-48e9-92b4-22fdcb947390", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ce7583eea92f46d523f5b40e10f008023371fa23e00929712610e6b64e795d44", "class_name": "RelatedNodeInfo"}}, "text": "Parameter Use Case \u2013 Sample Count\n\nChoosing how many samples to process is important for efficient automation. This use case explores how a single parameter for sample count can have pervasive effects throughout a protocol. The examples are adapted from an actual parameterized protocol for DNA prep. The sample code will use 8\\-channel pipettes to process 8, 16, 24, or 32 samples.\n\nAt first glance, it might seem like sample count would primarily affect liquid transfers to and from sample wells. But when using the Python API\u2019s full range of capabilities, it affects:\n\n- How many tip racks to load.\n- The initial volume and placement of reagents.\n- Pipetting to and from samples.\n- If and when tip racks need to be replaced.\n\nTo keep things as simple as possible, this use case only focuses on setting up and using the value of the sample count parameter, which is just one of several parameters present in the full protocol.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 930, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d781fb74-e430-4e16-8ba3-33f40cf8805c": {"__data__": {"id_": "d781fb74-e430-4e16-8ba3-33f40cf8805c", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9b86a7d9-96a2-4e58-8f7b-c20667c1ab1c", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "6839a3d96fac4434b327f1793637eb0e7d4f503053c7985a8292c47b945ae314", "class_name": "RelatedNodeInfo"}}, "text": "From Samples to Columns\n\nFirst of all, we need to set up the sample count parameter so it\u2019s both easy for technicians to understand during protocol setup and easy for us to use in the protocol\u2019s `run()` function.\n\nWe want to limit the number of samples to 8, 16, 24, or 32, so we\u2019ll use an integer parameter with choices:\n\n```\ndef add_parameters(parameters):\n\n    parameters.add_int(\n        variable_name=\"sample_count\",\n        display_name=\"Sample count\",\n        description=\"Number of input DNA samples.\",\n        default=24,\n        choices=[\n            {\"display_name\": \"8\", \"value\": 8},\n            {\"display_name\": \"16\", \"value\": 16},\n            {\"display_name\": \"24\", \"value\": 24},\n            {\"display_name\": \"32\", \"value\": 32},\n        ]\n    )\n\n```\n\nAll of the possible values are multiples of 8, because the protocol will use an 8\\-channel pipette to process an entire column of samples at once. Considering how 8\\-channel pipettes access wells, it may be more useful to operate with a _column count_ in code. We can set a `column_count` very early in the `run()` function by accessing the value of `params.sample_count` and dividing it by 8:\n\n```\ndef run(protocol):\n\n    column_count = protocol.params.sample_count // 8\n\n```\n\nMost examples below will use `column_count`, rather than redoing (and retyping!) this calculation multiple times.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1358, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7870deef-0ff7-4eb9-9177-ee611d122f6c": {"__data__": {"id_": "7870deef-0ff7-4eb9-9177-ee611d122f6c", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5e5970cc-055f-4ad8-8118-51172040cc69", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "16c430638d3a0544627e01b36a75a777042a9287f19fc1b8068e40eccad9348b", "class_name": "RelatedNodeInfo"}}, "text": "Loading Tip Racks\n\nTip racks come first in most protocols. To ensure that the protocol runs to completion, we need to load enough tip racks to avoid running out of tips.\n\nWe could load as many tip racks as are needed for our maximum number of samples, but that would be suboptimal. Run setup is faster when the technician doesn\u2019t have to load extra items onto the deck. So it\u2019s best to examine the protocol\u2019s steps and determine how many racks are needed for each value of `sample_count`.\n\nIn the case of this DNA prep protocol, we can create formulas for the number of 200 \u00b5L and 50 \u00b5L tip racks needed. The following factors go into these computations:\n\n- 50 \u00b5L tips\n  - 1 fixed action that picks up once per protocol.\n  - 7 variable actions that pick up once per sample column.\n- 200 \u00b5L tips\n  - 2 fixed actions that pick up once per protocol.\n  - 11 variable actions that pick up once per sample column.\n\nSince each tip rack has 12 columns, divide the number of pickup actions by 12 to get the number of racks needed. And we always need to round up \u2014 performing 13 pickups requires 2 racks. The `math.ceil()`') method rounds up to the nearest integer. We\u2019ll add `from math import ceil` at the top of the protocol and then calculate the number of tip racks as follows:\n\n```\ntip_rack_50_count = ceil((1 + 7 * column_count) / 12)\ntip_rack_200_count = ceil((2 + 13 * column_count) / 12)\n\n```\n\nRunning the numbers shows that the maximum combined number of tip racks is 7\\. Now we have to decide where to load up to 7 racks, working around the modules and other labware on the deck. Assuming we\u2019re running this protocol on a Flex with staging area slots, they\u2019ll all fit! (If you don\u2019t have staging area slots, you can load labware off\\-deck instead.) We\u2019ll reserve these slots for the different size racks:\n\n```\ntip_rack_50_slots = [\"B3\", \"C3\", \"B4\"]\ntip_rack_200_slots = [\"A2\", \"B2\", \"A3\", \"A4\"]\n\n```\n\nFinally, we can combine this information to call `load_labware()`. Depending on the number of racks needed, we\u2019ll slice that number of elements from the slot list and use a list comprehension to gather up the loaded tip racks. For the 50 \u00b5L tips, this would look like:\n\n```\ntip_racks_50 = [\n    protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_50ul\",\n        location=slot\n    )\n    for slot in tip_rack_50_slots[:tip_rack_50_count]\n]\n\n```\n\nThen we can associate those lists of tip racks directly with each pipette as we load them. All together, the start of our `run()` function looks like this:\n\n```\n# calculate column count from sample count\ncolumn_count = protocol.params.sample_count // 8\n\n# calculate number of required tip racks\ntip_rack_50_count = ceil((1 + 7 * column_count) / 12)\ntip_rack_200_count = ceil((2 + 13 * column_count) / 12)\n\n# assign tip rack locations (maximal case)\ntip_rack_50_slots = [\"B3\", \"C3\", \"B4\"]\ntip_rack_200_slots = [\"A2\", \"B2\", \"A3\", \"A4\"]\n\n# create lists of loaded tip racks\n# limit to number of needed racks for each type\ntip_racks_50 = [\n    protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_50ul\",\n        location=slot\n    )\n    for slot in tip_rack_50_slots[:tip_rack_50_count]\n]\ntip_racks_200 = [\n    protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_200ul\",\n        location=slot\n    )\n    for slot in tip_rack_200_slots[:tip_rack_200_count]\n]\n\npipette_50 = protocol.load_instrument(\n    instrument_name=\"flex_8channel_50\",\n    mount=\"right\",\n    tip_racks=tip_racks_50\n)\npipette_1000 = protocol.load_instrument(\n    instrument_name=\"flex_1channel_1000\",\n    mount=\"left\",\n    tip_racks=tip_racks_200\n)\n\n```\n\nThis code will load as few as 3 tip racks and as many as 7, and associate them with the correct pipettes \u2014 all based on a single choice from a dropdown menu at run setup.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 3781, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ba304024-cb3c-49af-a18e-f96ec2724457": {"__data__": {"id_": "ba304024-cb3c-49af-a18e-f96ec2724457", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "65049405-5ee7-41a3-8f7e-1f4afd67da15", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "f3c8c689bedfa7af6aa8018fbbe8b0f5fa604edbc7635624bd9128a8942af4d6", "class_name": "RelatedNodeInfo"}}, "text": "Loading Liquids\n\nNext come the reagents, samples, and the labware that holds them.\n\nThe required volume of each reagent is dependent on the sample count. While the full protocol defines more than ten liquids, we\u2019ll show three reagents plus the samples here.\n\nFirst, let\u2019s load a reservoir and define the three example liquids. Definitions only specify the name, description, and display color, so our sample count parameter doesn\u2019t come into play yet:\n\n```\n# labware to hold reagents\nreservoir = protocol.load_labware(\n    load_name=\"nest_12_reservoir_15ml\", location=\"C2\"\n)\n\n# reagent liquid definitions\nampure_liquid = protocol.define_liquid(\n    name=\"AMPure\", description=\"AMPure Beads\", display_color=\"#704848\"\n)\ntagstop_liquid = protocol.define_liquid(\n    name=\"TAGSTOP\", description=\"Tagmentation Stop\", display_color=\"#FF0000\"\n)\ntwb_liquid = protocol.define_liquid(\n    name=\"TWB\", description=\"Tagmentation Wash Buffer\", display_color=\"#FFA000\"\n)\n\n```\n\nNow we\u2019ll bring sample count into consideration as we load the liquids. The application requires the following volumes for each column of samples:\n\n| Liquid                   | Volume (\u00b5L per column) |\n| ------------------------ | ---------------------- |\n| AMPure Beads             | 180                    |\n| Tagmentation Stop        | 10                     |\n| Tagmentation Wash Buffer | 900                    |\n\nTo calculate the total volume for each liquid, we\u2019ll multiply these numbers by `column_count` and by 1\\.1 (to ensure that the pipette can aspirate the required volume without drawing in air at the bottom of the well). This calculation can be done inline as the `volume` value of `load_liquid()`:\n\n```\nreservoir[\"A1\"].load_liquid(\n    liquid=ampure_liquid, volume=180 * column_count * 1.1\n)\nreservoir[\"A2\"].load_liquid(\n    liquid=tagstop_liquid, volume=10 * column_count * 1.1\n)\nreservoir[\"A4\"].load_liquid(\n    liquid=twb_liquid, volume=900 * column_count * 1.1\n)\n\n```\n\nNow, for example, the volume of AMPure beads to load will vary from 198 \u00b5L for a single sample column up to 792 \u00b5L for four columns.\n\nTip\n\nDoes telling a technician to load 792 \u00b5L of a liquid seem overly precise? Remember that you can perform any calculation you like to set the value of `volume`! For example, you could round the AMPure volume up to the nearest 10 \u00b5L:\n\n```\nvolume=ceil((180 * column_count * 1.1) / 10) * 10\n\n```\n\nFinally, it\u2019s good practice to label the wells where the samples reside. The sample plate starts out atop the Heater\\-Shaker Module:\n\n```\nhs_mod = protocol.load_module(\n    module_name=\"heaterShakerModuleV1\", location=\"D1\"\n)\nhs_adapter = hs_mod.load_adapter(name=\"opentrons_96_pcr_adapter\")\nsample_plate = hs_adapter.load_labware(\n    name=\"opentrons_96_wellplate_200ul_pcr_full_skirt\",\n    label=\"Sample Plate\",\n)\n\n```\n\nNow we can construct a `for` loop to label each sample well with `load_liquid()`. The simplest way to do this is to combine our original _sample count_ with the fact that the `Labware.wells()` accessor returns wells top\\-to\\-bottom, left\\-to\\-right:\n\n```\n# define sample liquid\nsample_liquid = protocol.define_liquid(\n    name=\"Samples\", description=None, display_color=\"#52AAFF\"\n)\n\n# load 40 \u00b5L in each sample well\nfor w in range(protocol.params.sample_count):\n    sample_plate.wells()[w].load_liquid(liquid=sample_liquid, volume=40)\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 3346, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "16351c56-0d44-4ada-864f-be7104ad6860": {"__data__": {"id_": "16351c56-0d44-4ada-864f-be7104ad6860", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "16ec0902-93f5-4310-af1b-cd584e6ededb", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "03c90687116b8ac3d4fa4038e95513525c3876f34161a69e6887b10e954069dd", "class_name": "RelatedNodeInfo"}}, "text": "Processing Samples\n\nWhen it comes time to process the samples, we\u2019ll return to working by column, since the protocol uses an 8\\-channel pipette. There are many pipetting stages in the full protocol, but this section will examine just the stage for adding the Tagmentation Stop liquid. The same techniques would apply to similar stages.\n\nFor pipetting in the original sample locations, we\u2019ll command the 50 \u00b5L pipette to move to some or all of A1\u2013A4 on the sample plate. Similar to when we loaded tip racks earlier, we can use `column_count` to slice a list containing these well names, and then iterate over that list with a `for` loop:\n\n```\nfor w in [\"A1\", \"A2\", \"A3\", \"A4\"][:column_count]:\n    pipette_50.pick_up_tip()\n    pipette_50.aspirate(volume=13, location=reservoir[\"A2\"].bottom())\n    pipette_50.dispense(volume=3, location=reservoir[\"A2\"].bottom())\n    pipette_50.dispense(volume=10, location=sample_plate[w].bottom())\n    pipette_50.move_to(location=sample_plate[w].bottom())\n    pipette_50.mix(repetitions=10, volume=20)\n    pipette_50.blow_out(location=sample_plate[w].top(z=-2))\n    pipette_50.drop_tip()\n\n```\n\nEach time through the loop, the pipette will fill from the same well of the reservoir and then dispense (and mix and blow out) in a different column of the sample plate.\n\nLater steps of the protocol will move intermediate samples to the middle of the plate (columns 5\u20138\\) and final samples to the right side of the plate (columns 9\u201312\\). When moving directly from one set of columns to another, we have to track _both lists_ with the `for` loop. The `zip()`') function lets us pair up the lists of well names and step through them in parallel:\n\n```\nfor initial, intermediate in zip(\n    [\"A1\", \"A2\", \"A3\", \"A4\"][:column_count],\n    [\"A5\", \"A6\", \"A7\", \"A8\"][:column_count],\n):\n    pipette_50.pick_up_tip()\n    pipette_50.aspirate(volume=13, location=sample_plate[initial])\n    pipette_50.dispense(volume=13, location=sample_plate[intermediate])\n    pipette_50.drop_tip()\n\n```\n\nThis will transfer from column 1 to 5, 2 to 6, and so on \u2014 depending on the number of samples chosen during run setup.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2122, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a190cb27-9b4e-48b8-bad2-f21b21dce25b": {"__data__": {"id_": "a190cb27-9b4e-48b8-bad2-f21b21dce25b", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "82077a3f-5db0-4220-969c-766bfbb80958", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "7a529ed43d8eb253c689e482c1eefc8d793f6daa13a00f16fe020e232cbe0c46", "class_name": "RelatedNodeInfo"}}, "text": "Replenishing Tips\n\nFor the higher values of `protocol.params.sample_count`, the protocol will load tip racks in the staging area slots (column 4\\). Since pipettes can\u2019t reach these slots, we need to move these tip racks into the working area (columns 1\u20133\\) before issuing a pipetting command that targets them, or the API will raise an error.\n\nA protocol without parameters will always run out of tips at the same time \u2014 just add a `move_labware()` command when that happens. But as we saw in the Processing Samples section above, our parameterized protocol will go through tips at a different rate depending on the sample count.\n\nIn our simplified example, we know that when the sample count is 32, the first 200 \u00b5L tip rack will be exhausted after three stages of pipetting using the 1000 \u00b5L pipette. So, after that step, we could add:\n\n```\nif protocol.params.sample_count == 32:\n    protocol.move_labware(\n        labware=tip_racks_200[0],\n        new_location=chute,\n        use_gripper=True,\n    )\n    protocol.move_labware(\n        labware=tip_racks_200[-1],\n        new_location=\"A2\",\n        use_gripper=True,\n    )\n\n```\n\nThis will replace the first 200 \u00b5L tip rack (in slot A2\\) with the last 200 \u00b5L tip rack (in the staging area).\n\nHowever, in the full protocol, sample count is not the only parameter that affects the rate of tip use. It would be unwieldy to calculate in advance all the permutations of when tip replenishment is necessary. Instead, before each stage of the protocol, we could use `Well.has_tip()` to check whether the first tip rack is empty. If the _last well_ of the rack is empty, we can assume that the entire rack is empty and needs to be replaced:\n\n```\nif tip_racks_200[0].wells()[-1].has_tip is False:\n    # same move_labware() steps as above\n\n```\n\nFor a protocol that uses tips at a faster rate than this one \u2014 such that it might exhaust a tip rack in a single `for` loop of pipetting steps \u2014 you may have to perform such checks even more frequently. You can even define a function that counts tips or performs `has_tip` checks in combination with picking up a tip, and use that instead of `pick_up_tip()` every time you pipette. The built\\-in capabilities of Python and the methods of the Python Protocol API give you the flexibility to add this kind of smart behavior to your protocols.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2327, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a2dde6cc-b223-4833-8123-12a80b223f28": {"__data__": {"id_": "a2dde6cc-b223-4833-8123-12a80b223f28", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2e04468b-1a5f-41cb-870d-d63002ee17b0", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "56ea910611e7496cad4ba590fc7add35d3a0cdbd21c302cecf9fd8b68d73fae1", "class_name": "RelatedNodeInfo"}}, "text": "Parameter Use Case \u2013 Dry Run\n\nWhen testing out a new protocol, it\u2019s common to perform a dry run to watch your robot go through all the steps without actually handling samples or reagents. This use case explores how to add a single Boolean parameter for whether you\u2019re performing a dry run.\n\nThe code examples will show how this single value can control:\n\n- Skipping module actions and long delays.\n- Reducing mix repetitions to save time.\n- Returning tips (that never touched any liquid) to their racks.\n\nTo keep things as simple as possible, this use case only focuses on setting up and using the value of the dry run parameter, which could be just one of many parameters in a complete protocol.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 698, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "162d8940-0b7f-4e87-8288-15ce58a4bd8e": {"__data__": {"id_": "162d8940-0b7f-4e87-8288-15ce58a4bd8e", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "0f936c7f-ea99-4cfd-b7a7-b526a15c0154", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "1e02564f14794913d15e4d05bc42843c480c121a210cee053e3629b4a0c68318", "class_name": "RelatedNodeInfo"}}, "text": "Dry Run Definition\n\nFirst, we need to set up the dry run parameter. We want to set up a simple yes/no choice for the technician running the protocol, so we\u2019ll use a Boolean parameter:\n\n```\ndef add_parameters(parameters):\n\n    parameters.add_bool(\n        variable_name=\"dry_run\",\n        display_name=\"Dry Run\",\n        description=(\n            \"Skip delays,\"\n            \" shorten mix steps,\"\n            \" and return tips to their racks.\"\n        ),\n        default=False\n    )\n\n```\n\nThis parameter is set to `False` by default, assuming that most runs will be live runs. In other words, during run setup the technician will have to change the parameter setting to perform a dry run. If they leave it as is, the robot will perform a live run.\n\nAdditionally, since \u201cdry run\u201d can have different meanings in different contexts, it\u2019s important to include a `description` that indicates exactly what the parameter will control \u2014 in this case, three things. The following sections will show how to accomplish each of those when the dry run parameter is set to `True`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1066, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fa854af0-f5b7-4f15-a27d-d77b60c06994": {"__data__": {"id_": "fa854af0-f5b7-4f15-a27d-d77b60c06994", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "cc638242-a014-4e20-8438-82fe9a902629", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "d33bd4ebb05eee9f7bbab6b506c2ba0e723223c48519d607bdc40449cb5ea49d", "class_name": "RelatedNodeInfo"}}, "text": "Skipping Delays\n\nMany protocols have built\\-in delays, either for a module to work or to let a reaction happen passively. Lengthy delays just get in the way when verifying a protocol with a dry run. So wherever the protocol calls for a delay, we can check the value of `protocol.params.dry_run` and make the protocol behave accordingly.\n\nTo start, let\u2019s consider a simple `delay()` command. We can wrap it in an `if` statement such that the delay will only execute when the run is _not_ a dry run:\n\n```\nif protocol.params.dry_run is False:\n    protocol.delay(minutes=5)\n\n```\n\nYou can extend this approach to more complex situations, like module interactions. For example, in a protocol that moves a plate to the Thermocycler for an incubation, you\u2019ll want to perform all the movement steps \u2014 opening and closing the module lid, and moving the plate to and from the block \u2014 but skip the heating and cooling time. The simplest way to do this is, like in the delay example above, to wrap each skippable command:\n\n```\nprotocol.move_labware(labware=plate, new_location=tc_mod, use_gripper=True)\nif protocol.params.dry_run is False:\n    tc_mod.set_block_temperature(4)\n    tc_mod.set_lid_temperature(100)\ntc_mod.close_lid()\npcr_profile = [\n    {\"temperature\": 68, \"hold_time_seconds\": 180},\n    {\"temperature\": 98, \"hold_time_seconds\": 180},\n]\nif protocol.params.dry_run is False:\n    tc_mod.execute_profile(\n        steps=pcr_profile, repetitions=1, block_max_volume=50\n    )\ntc_mod.open_lid()\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1495, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "fc5e1b2a-c2f2-49c8-9d43-24afd4a22563": {"__data__": {"id_": "fc5e1b2a-c2f2-49c8-9d43-24afd4a22563", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d1bf8d3f-e168-4b22-9b78-5697e1d92ff0", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "c8a8df235f410d35badaeb2cd2138f805e9047f5afd7b2bb8ee4cd1f144c5046", "class_name": "RelatedNodeInfo"}}, "text": "Shortening Mix Steps\n\nSimilar to delays, mix steps can take a long time because they are inherently repetitive actions. Mixing ten times takes ten times as long as mixing once! To save time, set a mix repetitions variable based on the value of `protocol.params.dry_run` and pass that to `mix()`:\n\n```\nif protocol.params.dry_run is True:\n    mix_reps = 1\nelse:\n    mix_reps = 10\npipette.mix(repetitions=mix_reps, volume=50, location=plate[\"A1\"].bottom())\n\n```\n\nNote that this checks whether the dry run parameter is `True`. If you prefer to set up all your `if` statements to check whether it\u2019s `False`, you can reverse the logic:\n\n```\nif protocol.params.dry_run is False:\n    mix_reps = 10\nelse:\n    mix_reps = 1\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 719, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "62c57601-3a00-4f38-9001-f1b1657519b8": {"__data__": {"id_": "62c57601-3a00-4f38-9001-f1b1657519b8", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "dcfe059d-adf4-4efe-8a11-0f5df04bf137", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "b39b948fe752c3d69627a80eb316b286a088a9c6dff19ca05468a957779f5cca", "class_name": "RelatedNodeInfo"}}, "text": "Returning Tips\n\nTips used in a dry run should be reusable \u2014 for another dry run, if nothing else. It doesn\u2019t make sense to dispose of them in a trash container, unless you specifically need to test movement to the trash. You can choose whether to use `drop_tip()` or `return_tip()` based on the value of `protocol.params.dry_run`. If the protocol doesn\u2019t have too many tip drop actions, you can use an `if` statement each time:\n\n```\nif protocol.params.dry_run is True:\n    pipette.return_tip()\nelse:\n    pipette.drop_tip()\n\n```\n\nHowever, repeating this block every time you handle tips could significantly clutter your code. Instead, you could define it as a function:\n\n```\ndef return_or_drop(pipette):\n    if protocol.params.dry_run is True:\n        pipette.return_tip()\n    else:\n        pipette.drop_tip()\n\n```\n\nThen call that function throughout your protocol:\n\n```\npipette.pick_up_tip()\nreturn_or_drop(pipette)\n\n```\n\nNote\n\nIt\u2019s generally better to define a standalone function, rather than adding a method to the `InstrumentContext` class. This makes your custom, parameterized commands stand out from API methods in your code.\n\nAdditionally, if your protocol uses enough tips that you have to replenish tip racks, you\u2019ll need separate behavior for dry runs and live runs. In a live run, once you\u2019ve used all the tips, the rack is empty, because the tips are in the trash. In a dry run, once you\u2019ve used all the tips in a rack, the rack is _full_, because you returned the tips.\n\nThe API has methods to handle both of these situations. To continue using the same tip rack without physically replacing it, call `reset_tipracks()`. In the live run, move the empty tip rack off the deck and move a full one into place:\n\n```\nif protocol.params.dry_run is True:\n    pipette.reset_tipracks()\nelse:\n    protocol.move_labware(\n        labware=tips_1, new_location=chute, use_gripper=True\n    )\n    protocol.move_labware(\n        labware=tips_2, new_location=\"C3\", use_gripper=True\n    )\n\n```\n\nYou can modify this code for similar cases. You may be moving tip racks by hand, rather than with the gripper. Or you could even mix the two, moving the used (but full) rack off\\-deck by hand \u2014 instead of dropping it down the chute, spilling all the tips \u2014 and have the gripper move a new rack into place. Ultimately, it\u2019s up to you to fine\\-tune your dry run behavior, and communicate it to your protocol\u2019s users with your parameter descriptions.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 2439, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "861da732-4fdc-4aab-bc7b-b047963943e3": {"__data__": {"id_": "861da732-4fdc-4aab-bc7b-b047963943e3", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4827f7da-38d2-48b3-a83b-74a0ae6b0dc1", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "8e7e671373bf25e926c43ab2db7f27d81e8438f2741f6c823da90eda7f5e54ae", "class_name": "RelatedNodeInfo"}}, "text": "Parameter Style Guide\n\nIt\u2019s important to write clear names and descriptions when you define parameters in your protocols. Clarity improves the user experience for the technicians who run your protocols. They rely on your parameter names and descriptions to understand how the robot will function when running your protocol.\n\nAdopting the advice of this guide will help make your protocols clear, consistent, and ultimately easy to use. It also aligns them with protocols in the Opentrons Protocol Library, which can help others access and replicate your science.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 564, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9db76110-8d6d-4a95-9577-2aa0cc178cf7": {"__data__": {"id_": "9db76110-8d6d-4a95-9577-2aa0cc178cf7", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a8b9a87d-c8c2-48bb-8c79-a7e914af3279", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "cb324d099071be2155869275417aa321741c48f9b63805286b8c12d57815ea02", "class_name": "RelatedNodeInfo"}}, "text": "General Guidance\n\n**Parameter names are nouns.** Parameters should be discrete enough that you can describe them in a single word or short noun phrase. `display_name` is limited to 30 characters, and you can add more context in the description.\n\nDon\u2019t ask questions or put other sentence punctuation in parameter names. For example:\n\n| \u2705 Dry run           | \u274c Dry run?                      |\n| -------------------- | -------------------------------- |\n| \u2705 Sample count      | \u274c How many samples?             |\n| \u2705 Number of samples | \u274c Number of samples to process. |\n\n**Parameter descriptions explain actions.** In one or two clauses or sentences, state when and how the parameter value is used in the protocol. Don\u2019t merely restate the parameter name.\n\nPunctuate descriptions as sentences, even if they aren\u2019t complete sentences. For example:\n\n| Parameter name  | Parameter description                                                                                                                         |\n| --------------- | --------------------------------------------------------------------------------------------------------------------------------------------- |\n| Dry run         | _ \u2705 Skip incubation delays and shorten mix steps. _ \u274c Whether to do a dry run.                                                              |\n| Aspirate volume | _ \u2705 How much to aspirate from each sample. _ \u274c Volume that the pipette will aspirate                                                        |\n| Dilution factor | _ \u2705 Each step uses this ratio of total liquid to original solution. Express the ratio as a decimal. _ \u274c total/diluent ratio for the process |\n\nNot every parameter requires a description! For example, in a protocol that uses only one pipette, it would be difficult to explain a parameter named \u201cPipette type\u201d without repeating yourself. In a protocol that offers parameters for two different pipettes, it may be useful to summarize what steps each pipette performs.\n\n**Use sentence case for readability**. Sentence case means adding a capital letter to _only_ the first word of the name and description. This gives your parameters a professional appearance. Keep proper names capitalized as they would be elsewhere in a sentence. For example:\n\n| \u2705 Number of samples       | \u274c number of samples       |\n| -------------------------- | -------------------------- |\n| \u2705 Temperature Module slot | \u274c Temperature module slot |\n| \u2705 Dilution factor         | \u274c Dilution Factor         |\n\n**Use numerals for all numbers.** In a scientific context, this includes single\\-digit numbers. Additionally, punctuate numbers according to the needs of your protocol\u2019s users. If you plan to share your protocol widely, consider using American English number punctuation (comma for thousands separator; period for decimal separator).\n\n**Order choices logically.** Place items within the `choices` attribute in the order that makes sense for your application.\n\nNumeric choices should either ascend or descend. Consider an offset parameter with choices. Sorting according to value is easy to use in either direction, but sorting by absolute value is difficult:\n\n| \u2705 \\-3, \\-2, \\-1, 0, 1, 2, 3 | \u274c 0, 1, \\-1, 2, \\-2, 3, \\-3 |\n| ---------------------------- | ---------------------------- |\n| \u2705 3, 2, 1, 0, \\-1, \\-2, \\-3 |                              |\n\nString choices may have an intrinsic ordering. If they don\u2019t, fall back to alphabetical order.\n\n| Parameter name | Parameter description                                                                       |\n| -------------- | ------------------------------------------------------------------------------------------- |\n| Liquid color   | _ \u2705 Red, Orange, Yellow, Green, Blue, Violet _ \u274c Blue, Green, Orange, Red, Violet, Yellow |\n| Tube brand     | _ \u2705 Eppendorf, Falcon, Generic, NEST _ \u274c Falcon, NEST, Eppendorf, Generic                 |", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 3891, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "65c8408d-f050-4ca4-8e98-8aa07163ca2e": {"__data__": {"id_": "65c8408d-f050-4ca4-8e98-8aa07163ca2e", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1c34a6ee-41fb-4374-bddc-50a460a096bd", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "9171e0eb52e05db814a877362e7ff4a950861fe4101526d631a6d85754343d69", "class_name": "RelatedNodeInfo"}}, "text": "Type\\-Specific Guidance", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 25, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e3cb6921-36b2-446b-9f44-ae0a4c18259d": {"__data__": {"id_": "e3cb6921-36b2-446b-9f44-ae0a4c18259d", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d7cd9798-cf09-4395-ad0c-405565c47cf3", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "a9961b7e2769c4fa95ed273702a4f668ec6293eb206d144c0681013d7e257749", "class_name": "RelatedNodeInfo"}}, "text": "Booleans\n\nThe `True` value of a Boolean corresponds to the word _On_ and the `False` value corresponds to the word _Off_.\n\n**Avoid double negatives.** These are difficult to understand and may lead to a technician making an incorrect choice. Remember that negation can be part of a word\u2019s meaning! For example, it\u2019s difficult to reason about what will happen when a parameter named \u201cDeactivate module\u201d is set to \u201cOff\u201d.\n\n**When in doubt, clarify in the description.** If you feel like you need to add extra clarity to your Boolean choices, use the phrase \u201cWhen on\u201d or \u201cWhen off\u201d at the beginning of your description. For example, a parameter named \u201cDry run\u201d could have the description \u201cWhen on, skip protocol delays and return tips instead of trashing them.\u201d", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 759, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "01bd11b6-0227-43fd-8602-e65d1d744483": {"__data__": {"id_": "01bd11b6-0227-43fd-8602-e65d1d744483", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "dac92a66-6742-42fa-9bc8-7aba5d6e50fe", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "42238beff82abdc00b85e2598350302a6b17edd7d2336ff59fa8aa56790ffec7", "class_name": "RelatedNodeInfo"}}, "text": "Number Choices\n\n**Don\u2019t repeat text in choices.** Rely on the name and description to indicate what the number refers to. It\u2019s OK to add units to the display names of numeric choices, because the `unit` attribute is ignored when you specify `choices`.\n\n| Parameter name    | Parameter description                                                                                                |\n| ----------------- | -------------------------------------------------------------------------------------------------------------------- |\n| Number of columns | _ \u2705 1, 2, 3 _ \u274c 1 column, 2 columns, 3 columns                                                                     |\n| Aspirate volume   | _ \u2705 10 \u00b5L, 20 \u00b5L, 50 \u00b5L _ \u2705 Low (10 \u00b5L), Medium (20 \u00b5L), High (50 \u00b5L) \\* \u274c Low volume, Medium volume, High volume |\n\n**Use a range instead of choices when all values are acceptable.** It\u2019s faster and easier to enter a numeric value than to choose from a long list. For example, a \u201cNumber of columns\u201d parameter that accepts any number 1 through 12 should specify a `minimum` and `maximum`, rather than `choices`. However, if the application requires that the parameter only accepts even numbers, you need to specify choices (2, 4, 6, 8, 10, 12\\).", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1243, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "de0c6866-6a44-4fa7-a7a5-ee1b0012029a": {"__data__": {"id_": "de0c6866-6a44-4fa7-a7a5-ee1b0012029a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c619de16-f76a-405a-b8f5-a3ffbd2dc920", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "fcf8d2f4ce0940c444787c836272ca05a04432b9d3bb76de523345c162fc9b27", "class_name": "RelatedNodeInfo"}}, "text": "Strings\n\n**Avoid strings that are synonymous with \u201cyes\u201d and \u201cno\u201d.** When presenting exactly two string choices, consider their meaning. Can they be rephrased in terms of \u201cyes/no\u201d, \u201ctrue/false\u201d, or \u201con/off\u201d? If no, then a string parameter is appropriate. If yes, it\u2019s better to use a Boolean, which appears in run setup as a toggle rather than a dropdown menu.\n\n> - \u2705 Blue, Red\n> - \u2705 Left\\-to\\-right, Right\\-to\\-left\n> - \u274c Include, Exclude\n> - \u274c Yes, No\n\nRuntime parameters let you define user\\-customizable variables in your Python protocols. This gives you greater flexibility and puts extra control in the hands of the technician running the protocol \u2014 without forcing them to switch between lots of protocol files or write code themselves.\n\nThis section begins with the fundamentals of runtime parameters:\n\n- Preliminary advice on how to choose good parameters, before you start writing code.\n- The syntax for defining parameters with boolean, numeric, and string values.\n- How to use parameter values in your protocol, building logic and API calls that implement the technician\u2019s choices.\n\nIt continues with a selection of use cases and some overall style guidance. When adding parameters, you are in charge of the user experience when it comes time to set up the protocol! These pages outline best practices for making your protocols reliable and easy to use.\n\n- Use case \u2013 sample count: Change behavior throughout a protocol based on how many samples you plan to process. Setting sample count exactly saves time, tips, and reagents.\n- Use case \u2013 dry run: Test your protocol, rather than perform a live run, just by flipping a toggle.\n- Style and usage: When you\u2019re a protocol author, you write code. When you\u2019re a parameter author, you write words. Follow this advice to make things as clear as possible for the technicians who will run your protocol.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1859, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4f10ff3c-7482-4bc9-a624-fc899e30e624": {"__data__": {"id_": "4f10ff3c-7482-4bc9-a624-fc899e30e624", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ba32a073-fa17-4a8c-a508-de75fbbeb558", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "027f62eb75349c967a58b395c4ee493d281b0fe658833234a5b8f504b5584121", "class_name": "RelatedNodeInfo"}}, "text": "Advanced Control\n\nAs its name implies, the Python Protocol API is primarily designed for creating protocols that you upload via the Opentrons App and execute on the robot as a unit. But sometimes it\u2019s more convenient to control the robot outside of the app. For example, you might want to have variables in your code that change based on user input or the contents of a CSV file. Or you might want to only execute part of your protocol at a time, especially when developing or debugging a new protocol.\n\nThe Python API offers two ways of issuing commands to the robot outside of the app: through Jupyter Notebook or on the command line with `opentrons_execute`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 663, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bdcedd02-6321-4aee-8c5c-0f55495e7891": {"__data__": {"id_": "bdcedd02-6321-4aee-8c5c-0f55495e7891", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "53f8a2c4-7e3e-4024-994f-05438c19456f", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "56b372e32ea7ae43d3d30fd38d30f9cd7116f2ec6627fdb3e87a295c9c2f1ad8", "class_name": "RelatedNodeInfo"}}, "text": "Jupyter Notebook\n\nThe Flex and OT\\-2 run Jupyter Notebook servers on port 48888, which you can connect to with your web browser. This is a convenient environment for writing and debugging protocols, since you can define different parts of your protocol in different notebook cells and run a single cell at a time.\n\nAccess your robot\u2019s Jupyter Notebook by either:\n\n- Going to the **Advanced** tab of Robot Settings and clicking **Launch Jupyter Notebook**.\n- Going directly to `http://:48888` in your web browser (if you know your robot\u2019s IP address).\n\nOnce you\u2019ve launched Jupyter Notebook, you can create a notebook file or edit an existing one. These notebook files are stored on the the robot. If you want to save code from a notebook to your computer, go to **File \\> Download As** in the notebook interface.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 814, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "04d8a208-e98b-4ecb-9c7f-4b74a830cdef": {"__data__": {"id_": "04d8a208-e98b-4ecb-9c7f-4b74a830cdef", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c504291f-7c6d-44d7-9988-612a6d4258f9", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "2a8d86d9f6cd20a1028251b31008d8608de7f1e1ced9cf5f1e982389f6a01b62", "class_name": "RelatedNodeInfo"}}, "text": "Protocol Structure\n\nJupyter Notebook is structured around cells: discrete chunks of code that can be run individually. This is nearly the opposite of Opentrons protocols, which bundle all commands into a single `run` function. Therefore, to take full advantage of Jupyter Notebook, you have to restructure your protocol.\n\nRather than writing a `run` function and embedding commands within it, start your notebook by importing `opentrons.execute` and calling `opentrons.execute.get_protocol_api()`. This function also replaces the `metadata` block of a standalone protocol by taking the minimum API version as its argument. Then you can call `ProtocolContext` methods in subsequent lines or cells:\n\n```\nimport opentrons.execute\nprotocol = opentrons.execute.get_protocol_api(\"2.19\")\nprotocol.home()\n\n```\n\nThe first command you execute should always be `home()`. If you try to execute other commands first, you will get a `MustHomeError`. (When running protocols through the Opentrons App, the robot homes automatically.)\n\nYou should use the same `ProtocolContext` throughout your notebook, unless you need to start over from the beginning of your protocol logic. In that case, call `get_protocol_api()` again to get a new `ProtocolContext`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1240, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "48b7809f-a0f3-462d-ba49-63a3cede58fe": {"__data__": {"id_": "48b7809f-a0f3-462d-ba49-63a3cede58fe", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2118b02b-9f5f-4dd7-9770-dadd54219e2c", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "5d38e432e8a74471890f22a5ae828bd44715e10e1ddd7be98451b53df38140ee", "class_name": "RelatedNodeInfo"}}, "text": "Running a Previously Written Protocol\n\nYou can also use Jupyter to run a protocol that you have already written. To do so, first copy the entire text of the protocol into a cell and run that cell:\n\n```\nimport opentrons.execute\nfrom opentrons import protocol_api\ndef run(protocol: protocol_api.ProtocolContext):\n    # the contents of your previously written protocol go here\n\n```\n\nSince a typical protocol only defines the `run` function but doesn\u2019t call it, this won\u2019t immediately cause the robot to move. To begin the run, instantiate a `ProtocolContext` and pass it to the `run` function you just defined:\n\n```\nprotocol = opentrons.execute.get_protocol_api(\"2.19\")\nrun(protocol)  # your protocol will now run\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 717, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3cd472fa-0cb2-4f47-9860-1b70b88253aa": {"__data__": {"id_": "3cd472fa-0cb2-4f47-9860-1b70b88253aa", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "79714208-495e-475b-82be-9cfb3eb94965", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "f261fd63a52dae72ed32e1ea0cce487c3000e0db4ae140e06a445f2aac8ff4c8", "class_name": "RelatedNodeInfo"}}, "text": "Setting Labware Offsets\n\nAll positions relative to labware are adjusted automatically based on labware offset data. When you\u2019re running your code in Jupyter Notebook or with `opentrons_execute`, you need to set your own offsets because you can\u2019t perform run setup and Labware Position Check in the Opentrons App or on the Flex touchscreen.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 341, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "649de324-ef4f-4f4f-815c-44528769a291": {"__data__": {"id_": "649de324-ef4f-4f4f-815c-44528769a291", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ec9808bd-3e73-4956-a1ac-0c8c8a442f16", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "665aede2ef3cb57443068dfb7b00ce75ce345181a7b084ecd53a41d0fed374b3", "class_name": "RelatedNodeInfo"}}, "text": "Creating a Dummy Protocol\n\nFor advanced control applications, do the following to calculate and apply labware offsets:\n\n> 1. Create a \u201cdummy\u201d protocol that loads your labware and has each used pipette pick up a tip from a tip rack.\n> 2. Import the dummy protocol to the Opentrons App.\n> 3. Run Labware Position Check from the app or touchscreen.\n> 4. Add the offsets to your code with `set_offset()`.\n\nCreating the dummy protocol requires you to:\n\n> 1. Use the `metadata` or `requirements` dictionary to specify the API version. (See Versioning for details.) Use the same API version as you did in `opentrons.execute.get_protocol_api()`.\n> 2. Define a `run()` function.\n> 3. Load all of your labware in their initial locations.\n> 4. Load your smallest capacity pipette and specify its `tip_racks`.\n> 5. Call `pick_up_tip()`. Labware Position Check can\u2019t run if you don\u2019t pick up a tip.\n\nFor example, the following dummy protocol will use a P300 Single\\-Channel GEN2 pipette to enable Labware Position Check for an OT\\-2 tip rack, NEST reservoir, and NEST flat well plate.\n\n```\nmetadata = {\"apiLevel\": \"2.13\"}\n\n def run(protocol):\n     tiprack = protocol.load_labware(\"opentrons_96_tiprack_300ul\", 1)\n     reservoir = protocol.load_labware(\"nest_12_reservoir_15ml\", 2)\n     plate = protocol.load_labware(\"nest_96_wellplate_200ul_flat\", 3)\n     p300 = protocol.load_instrument(\"p300_single_gen2\", \"left\", tip_racks=[tiprack])\n     p300.pick_up_tip()\n     p300.return_tip()\n\n```\n\nAfter importing this protocol to the Opentrons App, run Labware Position Check to get the x, y, and z offsets for the tip rack and labware. When complete, you can click **Get Labware Offset Data** to view automatically generated code that uses `set_offset()` to apply the offsets to each piece of labware.\n\n```\nlabware_1 = protocol.load_labware(\"opentrons_96_tiprack_300ul\", location=\"1\")\nlabware_1.set_offset(x=0.00, y=0.00, z=0.00)\n\nlabware_2 = protocol.load_labware(\"nest_12_reservoir_15ml\", location=\"2\")\nlabware_2.set_offset(x=0.10, y=0.20, z=0.30)\n\nlabware_3 = protocol.load_labware(\"nest_96_wellplate_200ul_flat\", location=\"3\")\nlabware_3.set_offset(x=0.10, y=0.20, z=0.30)\n\n```\n\nThis automatically generated code uses generic names for the loaded labware. If you want to match the labware names already in your protocol, change the labware names to match your original code:\n\n```\nreservoir = protocol.load_labware(\"nest_12_reservoir_15ml\", \"2\")\nreservoir.set_offset(x=0.10, y=0.20, z=0.30)\n\n```\n\nNew in version 2\\.12\\.\n\nOnce you\u2019ve executed this code in Jupyter Notebook, all subsequent positional calculations for this reservoir in slot 2 will be adjusted 0\\.1 mm to the right, 0\\.2 mm to the back, and 0\\.3 mm up.\n\nKeep in mind that `set_offset()` commands will override any labware offsets set by running Labware Position Check in the Opentrons App. And you should follow the behavior of Labware Position Check, i.e., _do not_ reuse offset measurements unless they apply to the _same labware type_ in the _same deck slot_ on the _same robot_.\n\nWarning\n\nImproperly reusing offset data may cause your robot to move to an unexpected position or crash against labware, which can lead to incorrect protocol execution or damage your equipment. When in doubt: run Labware Position Check again and update your code!", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 3296, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "78064cf5-b52a-4edd-9eee-8b82841a7f73": {"__data__": {"id_": "78064cf5-b52a-4edd-9eee-8b82841a7f73", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6a35332e-c12b-4487-89cd-76da8b0f779b", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "667d6be65647c5c50031838cb0f9cb05e8e3cb50f0d937791eefcf3f5c3d3529", "class_name": "RelatedNodeInfo"}}, "text": "Labware Offset Behavior\n\nHow the API applies labware offsets varies depending on the API level of your protocol. This section describes the latest behavior. For details on how offsets work in earlier API versions, see the API reference entry for `set_offset()`.\n\nIn the latest API version, offsets apply to labware type\u2013location combinations. For example, if you use `set_offset()` on a tip rack, use all the tips, and replace the rack with a fresh one of the same type in the same location, the offsets will apply to the fresh tip rack:\n\n```\ntiprack = protocol.load_labware(\n    load_name=\"opentrons_flex_96_tiprack_1000ul\", location=\"D3\"\n)\ntiprack2 = protocol.load_labware(\n    load_name=\"opentrons_flex_96_tiprack_1000ul\",\n    location=protocol_api.OFF_DECK,\n)\ntiprack.set_offset(x=0.1, y=0.1, z=0.1)\nprotocol.move_labware(\n    labware=tiprack, new_location=protocol_api.OFF_DECK\n)  # tiprack has no offset while off-deck\nprotocol.move_labware(\n    labware=tiprack2, new_location=\"D3\"\n)  # tiprack2 now has offset 0.1, 0.1, 0.1\n\n```\n\nBecause offsets apply to combinations of labware type and location, if you want an offset to apply to a piece of labware as it moves around the deck, call `set_offset()` again after each movement:\n\n```\nplate = protocol.load_labware(\n    load_name=\"corning_96_wellplate_360ul_flat\", location=\"D2\"\n)\nplate.set_offset(\n    x=-0.1, y=-0.2, z=-0.3\n)  # plate now has offset -0.1, -0.2, -0.3\nprotocol.move_labware(\n    labware=plate, new_location=\"D3\"\n)  # plate now has offset 0, 0, 0\nplate.set_offset(\n    x=-0.1, y=-0.2, z=-0.3\n)  # plate again has offset -0.1, -0.2, -0.3\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1613, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1d1fdcf4-00b9-4f7d-9638-c49924ef9e6f": {"__data__": {"id_": "1d1fdcf4-00b9-4f7d-9638-c49924ef9e6f", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1f82455d-8268-49b3-857e-ddabce1c25f3", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "8e66f27e73f8b637313be3cd621b75827c531be4b76a805e53b9c2bd9674ec52", "class_name": "RelatedNodeInfo"}}, "text": "Using Custom Labware\n\nIf you have custom labware definitions you want to use with Jupyter, make a new directory called `labware` in Jupyter and put the definitions there. These definitions will be available when you call `load_labware()`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 240, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ff1d1173-ef6f-4ce4-81fa-9ad5396ac4e9": {"__data__": {"id_": "ff1d1173-ef6f-4ce4-81fa-9ad5396ac4e9", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6c29536f-9969-4ac8-bac4-763b731a23dc", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "70fe88d6d5b8bc08110d6bdb3050437c1aa461803a80ecd5d411fe2e7c29ddca", "class_name": "RelatedNodeInfo"}}, "text": "Using Modules\n\nIf your protocol uses modules, you need to take additional steps to make sure that Jupyter Notebook doesn\u2019t send commands that conflict with the robot server. Sending commands to modules while the robot server is running will likely cause errors, and the module commands may not execute as expected.\n\nTo disable the robot server, open a Jupyter terminal session by going to **New \\> Terminal** and run `systemctl stop opentrons-robot-server`. Then you can run code from cells in your notebook as usual. When you are done using Jupyter Notebook, you should restart the robot server with `systemctl start opentrons-robot-server`.\n\nNote\n\nWhile the robot server is stopped, the robot will display as unavailable in the Opentrons App. If you need to control the robot or its attached modules through the app, you need to restart the robot server and wait for the robot to appear as available in the app.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 915, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7aadc5f9-ced8-475a-875a-a1a75899e994": {"__data__": {"id_": "7aadc5f9-ced8-475a-875a-a1a75899e994", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "506d8c87-e9c3-44ca-8327-d43785ff89cb", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "629a444c3bce07deddf219feb4459d88fae5b77557c8796e7f98547ff5851f64", "class_name": "RelatedNodeInfo"}}, "text": "Command Line\n\nThe robot\u2019s command line is accessible either by going to **New \\> Terminal** in Jupyter or via SSH.\n\nTo execute a protocol from the robot\u2019s command line, copy the protocol file to the robot with `scp` and then run the protocol with `opentrons_execute`:\n\n```\nopentrons_execute /data/my_protocol.py\n\n```\n\nBy default, `opentrons_execute` will print out the same run log shown in the Opentrons App, as the protocol executes. It also prints out internal logs at the level `warning` or above. Both of these behaviors can be changed. Run `opentrons_execute --help` for more information.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 596, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "27184572-28ce-4cef-9ede-e62d8421666f": {"__data__": {"id_": "27184572-28ce-4cef-9ede-e62d8421666f", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e86330df-b5ff-4404-83f7-a532df4a699b", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "2cf27147274a87374275273e477f02fc94b3f2fc77aa1a3200008cec8d392d64", "class_name": "RelatedNodeInfo"}}, "text": "Protocol Examples\n\nThis page provides simple, ready\\-made protocols for Flex and OT\\-2\\. Feel free to copy and modify these examples to create unique protocols that help automate your laboratory workflows. Also, experimenting with these protocols is another way to build upon the skills you\u2019ve learned from working through the tutorial. Try adding different hardware, labware, and commands to a sample protocol and test its validity after importing it into the Opentrons App.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 477, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "1f2df2b3-3b51-4e01-b2f1-202e5533caca": {"__data__": {"id_": "1f2df2b3-3b51-4e01-b2f1-202e5533caca", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "93744a9c-4c8e-4e45-9656-52c8de55e605", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "352a026f5b538d5b1baefb40b6146189621816f76885bc8c711d4c6d5eb6e6dc", "class_name": "RelatedNodeInfo"}}, "text": "Using These Protocols\n\nThese sample protocols are designed for anyone using an Opentrons Flex or OT\\-2 liquid handling robot. For our users with little to no Python experience, we\u2019ve taken some liberties with the syntax and structure of the code to make it easier to understand. For example, we\u2019ve formatted the samples with line breaks to show method arguments clearly and to avoid horizontal scrolling. Additionally, the methods use named arguments instead of positional arguments. For example:\n\n```\n# This code uses named arguments\ntiprack_1 = protocol.load_labware(\n    load_name=\"opentrons_flex_96_tiprack_200ul\",\n    location=\"D2\")\n\n# This code uses positional arguments\ntiprack_1 = protocol.load_labware(\"opentrons_flex_96_tiprack_200ul\", \"D2\")\n\n```\n\nBoth examples instantiate the variable `tiprack_1` with a Flex tip rack, but the former is more explicit. It shows the parameter name and its value together (e.g. `location=\"D2\"`), which may be helpful when you\u2019re unsure about what\u2019s going on in a protocol code sample.\n\nPython developers with more experience should feel free to ignore the code styling used here and work with these examples as you like.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1165, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "e1ec47fd-eb6e-4dfb-b1c2-04372c1e62a1": {"__data__": {"id_": "e1ec47fd-eb6e-4dfb-b1c2-04372c1e62a1", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9b5fa849-f425-4f79-b3e3-398d7afaaad9", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "48588b363fc65c7cdaa575b46286fbeb0b70e863cf5c6b4917027d7f71f84745", "class_name": "RelatedNodeInfo"}}, "text": "Instruments and Labware\n\nThe sample protocols all use the following pipettes:\n\n- Flex 1\\-Channel Pipette (5\u20131000 \u00b5L). The API load name for this pipette is `flex_1channel_1000`.\n- P300 Single\\-Channel GEN2 pipette for the OT\\-2\\. The API load name for this pipette is `p300_single_gen2`.\n\nThey also use the labware listed below:\n\n| Labware type   | Labware name                            | API load name                     |\n| -------------- | --------------------------------------- | --------------------------------- |\n| Reservoir      | USA Scientific 12\\-Well Reservoir 22 mL | `usascientific_12_reservoir_22ml` |\n| Well plate     | Corning 96\\-Well Plate 360 \u00b5L Flat      | `corning_96_wellplate_360ul_flat` |\n| Flex tip rack  | Opentrons Flex 96 Tip Rack 200 \u00b5L       | `opentrons_flex_96_tiprack_200ul` |\n| OT\\-2 tip rack | Opentrons 96 Tip Rack 300 \u00b5L            | `opentrons_96_tiprack_300ul`      |", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 913, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "516841c3-b9bb-452a-b495-eef19628220b": {"__data__": {"id_": "516841c3-b9bb-452a-b495-eef19628220b", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a65e5de8-a726-46de-97d1-d345af0493a5", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "80f8c3b98c9f23b102d9f345d856abbbed952a7e4b65b0b9f43a3e5af3191b6c", "class_name": "RelatedNodeInfo"}}, "text": "Protocol Template\n\nThis code only loads the instruments and labware listed above, and performs no other actions. Many code snippets from elsewhere in the documentation will run without modification when added at the bottom of this template. You can also use it to start writing and testing your own code.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 306, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f63dde7b-d7c0-4369-a891-21770d563e50": {"__data__": {"id_": "f63dde7b-d7c0-4369-a891-21770d563e50", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "2eac5e37-3290-42aa-afea-3f7b49c5c4ef", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "9991892d2129766f2a53a15443af2bf2a8819bfbffddb1a02075d4283bc86f4a", "class_name": "RelatedNodeInfo"}}, "text": "Flex\n\n```\nfrom opentrons import protocol_api\n\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    # load tip rack in deck slot D3\n    tiprack = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_1000ul\", location=\"D3\"\n    )\n    # attach pipette to left mount\n    pipette = protocol.load_instrument(\n        instrument_name=\"flex_1channel_1000\",\n        mount=\"left\",\n        tip_racks=[tiprack]\n    )\n    # load well plate in deck slot D2\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\", location=\"D2\"\n    )\n    # load reservoir in deck slot D1\n    reservoir = protocol.load_labware(\n        load_name=\"usascientific_12_reservoir_22ml\", location=\"D1\"\n    )\n    # load trash bin in deck slot A3\n    trash = protocol.load_trash_bin(location=\"A3\")\n    # Put protocol commands here\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 899, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "2670e9bd-ad8f-401a-ad59-f7a03c799c99": {"__data__": {"id_": "2670e9bd-ad8f-401a-ad59-f7a03c799c99", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1b37e028-4d89-4dc9-acda-2c74831dfb45", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "2c48e2e8fcffec25a5daa9594ac2be269fbddae1e59103a374f15b9e9a7a195a", "class_name": "RelatedNodeInfo"}}, "text": "OT-2\n\n```\nfrom opentrons import protocol_api\n\nmetadata = {\"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    # load tip rack in deck slot 3\n    tiprack = protocol.load_labware(\n        load_name=\"opentrons_96_tiprack_300ul\", location=3\n    )\n    # attach pipette to left mount\n    pipette = protocol.load_instrument(\n        instrument_name=\"p300_single_gen2\",\n        mount=\"left\",\n        tip_racks=[tiprack]\n    )\n    # load well plate in deck slot 2\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\", location=2\n    )\n    # load reservoir in deck slot 1\n    reservoir = protocol.load_labware(\n        load_name=\"usascientific_12_reservoir_22ml\", location=1\n    )\n    # Put protocol commands here\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 766, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "cf8fc020-01e6-4470-b1db-70012eb2f822": {"__data__": {"id_": "cf8fc020-01e6-4470-b1db-70012eb2f822", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6fbcc5a1-f232-4cc2-829a-ceec375b222e", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "17bc8cd3c65579eb5307ffaf2910dbf62e0ae7d0e2497e9dd83dd0a7475cbd69", "class_name": "RelatedNodeInfo"}}, "text": "Transferring Liquids\n\nThese protocols demonstrate how to move 100 \u00b5L of liquid from one well to another.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 106, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bac0b557-4d29-45e4-9b97-7eb3d94059c6": {"__data__": {"id_": "bac0b557-4d29-45e4-9b97-7eb3d94059c6", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "1d433be7-3fee-40ad-9096-0cd30d082d5b", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "7303613d6c4c235a2844ee5609b017cc8552d932c4bb38df4b34c431a31989fe", "class_name": "RelatedNodeInfo"}}, "text": "Basic Method\n\nThis protocol uses some building block commands to tell the robot, explicitly, where to go to aspirate and dispense liquid. These commands include the `pick_up_tip()`, `aspirate()`, and `dispense()` methods.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 223, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "c4ccbd8d-84b6-47e6-8d29-6f09d42e5c60": {"__data__": {"id_": "c4ccbd8d-84b6-47e6-8d29-6f09d42e5c60", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "3c19b45c-0bb6-41a7-a513-2779f900200d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "d82da1b38f60be153fb779ed9ec70ee6e0c3ce591433c11aa25f7c73bdf70933", "class_name": "RelatedNodeInfo"}}, "text": "Flex\n\n```\nfrom opentrons import protocol_api\n\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\":\"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\",\n        location=\"D1\")\n    tiprack_1 = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_200ul\",\n        location=\"D2\")\n    trash = protocol.load_trash_bin(\"A3\")\n    pipette = protocol.load_instrument(\n        instrument_name=\"flex_1channel_1000\",\n        mount=\"left\",\n    tip_racks=[tiprack_1])\n\n    pipette.pick_up_tip()\n    pipette.aspirate(100, plate[\"A1\"])\n    pipette.dispense(100, plate[\"B1\"])\n    pipette.drop_tip()\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 689, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "15b3a0e9-c626-4ce0-a150-dc56e8976957": {"__data__": {"id_": "15b3a0e9-c626-4ce0-a150-dc56e8976957", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bd4dfd55-fd52-4ad4-8f18-cd0eb92628bc", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "2972c876d4b380d79f4f1faffb8092ba13210d2d120e12ca15166542be994908", "class_name": "RelatedNodeInfo"}}, "text": "OT-2\n\n```\nfrom opentrons import protocol_api\n\nmetadata = {\"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\",\n        location=1)\n    tiprack_1 = protocol.load_labware(\n            load_name=\"opentrons_96_tiprack_300ul\",\n            location=2)\n    p300 = protocol.load_instrument(\n            instrument_name=\"p300_single\",\n            mount=\"left\",\n            tip_racks=[tiprack_1])\n\n    p300.pick_up_tip()\n    p300.aspirate(100, plate[\"A1\"])\n    p300.dispense(100, plate[\"B1\"])\n    p300.drop_tip()\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 614, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "11b2fb3b-e597-4181-8ca3-65b93e3a1b8d": {"__data__": {"id_": "11b2fb3b-e597-4181-8ca3-65b93e3a1b8d", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a65c6650-1424-4f55-aa5c-4fd7d807d0d0", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "648634bd86b6fd20fbf7ff8ce305ebf3c0e4b5f7c2e89b365027d200b6aac893", "class_name": "RelatedNodeInfo"}}, "text": "Advanced Method\n\nThis protocol accomplishes the same thing as the previous example, but does it a little more efficiently. Notice how it uses the `InstrumentContext.transfer()` method to move liquid between well plates. The source and destination well arguments (e.g., `plate[\"A1\"], plate[\"B1\"]`) are part of `transfer()` method parameters. You don\u2019t need separate calls to `aspirate` or `dispense` here.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 406, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8316afb5-7e18-42ba-b4b5-ece619876d13": {"__data__": {"id_": "8316afb5-7e18-42ba-b4b5-ece619876d13", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ca0210a6-bad3-4baa-9c51-0358f67c1f53", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "2ac7b2341f60a70485701f647218b252f21959e20a09096358f92cf530f88dd7", "class_name": "RelatedNodeInfo"}}, "text": "Flex\n\n```\nfrom opentrons import protocol_api\n\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\",\n        location=\"D1\")\n    tiprack_1 = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_200ul\",\n        location=\"D2\")\n    trash = protocol.load_trash_bin(\"A3\")\n    pipette = protocol.load_instrument(\n        instrument_name=\"flex_1channel_1000\",\n        mount=\"left\",\n        tip_racks=[tiprack_1])\n    # transfer 100 \u00b5L from well A1 to well B1\n    pipette.transfer(100, plate[\"A1\"], plate[\"B1\"])\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 664, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3ff58683-b241-4204-9422-74ca76500024": {"__data__": {"id_": "3ff58683-b241-4204-9422-74ca76500024", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "612883d9-9db4-48e7-9fac-2123087fa821", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "be1bb97b4ec9d7cbad8b841ff08a5c889061213dbab3e667cffa2a2d22f6ca71", "class_name": "RelatedNodeInfo"}}, "text": "OT-2\n\n```\nfrom opentrons import protocol_api\n\nmetadata = {\"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\",\n        location=1)\n    tiprack_1 = protocol.load_labware(\n            load_name=\"opentrons_96_tiprack_300ul\",\n            location=2)\n    p300 = protocol.load_instrument(\n        instrument_name=\"p300_single\",\n        mount=\"left\",\n        tip_racks=[tiprack_1])\n    # transfer 100 \u00b5L from well A1 to well B1\n    p300.transfer(100, plate[\"A1\"], plate[\"B1\"])\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 581, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "26cac643-4e3f-40af-b6b3-198bf928e613": {"__data__": {"id_": "26cac643-4e3f-40af-b6b3-198bf928e613", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bb180876-b6e2-43a5-bcd4-0a64793d24f9", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "505979c28cd88823456e526720f594add108f2fe7667fc05fd20ca47bafece6d", "class_name": "RelatedNodeInfo"}}, "text": "Loops\n\nIn Python, a loop is an instruction that keeps repeating an action until a specific condition is met.\n\nWhen used in a protocol, loops automate repetitive steps such as aspirating and dispensing liquids from a reservoir to a a range of wells, or all the wells, in a well plate. For example, this code sample loops through the numbers 0 to 7, and uses the loop\u2019s current value to transfer liquid from all the wells in a reservoir to all the wells in a 96\\-well plate.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 474, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f8190573-17a2-4f48-96f5-e9de24a468a3": {"__data__": {"id_": "f8190573-17a2-4f48-96f5-e9de24a468a3", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c624a7a2-6d17-4bc8-b14b-41fdb271454b", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "b22f3007c2e407df634f7fe8537d1d5cb2257c58fd9cbf5196403aca280d2753", "class_name": "RelatedNodeInfo"}}, "text": "Flex\n\n```\nfrom opentrons import protocol_api\n\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\":\"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\",\n        location=\"D1\")\n    tiprack_1 = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_200ul\",\n        location=\"D2\")\n    reservoir = protocol.load_labware(\n        load_name=\"usascientific_12_reservoir_22ml\",\n        location=\"D3\")\n    trash = protocol.load_trash_bin(\"A3\")\n    pipette = protocol.load_instrument(\n        instrument_name=\"flex_1channel_1000\",\n        mount=\"left\",\n        tip_racks=[tiprack_1])\n\n    # distribute 20 \u00b5L from reservoir:A1 -> plate:row:1\n    # distribute 20 \u00b5L from reservoir:A2 -> plate:row:2\n    # etc...\n    # range() starts at 0 and stops before 8, creating a range of 0-7\n    for i in range(8):\n        pipette.distribute(200, reservoir.wells()[i], plate.rows()[i])\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 970, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3a9a2c52-c8f7-4d5e-8604-e2108925bcfe": {"__data__": {"id_": "3a9a2c52-c8f7-4d5e-8604-e2108925bcfe", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bc0eff0a-682f-40a9-8944-28d0548166ef", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "26211da61e240278afa0d45a5ae21c6426204a86df75f303455b581acab33e00", "class_name": "RelatedNodeInfo"}}, "text": "OT-2\n\n```\nfrom opentrons import protocol_api\n\nmetadata = {\"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\",\n        location=1)\n    tiprack_1 = protocol.load_labware(\n        load_name=\"opentrons_96_tiprack_300ul\",\n        location=2)\n    reservoir = protocol.load_labware(\n        load_name=\"usascientific_12_reservoir_22ml\",\n        location=4)\n    p300 = protocol.load_instrument(\n        instrument_name=\"p300_single\",\n        mount=\"left\",\n        tip_racks=[tiprack_1])\n\n    # distribute 20 \u00b5L from reservoir:A1 -> plate:row:1\n    # distribute 20 \u00b5L from reservoir:A2 -> plate:row:2\n    # etc...\n    # range() starts at 0 and stops before 8, creating a range of 0-7\n    for i in range(8):\n        p300.distribute(200, reservoir.wells()[i], plate.rows()[i])\n\n```\n\nNotice here how Python\u2019s `range`') class (e.g., `range(8)`) determines how many times the code loops. Also, in Python, a range of numbers is _exclusive_ of the end value and counting starts at 0, not 1\\. For the Corning 96\\-well plate used here, this means well A1\\=0, B1\\=1, C1\\=2, and so on to the last well in the row, which is H1\\=7\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1217, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "391b30a4-a5c6-43ee-af92-3c4d3ffa9738": {"__data__": {"id_": "391b30a4-a5c6-43ee-af92-3c4d3ffa9738", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8babc670-40c0-456e-a794-1e2adf262c9a", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "c073be412cbdb16d94011a7ecd477ce7eab14baa79441326e731c2277457e673", "class_name": "RelatedNodeInfo"}}, "text": "Multiple Air Gaps\n\nOpentrons electronic pipettes can do some things that a human cannot do with a pipette, like accurately alternate between liquid and air aspirations that create gaps within the same tip. The protocol shown below shows you how to aspirate from the first five wells in the reservoir and create an air gap between each sample.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 344, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "0dbde4c6-cc9a-4a2f-83d6-35a3602cd3bb": {"__data__": {"id_": "0dbde4c6-cc9a-4a2f-83d6-35a3602cd3bb", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "164a7700-9271-4c3d-8044-44e3699e41d0", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "5ab85e5013180f48749accce02705747f6ba34ee0581413ea04df0ac269c240c", "class_name": "RelatedNodeInfo"}}, "text": "Flex\n\n```\nfrom opentrons import protocol_api\n\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\":\"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\",\n        location=\"D1\")\n    tiprack_1 = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_1000ul\",\n        location=\"D2\")\n    reservoir = protocol.load_labware(\n        load_name=\"usascientific_12_reservoir_22ml\",\n        location=\"D3\")\n    trash = protocol.load_trash_bin(\"A3\")\n    pipette = protocol.load_instrument(\n        instrument_name=\"flex_1channel_1000\",\n        mount=\"left\",\n        tip_racks=[tiprack_1])\n\n    pipette.pick_up_tip()\n\n    # aspirate from the first 5 wells\n    for well in reservoir.wells()[:5]:\n        pipette.aspirate(volume=35, location=well)\n        pipette.air_gap(10)\n\n    pipette.dispense(225, plate[\"A1\"])\n\n    pipette.return_tip()\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 931, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5672b081-5c8e-4df8-8072-0c57e5c54aa9": {"__data__": {"id_": "5672b081-5c8e-4df8-8072-0c57e5c54aa9", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "d724225e-4bc5-47dd-9c3b-2dc28ed0a986", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "91960ef6d07120503cfe8a227bcb6dfff24705cd5c13d75972c5eb1b4c0879cc", "class_name": "RelatedNodeInfo"}}, "text": "OT-2\n\n```\nfrom opentrons import protocol_api\n\nmetadata = {\"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\",\n        location=1)\n    tiprack_1 = protocol.load_labware(\n        load_name=\"opentrons_96_tiprack_300ul\",\n        location=2)\n    reservoir = protocol.load_labware(\n        load_name=\"usascientific_12_reservoir_22ml\",\n        location=3)\n    p300 = protocol.load_instrument(\n        instrument_name=\"p300_single\",\n        mount=\"right\",\n        tip_racks=[tiprack_1])\n\n    p300.pick_up_tip()\n\n    # aspirate from the first 5 wells\n    for well in reservoir.wells()[:5]:\n        p300.aspirate(volume=35, location=well)\n        p300.air_gap(10)\n\n    p300.dispense(225, plate[\"A1\"])\n\n    p300.return_tip()\n\n```\n\nNotice here how Python\u2019s `slice`') functionality (in the code sample as `:5]`) lets us select the first five wells of the well plate only. Also, in Python, a range of numbers is _exclusive_ of the end value and counting starts at 0, not 1\\. For the USA Scientific 12\\-well reservoir used here, this means well A1\\=0, A2\\=1, A3\\=2, and so on to the last well used, which is A5\\=4\\. See also, the [Commands section of the Tutorial.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1257, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5051c91a-36b9-4537-bdeb-e45c056c8fdd": {"__data__": {"id_": "5051c91a-36b9-4537-bdeb-e45c056c8fdd", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f850c619-c7d4-4836-9993-fdebbdbc4e72", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "df668b41421590519955a4b79b472bf0d96cb5e5c8785346d425febc0eb20e5f", "class_name": "RelatedNodeInfo"}}, "text": "Dilution\n\nThis protocol dispenses diluent to all wells of a Corning 96\\-well plate. Next, it dilutes 8 samples from the reservoir across all 8 columns of the plate.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 166, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bb531fb7-0cfe-469f-b092-b69c85d2f79a": {"__data__": {"id_": "bb531fb7-0cfe-469f-b092-b69c85d2f79a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5447f475-1492-43a8-93d3-515de254e4b9", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "46be03f22e4af10a3cb37198365e5ec82f3fbd9d7dee1fcad8f3ead3496d4522", "class_name": "RelatedNodeInfo"}}, "text": "Flex\n\n```\nfrom opentrons import protocol_api\n\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\",\n        location=\"D1\")\n    tiprack_1 = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_200ul\",\n        location=\"D2\")\n    tiprack_2 = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_200ul\",\n        location=\"D3\")\n    reservoir = protocol.load_labware(\n        load_name=\"usascientific_12_reservoir_22ml\",\n        location=\"C1\")\n    trash = protocol.load_trash_bin(\"A3\")\n    pipette = protocol.load_instrument(\n        instrument_name=\"flex_1channel_1000\",\n        mount=\"left\",\n        tip_racks=[tiprack_1, tiprack_2])\n    # Dispense diluent\n    pipette.distribute(50, reservoir[\"A12\"], plate.wells())\n\n    # loop through each row\n    for i in range(8):\n        # save the source well and destination column to variables\n        source = reservoir.wells()[i]\n        row = plate.rows()[i]\n\n    # transfer 30 \u00b5L of source to first well in column\n    pipette.transfer(30, source, row[0], mix_after=(3, 25))\n\n    # dilute the sample down the column\n    pipette.transfer(\n        30, row[:11], row[1:],\n        mix_after=(3, 25))\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1314, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "471d678f-de01-4b01-9832-0d94cf7283f2": {"__data__": {"id_": "471d678f-de01-4b01-9832-0d94cf7283f2", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e50b4eae-c4b7-4d03-8794-6590c6f9515a", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "b7bb2015a5362e52e54857f3912642be2fea8b0120c7bc58f7ed3b344e9c7e52", "class_name": "RelatedNodeInfo"}}, "text": "OT-2\n\n```\nfrom opentrons import protocol_api\n\nmetadata = {\"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\",\n        location=1)\n    tiprack_1 = protocol.load_labware(\n        load_name=\"opentrons_96_tiprack_300ul\",\n        location=2)\n    tiprack_2 = protocol.load_labware(\n        load_name=\"opentrons_96_tiprack_300ul\",\n        location=3)\n    reservoir = protocol.load_labware(\n        load_name=\"usascientific_12_reservoir_22ml\",\n        location=4)\n    p300 = protocol.load_instrument(\n        instrument_name=\"p300_single\",\n        mount=\"right\",\n        tip_racks=[tiprack_1, tiprack_2])\n    # Dispense diluent\n    p300.distribute(50, reservoir[\"A12\"], plate.wells())\n\n    # loop through each row\n    for i in range(8):\n        # save the source well and destination column to variables\n        source = reservoir.wells()[i]\n        source = reservoir.wells()[i]\n        row = plate.rows()[i]\n\n    # transfer 30 \u00b5L of source to first well in column\n    p300.transfer(30, source, row[0], mix_after=(3, 25))\n\n    # dilute the sample down the column\n    p300.transfer(\n        30, row[:11], row[1:],\n        mix_after=(3, 25))\n\n```\n\nNotice here how the code sample loops through the rows and uses slicing to distribute the diluent. For information about these features, see the Loops and Air Gaps examples above. See also, the Commands section of the Tutorial.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1474, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "75e58b01-d49c-4871-b2e6-5becf95f2bc0": {"__data__": {"id_": "75e58b01-d49c-4871-b2e6-5becf95f2bc0", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "89c0f327-0181-4262-961c-712fa3bd3f5a", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "c16706256eddbcd6350b4b899bd86f3c5f83d2dee5e27c96816f791add2c838e", "class_name": "RelatedNodeInfo"}}, "text": "Plate Mapping\n\nThis protocol dispenses different volumes of liquids to a well plate and automatically refills the pipette when empty.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 135, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "35fd07d3-ad65-405c-a284-275b10b83ed6": {"__data__": {"id_": "35fd07d3-ad65-405c-a284-275b10b83ed6", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "bed8baab-41ea-443b-8c2a-2472e90c7933", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "dfb1f684c1f40c86a8c5b71c2d7126fc656877942234efa3913987c6f4d5804b", "class_name": "RelatedNodeInfo"}}, "text": "Flex\n\n```\nfrom opentrons import protocol_api\n\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\",\n        location=\"D1\")\n    tiprack_1 = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_200ul\",\n        location=\"D2\")\n    tiprack_2 = protocol.load_labware(\n        load_name=\"opentrons_flex_96_tiprack_200ul\",\n        location=\"D3\")\n    reservoir = protocol.load_labware(\n        load_name=\"usascientific_12_reservoir_22ml\",\n        location=\"C1\")\n    trash = protocol.load_trash_bin(\"A3\")\n    pipette = protocol.load_instrument(\n        instrument_name=\"flex_1channel_1000\",\n        mount=\"right\",\n    tip_racks=[tiprack_1, tiprack_2])\n\n    # Volume amounts are for demonstration purposes only\n    water_volumes = [\n        1,  2,  3,  4,  5,  6,  7,  8,\n        9,  10, 11, 12, 13, 14, 15, 16,\n        17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32,\n        33, 34, 35, 36, 37, 38, 39, 40,\n        41, 42, 43, 44, 45, 46, 47, 48,\n        49, 50, 51, 52, 53, 54, 55, 56,\n        57, 58, 59, 60, 61, 62, 63, 64,\n        65, 66, 67, 68, 69, 70, 71, 72,\n        73, 74, 75, 76, 77, 78, 79, 80,\n        81, 82, 83, 84, 85, 86, 87, 88,\n        89, 90, 91, 92, 93, 94, 95, 96\n        ]\n\n    pipette.distribute(water_volumes, reservoir[\"A12\"], plate.wells())\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1444, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "4d427609-7a63-4636-b86c-76727ebedf3f": {"__data__": {"id_": "4d427609-7a63-4636-b86c-76727ebedf3f", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "ed184b12-df96-457d-830a-cfbc3c39dc36", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "4281ea40d8e38724bd13c8d62b7a4170769c3efc76e406d02b8cd0e98afbebe6", "class_name": "RelatedNodeInfo"}}, "text": "OT-2\n\n```\nfrom opentrons import protocol_api\nmetadata = {\"apiLevel\": \"2.19\"}\n\ndef run(protocol: protocol_api.ProtocolContext):\n    plate = protocol.load_labware(\n        load_name=\"corning_96_wellplate_360ul_flat\",\n        location=1)\n    tiprack_1 = protocol.load_labware(\n        load_name=\"opentrons_96_tiprack_300ul\",\n        location=2)\n    tiprack_2 = protocol.load_labware(\n        load_name=\"opentrons_96_tiprack_300ul\",\n        location=3)\n    reservoir = protocol.load_labware(\n        load_name=\"usascientific_12_reservoir_22ml\",\n        location=4)\n    p300 = protocol.load_instrument(\n        instrument_name=\"p300_single\",\n        mount=\"right\",\n        tip_racks=[tiprack_1, tiprack_2])\n\n    # Volume amounts are for demonstration purposes only\n    water_volumes = [\n        1,  2,  3,  4,  5,  6,  7,  8,\n        9,  10, 11, 12, 13, 14, 15, 16,\n        17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32,\n        33, 34, 35, 36, 37, 38, 39, 40,\n        41, 42, 43, 44, 45, 46, 47, 48,\n        49, 50, 51, 52, 53, 54, 55, 56,\n        57, 58, 59, 60, 61, 62, 63, 64,\n        65, 66, 67, 68, 69, 70, 71, 72,\n        73, 74, 75, 76, 77, 78, 79, 80,\n        81, 82, 83, 84, 85, 86, 87, 88,\n        89, 90, 91, 92, 93, 94, 95, 96\n        ]\n\n    p300.distribute(water_volumes, reservoir[\"A12\"], plate.wells())\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1345, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "bac768a0-679a-4863-88d4-f7df15bfe00a": {"__data__": {"id_": "bac768a0-679a-4863-88d4-f7df15bfe00a", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "f9207ce3-2046-43ee-b074-875e1aec2213", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "98ab2b2f1bd46c4ec99f44ca9e3ec7dbedc74acb46b4aac631e1a5b578c00064", "class_name": "RelatedNodeInfo"}}, "text": "Adapting OT\\-2 Protocols for Flex\n\nPython protocols designed to run on the OT\\-2 can\u2019t be directly run on Flex without some modifications. This page describes the minimal steps that you need to take to get OT\\-2 protocols analyzing and running on Flex.\n\nAdapting a protocol for Flex lets you have parity across different Opentrons robots in your lab, or you can extend older protocols to take advantage of new features only available on Flex. Depending on your application, you may need to do additional verification of your adapted protocol.\n\nExamples on this page are in tabs so you can quickly move back and forth to see the differences between OT\\-2 and Flex code.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 670, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "13501c1a-267c-4298-ab95-9de3805ae756": {"__data__": {"id_": "13501c1a-267c-4298-ab95-9de3805ae756", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e195a8b7-9bd6-4243-b50e-99822347643e", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "457856840d75bef755c8347a51fcff3c718963336ae71207ef2610c556c14f78", "class_name": "RelatedNodeInfo"}}, "text": "Metadata and Requirements\n\nFlex requires you to specify an `apiLevel` of 2\\.15 or higher. If your OT\\-2 protocol specified `apiLevel` in the `metadata` dictionary, it\u2019s best to move it to the `requirements` dictionary. You can\u2019t specify it in both places, or the API will raise an error.\n\nNote\n\nConsult the list of changes in API versions to see what effect raising the `apiLevel` will have. If you increased it by multiple minor versions to get your protocol running on Flex, make sure that your protocol isn\u2019t using removed commands or commands whose behavior has changed in a way that may affect your scientific results.\n\nYou also need to specify `\"robotType\": \"Flex\"`. If you omit `robotType` in the `requirements` dictionary, the API will assume the protocol is designed for the OT\\-2\\.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 793, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d34e59b3-ec97-4a89-ace3-4c28022c21da": {"__data__": {"id_": "d34e59b3-ec97-4a89-ace3-4c28022c21da", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a79b72e8-af14-404f-ba34-9b8740f8428d", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "7e07fcb0a6703ea0b6eac3cb85c752a25369127c3a489fc5640949a1ac385dc8", "class_name": "RelatedNodeInfo"}}, "text": "Original OT-2 code\n\n```\nfrom opentrons import protocol_api\n\nmetadata = {\n    \"protocolName\": \"My Protocol\",\n    \"description\": \"This protocol uses the OT-2\",\n    \"apiLevel\": \"2.19\"\n}\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 189, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a4477c28-d91e-441f-88aa-102e447aaebd": {"__data__": {"id_": "a4477c28-d91e-441f-88aa-102e447aaebd", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6418bd1d-1814-45de-88d7-f307c2bd82ff", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "246e2b521a44c4ff9ec917194a4a8004ebdde2356db341c74861565d34002b64", "class_name": "RelatedNodeInfo"}}, "text": "Updated Flex code\n\n```\nfrom opentrons import protocol_api\n\nmetadata = {\n    \"protocolName\": \"My Protocol\",\n    \"description\": \"This protocol uses the Flex\",\n}\n\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\": \"2.19\"}\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 223, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "03c4a4c8-80e4-4412-83d5-0564106e9a74": {"__data__": {"id_": "03c4a4c8-80e4-4412-83d5-0564106e9a74", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "e2b5a1f2-ca1d-4174-bf53-0fbf97b69197", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "bebd3d321a1c5825113f6bfa8aaf33cf5215ecb0ac81b9db86b86d908b4cb6fa", "class_name": "RelatedNodeInfo"}}, "text": "Pipettes and Tip\\-rack Load Names\n\nFlex uses different types of pipettes and tip racks than OT\\-2, which have their own load names in the API. If possible, load Flex pipettes of the same capacity or larger than the OT\\-2 pipettes. See the list of pipette API load names for the valid values of `instrument_name` in Flex protocols. And check Labware Library or the Opentrons App for the load names of Flex tip racks.\n\nNote\n\nIf you use smaller capacity tips than in the OT\\-2 protocol, you may need to make further adjustments to avoid running out of tips. Also, the protocol may have more steps and take longer to execute.\n\nThis example converts OT\\-2 code that uses a P300 Single\\-Channel GEN2 pipette and 300 \u00b5L tips to Flex code that uses a Flex 1\\-Channel 1000 \u00b5L pipette and 1000 \u00b5L tips.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 794, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "f735b7d1-0aff-4c8f-8e09-9c2486cc4949": {"__data__": {"id_": "f735b7d1-0aff-4c8f-8e09-9c2486cc4949", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "25ce72e4-5cad-4303-9831-a1dbb3eb2339", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "bbf62110a5c2be4938f4235860c98775d6dbbe68052e95b68ebb23d41b19694b", "class_name": "RelatedNodeInfo"}}, "text": "Original OT-2 code\n\n```\ndef run(protocol: protocol_api.ProtocolContext):\n    tips = protocol.load_labware(\"opentrons_96_tiprack_300ul\", 1)\n    left_pipette = protocol.load_instrument(\n        \"p300_single_gen2\", \"left\", tip_racks=[tips]\n    )\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 249, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "7acb23d6-e401-47fa-a476-ff9aa5ba5200": {"__data__": {"id_": "7acb23d6-e401-47fa-a476-ff9aa5ba5200", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "8d9bfff5-1578-4007-b762-1832b4a0c23b", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "c236160797ede09cbe88fe7bc62afb62b43c427b1002969b33cf0cfd192cec48", "class_name": "RelatedNodeInfo"}}, "text": "Updated Flex code\n\n```\ndef run(protocol: protocol_api.ProtocolContext):\n    tips = protocol.load_labware(\"opentrons_flex_96_tiprack_1000ul\", \"D1\")\n    left_pipette = protocol.load_instrument(\n        \"flex_1channel_1000\", \"left\", tip_racks[tips]\n    )\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 258, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5505bba0-169e-45cf-88e0-7a09d74e92dc": {"__data__": {"id_": "5505bba0-169e-45cf-88e0-7a09d74e92dc", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "394a4f45-1d99-4702-9dc6-c9b89e15ec30", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ea3a6e9cefb9821cbf8bcde1cdf2c329b71f1106688569d1d974296c51064e4c", "class_name": "RelatedNodeInfo"}}, "text": "Trash Container\n\nOT\\-2 protocols always have a `fixed_trash` in slot 12\\. In Flex protocols specifying API version 2\\.16 or later, you need to load a trash bin. Put it in slot A3 to match the physical position of the OT\\-2 fixed trash:\n\n```\ntrash = protocol.load_trash_bin(\"A3\")\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 285, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "dab4f4c5-4e06-4d59-8e8b-22d8153ed292": {"__data__": {"id_": "dab4f4c5-4e06-4d59-8e8b-22d8153ed292", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "09c08890-5471-4e32-baa2-4ec0d3faf3f8", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "a10ebac3750a3bc48cee936055ab6dc4307d8962b63f8351ac46ec1bb4bb71d1", "class_name": "RelatedNodeInfo"}}, "text": "Deck Slot Labels\n\nIt\u2019s good practice to update numeric labels for deck slots (which match the labels on an OT\\-2\\) to coordinate ones (which match the labels on Flex). This is an optional step, since the two formats are interchangeable.\n\nFor example, the code in the previous section changed the location of the tip rack from `1` to `\"D1\"`.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 342, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d976907e-6a1e-4f20-a138-407dc66ea34c": {"__data__": {"id_": "d976907e-6a1e-4f20-a138-407dc66ea34c", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "fc26abac-1325-4bd1-af3b-2facd5b378f5", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "592f1c267b08cb8e6363db97eb5c0515d17d22f9dacee20167305da1f90337ce", "class_name": "RelatedNodeInfo"}}, "text": "Module Load Names\n\nIf your OT\\-2 protocol uses older generations of the Temperature Module or Thermocycler Module, update the load names you pass to `load_module()` to ones compatible with Flex:\n\n> - `temperature module gen2`\n> - `thermocycler module gen2` or `thermocyclerModuleV2`\n\nThe Heater\\-Shaker Module only has one generation, `heaterShakerModuleV1`, which is compatible with Flex and OT\\-2\\.\n\nThe Magnetic Module is not compatible with Flex. For protocols that load `magnetic module`, `magdeck`, or `magnetic module gen2`, you will need to make further modifications to use the Magnetic Block and Flex Gripper instead. This will require reworking some of your protocol steps, and you should verify that your new protocol design achieves similar results.\n\nThis simplified example, taken from a DNA extraction protocol, shows how using the Flex Gripper and the Magnetic Block can save time. Instead of pipetting an entire plate\u2019s worth of liquid from the Heater\\-Shaker to the Magnetic Module and then engaging the module, the gripper moves the plate to the Magnetic Block in one step.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1094, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "6857750c-2920-441f-86c6-11b2297886d1": {"__data__": {"id_": "6857750c-2920-441f-86c6-11b2297886d1", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "6aa69ebc-45f2-435e-bb1b-cad241b4fa23", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "b6a97c149411124adff4112d2eab3f20c01770ba645efd2fac71f44b3b2bc996", "class_name": "RelatedNodeInfo"}}, "text": "Original OT-2 code\n\n```\nhs_mod.set_and_wait_for_shake_speed(2000)\nprotocol.delay(minutes=5)\nhs_mod.deactivate_shaker()\n\nfor i in sample_plate.wells():\n    # mix, transfer, and blow-out all samples\n    pipette.pick_up_tip()\n    pipette.aspirate(100,hs_plate[i])\n    pipette.dispense(100,hs_plate[i])\n    pipette.aspirate(100,hs_plate[i])\n    pipette.air_gap(10)\n    pipette.dispense(pipette.current_volume,mag_plate[i])\n    pipette.aspirate(50,hs_plate[i])\n    pipette.air_gap(10)\n    pipette.dispense(pipette.current_volume,mag_plate[i])\n    pipette.blow_out(mag_plate[i].bottom(0.5))\n    pipette.drop_tip()\n\nmag_mod.engage()\n\n# perform elution steps\n\n```", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 657, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "9741e9f4-9cc0-4bca-867a-d61b7857ed14": {"__data__": {"id_": "9741e9f4-9cc0-4bca-867a-d61b7857ed14", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "c1abcc7f-2a36-4100-b728-fa8f385ba7dd", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "84a89956e0decf42c5a11a84bdfb30ce582ec5759c863cbc4306362808cd5a7f", "class_name": "RelatedNodeInfo"}}, "text": "Updated Flex code\n\n```\nhs_mod.set_and_wait_for_shake_speed(2000)\nprotocol.delay(minutes=5)\nhs_mod.deactivate_shaker()\n\n# move entire plate\n# no pipetting from Heater-Shaker needed\nhs_mod.open_labware_latch()\nprotocol.move_labware(sample_plate, mag_block, use_gripper=True)\n\n# perform elution steps\n\n```\n\nThe Opentrons Python Protocol API is a Python framework designed to make it easy to write automated biology lab protocols. Python protocols can control Opentrons Flex and OT\\-2 robots, their pipettes, and optional hardware modules. We\u2019ve designed the API to be accessible to anyone with basic Python and wet\\-lab skills.\n\nAs a bench scientist, you should be able to code your protocols in a way that reads like a lab notebook. You can write a fully functional protocol just by listing the equipment you\u2019ll use (modules, labware, and pipettes) and the exact sequence of movements the robot should make.\n\nAs a programmer, you can leverage the full power of Python for advanced automation in your protocols. Perform calculations, manage external data, use built\\-in and imported Python modules, and more to implement your custom lab workflow.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1145, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "a461165b-12a8-4cee-a663-10cc11edf05b": {"__data__": {"id_": "a461165b-12a8-4cee-a663-10cc11edf05b", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "a701e63b-aa68-4f04-bba9-c33ba763d6d5", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "d497f9565be1b01ab6a0d33499448e60f737de4ad5e543d8064bca0c93da1bfd", "class_name": "RelatedNodeInfo"}}, "text": "Getting Started\n\n**New to Python protocols?** Check out the Tutorial to learn about the different parts of a protocol file and build a working protocol from scratch.\n\nIf you want to **dive right into code**, take a look at our Protocol Examples and the comprehensive API Version 2 Reference.\n\nWhen you\u2019re ready to **try out a protocol**, download the Opentrons App, import the protocol file, and run it on your robot.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 419, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "ff97433b-069f-4fc9-96fd-581cb92c35d6": {"__data__": {"id_": "ff97433b-069f-4fc9-96fd-581cb92c35d6", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "420c3b95-a64c-4c5a-af4a-709f7826fc14", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "694f1ff009f923e5ad9244ec8c7aece7b1e1f81e1ae74153007c1be9989e6ce9", "class_name": "RelatedNodeInfo"}}, "text": "How the API Works\n\nThe design goal of this API is to make code readable and easy to understand. A protocol, in its most basic form:\n\n1. Provides some information about who made the protocol and what it is for.\n2. Specifies which type of robot the protocol should run on.\n3. Tells the robot where to find labware, pipettes, and (optionally) hardware modules.\n4. Commands the robot to manipulate its attached hardware.\n\nFor example, if we wanted to transfer liquid from well A1 to well B1 on a plate, our protocol would look like:", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 530, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "5930c6f6-c291-4ea8-9a73-fc52b471a514": {"__data__": {"id_": "5930c6f6-c291-4ea8-9a73-fc52b471a514", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "4751bee8-539f-4dfb-9718-f789534598d4", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "afa16fb37752f0695b254a16a652ba042e4f4787b5acaa7f283da2108aac367d", "class_name": "RelatedNodeInfo"}}, "text": "Flex\n\n```\nfrom opentrons import protocol_api\n\n# metadata\nmetadata = {\n    \"protocolName\": \"My Protocol\",\n    \"author\": \"Name \",\n    \"description\": \"Simple protocol to get started using the Flex\",\n}\n\n# requirements\nrequirements = {\"robotType\": \"Flex\", \"apiLevel\": \"2.19\"}\n\n# protocol run function\ndef run(protocol: protocol_api.ProtocolContext):\n    # labware\n    plate = protocol.load_labware(\n        \"corning_96_wellplate_360ul_flat\", location=\"D1\"\n    )\n    tiprack = protocol.load_labware(\n        \"opentrons_flex_96_tiprack_200ul\", location=\"D2\"\n    )\n    trash = protocol.load_trash_bin(location=\"A3\")\n\n    # pipettes\n    left_pipette = protocol.load_instrument(\n        \"flex_1channel_1000\", mount=\"left\", tip_racks=[tiprack]\n    )\n\n    # commands\n    left_pipette.pick_up_tip()\n    left_pipette.aspirate(100, plate[\"A1\"])\n    left_pipette.dispense(100, plate[\"B2\"])\n    left_pipette.drop_tip()\n\n```\n\nThis example proceeds completely linearly. Following it line\\-by\\-line, you can see that it has the following effects:\n\n1. Gives the name, contact information, and a brief description for the protocol.\n2. Indicates the protocol should run on a Flex robot, using API version 2\\.19\\.\n3. Tells the robot that there is:\n   1. A 96\\-well flat plate in slot D1\\.\n   2. A rack of 300 \u00b5L tips in slot D2\\.\n   3. A 1\\-channel 1000 \u00b5L pipette attached to the left mount, which should pick up tips from the aforementioned rack.\n4. Tells the robot to act by:\n   1. Picking up the first tip from the tip rack.\n   2. Aspirating 100 \u00b5L of liquid from well A1 of the plate.\n   3. Dispensing 100 \u00b5L of liquid into well B1 of the plate.\n   4. Dropping the tip in the trash.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1665, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "8dd7b702-dd79-4264-91d7-53db1277a4f9": {"__data__": {"id_": "8dd7b702-dd79-4264-91d7-53db1277a4f9", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "46eb1b61-a236-4070-b02d-965650d9309b", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "dfc1ef28727296b4709b22ade9da506fc64e08e41c2a1e2a68137100bc9741ba", "class_name": "RelatedNodeInfo"}}, "text": "OT-2\n\n```\nfrom opentrons import protocol_api\n\n# metadata\nmetadata = {\n    \"protocolName\": \"My Protocol\",\n    \"author\": \"Name \",\n    \"description\": \"Simple protocol to get started using the OT-2\",\n}\n\n# requirements\nrequirements = {\"robotType\": \"OT-2\", \"apiLevel\": \"2.19\"}\n\n# protocol run function\ndef run(protocol: protocol_api.ProtocolContext):\n    # labware\n    plate = protocol.load_labware(\n        \"corning_96_wellplate_360ul_flat\", location=\"1\"\n    )\n    tiprack = protocol.load_labware(\n        \"opentrons_96_tiprack_300ul\", location=\"2\"\n    )\n\n    # pipettes\n    left_pipette = protocol.load_instrument(\n        \"p300_single\", mount=\"left\", tip_racks=[tiprack]\n    )\n\n    # commands\n    left_pipette.pick_up_tip()\n    left_pipette.aspirate(100, plate[\"A1\"])\n    left_pipette.dispense(100, plate[\"B2\"])\n    left_pipette.drop_tip()\n\n```\n\nThis example proceeds completely linearly. Following it line\\-by\\-line, you can see that it has the following effects:\n\n1. Gives the name, contact information, and a brief description for the protocol.\n2. Indicates the protocol should run on an OT\\-2 robot, using API version 2\\.19\\.\n3. Tells the robot that there is:\n   1. A 96\\-well flat plate in slot 1\\.\n   2. A rack of 300 \u00b5L tips in slot 2\\.\n   3. A single\\-channel 300 \u00b5L pipette attached to the left mount, which should pick up tips from the aforementioned rack.\n4. Tells the robot to act by:\n   1. Picking up the first tip from the tip rack.\n   2. Aspirating 100 \u00b5L of liquid from well A1 of the plate.\n   3. Dispensing 100 \u00b5L of liquid into well B1 of the plate.\n   4. Dropping the tip in the trash.\n\nThere is much more that Opentrons robots and the API can do! The Building Block Commands, Complex Commands, and Hardware Modules pages cover many of these functions.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 1771, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "946b2634-b6a6-4898-af3d-c155f54d24ac": {"__data__": {"id_": "946b2634-b6a6-4898-af3d-c155f54d24ac", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "00cf25b1-8a6a-4f6f-a217-5e8331c3ff61", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "ef202bb9af34036977f34478c374f5c376e9dab4d568c62503a23cd1c83eb077", "class_name": "RelatedNodeInfo"}}, "text": "More Resources", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 16, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "01bbea0e-ff7d-46f2-b3cc-e525913a67f2": {"__data__": {"id_": "01bbea0e-ff7d-46f2-b3cc-e525913a67f2", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "7e5af48d-f5ff-4b60-b450-6aa543a5a171", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "8dec7dd4939e7a385eb3b873d0a6eaea80efb8840f3d573eb291f7945719d38c", "class_name": "RelatedNodeInfo"}}, "text": "Opentrons App\n\nThe Opentrons App is the easiest way to run your Python protocols. The app runs on the latest versions of macOS, Windows, and Ubuntu.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 150, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d9d5d2fa-8f23-46b9-9fec-319cf204711c": {"__data__": {"id_": "d9d5d2fa-8f23-46b9-9fec-319cf204711c", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "9a04f9f7-e932-4822-8df6-ee97d6abb2b8", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "9e1aab0d6b76eb42a4fad8832f2cf9139f6717d81ef118398ef30100c1022762", "class_name": "RelatedNodeInfo"}}, "text": "Support\n\nQuestions about setting up your robot, using Opentrons software, or troubleshooting? Check out our support articles or contact Opentrons Support directly.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 165, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "3d16b8e5-afbf-47e4-a085-a1c8ec2c2d56": {"__data__": {"id_": "3d16b8e5-afbf-47e4-a085-a1c8ec2c2d56", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "5847202a-71f8-44f2-abde-5792dcab65e9", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "e3cf12803d6123883eaa6a7f085c6ae5258295c9d7adfd5b2a7f8baca9b6c253", "class_name": "RelatedNodeInfo"}}, "text": "Custom Protocol Service\n\nDon\u2019t have the time or resources to write your own protocols? Our custom protocol development service can get you set up in two weeks.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 161, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}, "d59129b7-9f30-4524-906a-d141cfb4b90f": {"__data__": {"id_": "d59129b7-9f30-4524-906a-d141cfb4b90f", "embedding": null, "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "excluded_embed_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "excluded_llm_metadata_keys": ["file_name", "file_type", "file_size", "creation_date", "last_modified_date", "last_accessed_date"], "relationships": {"1": {"node_id": "03671864-c2be-42ec-87da-4d24b70c26ab", "node_type": "4", "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}, "hash": "626c4c6bdf71f3e019b0eb331fc9dd7346cd1e4e39dced46419ad978ec9b190e", "class_name": "RelatedNodeInfo"}}, "text": "Contributing\n\nOpentrons software, including the Python API and this documentation, is open source. If you have an improvement or an interesting idea, you can create an issue on GitHub by following our guidelines.\n\nThat guide also includes more information on how to directly contribute code.", "mimetype": "text/plain", "start_char_idx": 2, "end_char_idx": 293, "text_template": "{metadata_str}\n\n{content}", "metadata_template": "{key}: {value}", "metadata_seperator": "\n", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"ee8c1bea-b1cd-4fac-b9c4-9abe2fc7180a": {"node_ids": ["5fd6a050-23f3-4e8f-bba0-71fa5e7cc222"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "908670da-f9ca-45f4-9c87-18f5a25f1c50": {"node_ids": ["fb72f441-a712-4d13-85be-497de0ea4a6d"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "39782762-0920-4ecf-8385-840e2a25cf4b": {"node_ids": ["5c43cac6-cbd5-4310-8d7e-644c79ea84e3"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "443f616f-d00e-4fce-9d52-2f82b3787301": {"node_ids": ["ff004526-704c-4adf-ba86-191b44bee19c"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c6039319-063d-4f6c-bd97-c2a6f8f29be3": {"node_ids": ["90fed81b-994e-447f-bb57-a58434d07c40"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "90438811-6318-45c6-8a9b-31a4dda94448": {"node_ids": ["7d19dd1f-4d1d-45bd-97b3-213043675326"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "1500300c-2874-4b87-8451-6e42a046b04c": {"node_ids": ["0ca2eafd-f502-4632-bebc-2a9004268225"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c2f15d98-332a-4ac4-84c6-2e069e9c4d2b": {"node_ids": ["148b6c1e-85d2-4094-a823-08943ef9ef10"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "cda8dcad-3165-4e73-8ef9-913cccf2a532": {"node_ids": ["bf194c77-94d6-468b-9dca-33b4a00b4341"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "f12b1ab6-bf1d-4a1f-bb32-08050ed7ffd4": {"node_ids": ["7d5f954a-001c-4940-aae0-e524882b0dae"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2cd0d4ec-de93-4c86-8e23-2301b9df028a": {"node_ids": ["618e1434-de1b-4c78-aaa3-ecde2504bcdf"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "e05e5cb6-514b-4eb3-aeb9-fa3339907cfa": {"node_ids": ["f93e4978-3efc-45f3-bf8b-3c250e6867ec"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "86c4df41-67bc-4b18-9531-991ec39cdeb4": {"node_ids": ["ed204267-d82b-4dc2-8b63-c2808d43a436"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6bb64722-3854-4de2-bf50-7316a8a7a149": {"node_ids": ["edf53007-1498-457f-95bc-41dd176e8e3e"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "1bb4c179-ec9b-47a4-85c5-3d787bf7001b": {"node_ids": ["74c99f97-26f7-43a6-89f6-4fbf174fad47"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "07dc62f5-fff0-49d2-bdcb-0b4caa795372": {"node_ids": ["ba8a6241-8f23-4f5d-8ff1-97e13b7dfafd"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "d63598fb-e347-4caf-8874-4ea073ff89a8": {"node_ids": ["9aa01e0c-b6eb-4167-b102-d2a752dd3ab5"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2af8bedc-9d1c-45ac-9d9f-5674e6253616": {"node_ids": ["6046a625-2392-424d-a51b-7200fd7c676b"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "21660e10-5ec6-4d81-af4d-b8fa01baf94c": {"node_ids": ["fb05732f-c330-4e38-8be4-afd27dd0d467", "7ea28507-8d34-4264-9ec3-e83c3cad6fb6"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "a90ea0d4-c27a-46de-8738-36937bacf466": {"node_ids": ["90119cef-21c5-4c91-a649-5d34c669eac8"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "884e2dd3-ea7a-4e36-8ae2-8f62bf050531": {"node_ids": ["8c1900a7-2428-4b2e-9813-b0d9d95d16aa"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "7b7763bd-1f87-4b28-b172-88434a0a738d": {"node_ids": ["a9e68bf4-38b4-499e-b31c-49260b0f25e8"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "93f63f91-a2cf-4c98-b1a2-af9134983d98": {"node_ids": ["016f74e6-4cdd-4908-a670-9ce88db38ac8"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "4958c287-f737-46f2-97ef-bc6944efaed9": {"node_ids": ["637df4d8-3bb4-4e1e-b56b-a672fb78cfb3"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "b5ab2401-83c5-464c-862f-fa9f6fa74f56": {"node_ids": ["ff91cb92-24c1-422a-ad85-3083e163098a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "0227c4aa-7239-4e62-bcc9-8e90f5b2d44d": {"node_ids": ["32016a56-9bad-4a2c-a89b-f65bd22ed4d3"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "62a8b884-ade8-4a27-b6a8-c125f915b95d": {"node_ids": ["a91527a1-0c42-46fc-a00d-51e48e160a99"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "9d2dc5ed-5e92-475b-82b6-56268780b21d": {"node_ids": ["ca903758-010a-47e1-acce-16a4043df791"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "ec91b65d-e280-46b5-a777-e84d83560d98": {"node_ids": ["591cba89-9e7a-4331-9799-e9b3e319fa38"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "d47ef1f0-3a24-4e62-98eb-f2d4f4e64515": {"node_ids": ["70ad93a9-8073-4e58-8868-d8e7559ea8b9"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "1067516d-07d0-42fc-a9e2-b5cc0de4fe9a": {"node_ids": ["447bc559-f776-42b6-8228-7e330d6aaac3"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "5048901c-dd23-4034-b49a-059813f62608": {"node_ids": ["212eb7f4-b59c-45b9-a864-ddbb25f66fa3"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "13f2e3fd-a955-4360-acd1-9761ef014aec": {"node_ids": ["3c076ce3-5021-413d-b07e-b3da4772a6f2"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "5f65fa5a-be1c-4d4c-841d-71826c3097e8": {"node_ids": ["a7a68eab-bb2c-4505-9414-26af70c11169"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "3b6461a1-c383-4500-a9e6-43f39b6458ac": {"node_ids": ["77695f86-93ab-4b06-83d1-2e9f653d542d"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "1299ce80-d804-4efe-bd44-49226ac327f8": {"node_ids": ["6c6f7fdb-ca10-4a39-be7f-0e905c74f8e5"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "9f33c3e1-1e3d-40bb-9815-0ab96dee0e26": {"node_ids": ["c4a68a3f-5adc-454c-9329-d04beb315b66"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6fafa2db-d580-4bd6-bf08-2f3b424d1c97": {"node_ids": ["dd007594-e618-4623-8115-5975ec5a9c56"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "94eee232-a3ad-4b0f-85ec-afbdc0d5d33a": {"node_ids": ["2693d643-cade-446b-b4d9-b42ad94fc62e"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "202afc63-7d82-488a-9137-97ceabee5814": {"node_ids": ["f459b952-d907-4aad-a92c-b71613ff6a4a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "d33a7aa3-a7c9-4dd3-9912-e6e18ed4ca90": {"node_ids": ["8b50f6ed-9ce3-4b2d-9c21-aa7aa9122050"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "b0a92881-a03c-4afd-8067-ad2ec5a13701": {"node_ids": ["e66d3f9b-af1d-40b4-99a2-21fa95e2f55c"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "579f3294-8ab7-4e22-9588-33471c4a708e": {"node_ids": ["57091c68-9147-4261-86b7-9c91562b01ed"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "ac29e2b5-71ce-4c38-a656-c33875238965": {"node_ids": ["c63bac2c-818a-4f66-ae06-44032bde8628"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "a84485c9-b380-493a-b067-094fdd376094": {"node_ids": ["200ce9dd-cd00-4851-a923-7824a527cf44"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "756f8435-bab7-4990-938d-0a5c79c41202": {"node_ids": ["9918a549-33d8-4cc3-8582-0b6258c2cdda"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "a7566768-83eb-430b-8927-cf27b0116b87": {"node_ids": ["61111df3-ee09-4924-88bd-a283ae67baa3"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "947440ab-25f3-4da8-8d46-0b6010cf4c1d": {"node_ids": ["38186da5-60a4-45a8-838e-ae5dd6b24b89"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "11392ab1-c733-4b0e-a3b4-51b914143cd2": {"node_ids": ["215b168b-72e7-444b-93c7-933264a3875a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "677686d6-dcff-4e7e-aa22-8aab50d5c9d5": {"node_ids": ["4b8efd40-5180-4c76-b048-33e6a84cf9eb"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "282ac654-91de-4776-80e2-e59a4f83193d": {"node_ids": ["6d498364-56fb-49a3-92d2-30f2838277de"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "31631f53-39eb-4bab-a03d-f24041756d15": {"node_ids": ["344aec64-60fe-407b-ae79-06d2111587c0"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c4ff6a2c-3797-4ee0-bbf5-5b1849d8c328": {"node_ids": ["6027dcb1-2584-4d20-be83-dddf8b581639"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "b20bab95-1850-421a-a785-1f6b1665520d": {"node_ids": ["57ad1753-d494-445f-b1be-3187ea8a43ba"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2eec6d88-96a5-4ebf-80ae-3084489084c6": {"node_ids": ["9abf3c38-9bb4-49c9-abea-0bfd7aaf0920"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "88dc04a6-a0a0-43fb-8661-a06c018980f5": {"node_ids": ["9a4d4676-2fbf-4d82-8233-21eaa4bd674c"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6d13b8ba-18bd-490f-9c2d-9d549550d782": {"node_ids": ["7add000c-a7f1-44eb-b8c3-e658482e13ba"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "205d6cb1-d53d-4cb4-bfee-6d7cb87d2c02": {"node_ids": ["a4513569-7d04-4939-9534-49c886c375b2"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6c369cc3-8892-4b09-a524-b043d002b7a1": {"node_ids": ["45483488-f867-487e-bb35-5614a6143edb"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6306ae25-5d84-4f9b-b0d8-b5c649ac9a23": {"node_ids": ["a5ed50da-540b-42b4-8a51-03e1b47f79ba"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "04c427d9-e2fa-41bd-baec-a4a7a317660b": {"node_ids": ["7b3d3d1e-1041-48f6-a443-50b76cfacd71"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "aab510f8-68e5-4a6b-9dfc-bc62ea31bd0e": {"node_ids": ["28726f90-f670-4016-bff0-fd983af10963"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6ef1cfef-1436-4538-bdbf-ab280b7e469a": {"node_ids": ["28a2bfc9-b7ba-4b20-bf32-12e69a7d5117"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "f72abc19-8b18-4335-8881-c297dc1163f2": {"node_ids": ["88966cf8-3991-4ddf-81e1-962fcbae103e"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "0cae6ee2-b850-44c1-bf99-694cee68a4b6": {"node_ids": ["d0ef0f79-241d-415f-8ac2-2541f79d1f1a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "e2716b63-d299-4465-8e6e-d976bf37e9d0": {"node_ids": ["fbf33eaf-9f7b-4509-b47a-611f4d7a50aa"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6bb63a31-b4ce-4b00-8efd-307768f04424": {"node_ids": ["57b62286-fd01-47f0-8674-2b80a9fee898"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "e3796c9c-ffdd-423d-8b76-118a05663bb5": {"node_ids": ["4b27a462-6514-4a2e-9d97-0bbd7039f65a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2a55f44f-4fbf-499d-b815-f9c2877a8d0e": {"node_ids": ["7c5075f5-b0a0-4bf2-8a6e-9e429113717b"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "7361c261-b009-427a-81ba-edcfdda667e6": {"node_ids": ["5a2a09af-531c-4eaf-a0cf-72b66d0392ef"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "e47aa32b-4c2b-455f-a134-d242e27199ed": {"node_ids": ["ace66c16-e8e3-44c4-adff-1260bfe4f840"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "00d870b8-cbb0-4d7d-a350-496c3e19a1bd": {"node_ids": ["1801eede-81f2-4a73-8714-3929e604cea9"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "11382185-80cf-4e29-9b32-e96ab039e973": {"node_ids": ["1c749976-1c14-436c-9927-d5418b73805b"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6c334337-2220-4f84-a1ff-d0d977582906": {"node_ids": ["64fd41b5-bf91-40ef-9675-a2b23bfee199"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "0b0fe093-dce4-4605-9bee-82c42074f1eb": {"node_ids": ["257afe00-9c68-43ce-bb95-d0cbca2e23d7"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "8f18e61c-5f3d-499b-8a20-e029fb61b208": {"node_ids": ["f6fd86de-3321-464e-9e49-b7875248ed94"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c62e1dee-ebc0-4f4f-98cc-5c99dac80529": {"node_ids": ["b86c41ed-f1fc-4f91-b92d-74ec2c7034bf"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2be3e37e-fb2a-4504-a589-8c14055853ef": {"node_ids": ["026546e7-181a-4206-90ed-120461f65c38"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "a3f10417-72a7-4462-8ee0-440e39a24ab2": {"node_ids": ["c3b6ca63-6d23-4976-94cd-8580e6503e61"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "f95d67bd-6c0d-479a-a872-3674377bca97": {"node_ids": ["9bef5dc4-21d0-4a5c-ad87-6e432cb56ace"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "8c6dd48a-7701-46a7-95ab-162bb819468f": {"node_ids": ["e4b5304b-823e-4445-a1ea-c0cc4cd38fca"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "bc6e6f88-5eb1-408e-8ad7-6da71f6f1d38": {"node_ids": ["910cf0de-fab0-477c-b7a4-d647114bbb11"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "d1a63777-02d6-4af8-a809-2f8ae6e6475d": {"node_ids": ["a13e8beb-1ae1-40b7-ad66-8d2e8ea13cf5"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "3b458459-4dd9-4848-9549-85e9a77fecab": {"node_ids": ["c75ac5eb-5803-4ea7-8192-05ce627f6249"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "51ba3d9f-a608-42da-8e73-50f9815acc58": {"node_ids": ["dc21147f-8e07-4809-bbb4-8792f4b5088a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "7aa44a91-4a05-4638-b083-d7b567e074fd": {"node_ids": ["70b61591-5818-4d13-94e9-62d98f34ad86"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "d69fed16-ef9c-477b-8162-5398ec0becec": {"node_ids": ["308ac43a-fba8-466d-84cd-9f9786d45512"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "1e28e0d8-a45a-4ecd-8fc6-3ed34c463e4c": {"node_ids": ["fe3a5b11-1735-4d81-80bb-c036ba11cd84"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2385bce1-9781-40a9-bc5f-babc5758b8a8": {"node_ids": ["47b56d4a-735d-48a2-af71-73aa8af48557"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "917359d2-353c-445f-b663-2fc3df9b4709": {"node_ids": ["3add3fdb-f4da-465d-9169-f29febbf1824"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "94e300b3-0998-4e9f-8198-6c6f820d2e82": {"node_ids": ["38b29421-6026-4c4c-b185-215d46bb154b"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "cfcc63a6-d0c1-4c7b-8a51-557bc0dc565e": {"node_ids": ["41398e86-5b6e-46bb-9a65-40961ace4da2"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "4f20e1b9-764d-4ffe-801a-19a51b1058b0": {"node_ids": ["1d4a1982-5b0b-45be-ac4f-83d439dc303d"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "9858a4df-7f4b-42c3-b033-6606454404e6": {"node_ids": ["7c64cfd5-b8e5-47b3-84fa-baf21fe1e41c"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c4fd46da-c327-4201-bcc8-65ff4895ba5b": {"node_ids": ["1a367c53-3325-4cd9-b266-96204893392d"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "7c151f85-8ba8-4b98-a167-a53fde012914": {"node_ids": ["e26bb185-e570-47be-a374-daba5dbb7c3e"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "19ae540e-1254-4853-b078-e61060a4a0ed": {"node_ids": ["b8fc69cc-e537-4446-8f33-b45ca411d031"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "e635531f-c20b-4860-8dfb-420b960c5f8e": {"node_ids": ["d4efc45a-8e92-4637-a8ee-bf6e15e1ad60"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "cccc5fb8-ddbf-42d8-99bf-3d47d736af84": {"node_ids": ["fedf6bff-f687-4b6d-9dc0-7008c00d49f8"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "9769d996-c1b4-4dd9-8234-fe2515e80255": {"node_ids": ["811695ee-2228-4c8f-951a-82d7f4f45c3f"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "f055d117-26de-4aa7-8381-a2a3550eacc2": {"node_ids": ["55922c6e-79a7-40a3-94a5-c57015dc53af"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "ac98703e-178c-4344-a053-9adda47dcd16": {"node_ids": ["cc0292fe-89e4-4ed0-88a8-8bf84434944a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "4e01c364-e826-4134-a736-fba73609950d": {"node_ids": ["2a4423e3-72a1-4253-84e0-2cd14733e5ca"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "95463265-4f6f-4c31-8d48-990df80674af": {"node_ids": ["7a9b4fa2-7c27-40f1-bc48-435ddf6117cd"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "7a1867b0-ab52-48f8-951b-fc43bd32f774": {"node_ids": ["de7a313b-87dc-4714-8e67-8cf20017a4cb"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "cf77a9ff-f7c7-4593-a369-cd4fcec74f2e": {"node_ids": ["7d0b50a0-ea1e-4a94-a0ec-8d3673980d30"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2998f37a-c9ce-4c33-bf4e-52eebed61bb6": {"node_ids": ["9bee9f1a-6dbc-4059-936e-45558667d141"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "5da6ead4-b24f-43e3-bedc-9a77b862fc9e": {"node_ids": ["f7f3b1bd-ec07-41a7-a936-404f27f1fd59"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c99c0473-2ee3-4626-a83c-889903223a8d": {"node_ids": ["50083219-d212-497c-b454-93b2d826fccc"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "e1730e91-dc77-4608-9b00-c63130efd0f6": {"node_ids": ["19f48a1b-65d0-44a2-a1fd-a556bb4a4104"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "623359d1-b398-4a1f-bbed-a2188f071c4f": {"node_ids": ["0dfedaa9-28bb-4e38-8a0f-c221bbadde41"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c7fc7ded-4162-42fc-89f0-25bebb2072f7": {"node_ids": ["d30f5461-bfe9-419a-b9e5-13e7f817d3eb"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "cae08c35-58df-4cf0-9034-118be5bbfe65": {"node_ids": ["a4a4c01d-1d77-499c-a26e-93f5724f836a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "f8790928-f542-4321-b081-e518644dc5b6": {"node_ids": ["cefe593e-4bce-4336-a105-086bc6a1b89d"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "83b2eff1-167f-4ecb-8fea-bc10ab4531af": {"node_ids": ["50b1a5fc-76fd-43ae-8d2c-5b3d523b43ff"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "b7d86710-14f3-4128-9055-d2f74d49704f": {"node_ids": ["fbb6629d-83f6-40c4-a33b-90071643c471"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "9efe19e9-92a3-42f7-a2fc-591df5e1f4cc": {"node_ids": ["5ebf07e2-6f73-45de-8193-13b4a5849c97"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "bb774b2c-b190-424c-8f29-da6e433a7ed6": {"node_ids": ["23efc760-5dd5-464e-96d9-55018af5a877"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "03c17ce7-f7a9-4af4-bbda-4ef034c1775e": {"node_ids": ["fef84c92-5054-4ef0-98e0-b7ad804f8ec7"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "8c47a83a-cece-4eed-9754-e87cfa1311fb": {"node_ids": ["432a45aa-48e5-4043-98da-b8ae68632fa1"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "7c325cb2-4c75-4937-b03b-0621439135e5": {"node_ids": ["28e15324-5851-42c0-b1f2-0a1e1ed4cdac"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "b8310bbb-c7ee-4550-875c-c54c445580d8": {"node_ids": ["03bc875a-d6e8-455d-b9f1-86e01d0d4765"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "a1e3b10e-6074-4a02-b32e-9d69f689ab63": {"node_ids": ["60458e4e-0c67-42c2-8310-81e5d8f132f1"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "befa605f-8e9c-4682-905d-bb77f58d0fbb": {"node_ids": ["58a8ba9a-b614-4721-b5af-93142e365307"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "d74a49ec-52f8-43a0-bbdf-8b110eae4626": {"node_ids": ["cf70cbfd-5bf7-4388-9cae-eab7d813a45b"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "d1445793-9701-4b67-836d-6945c31b6fab": {"node_ids": ["1d73b0c5-6806-4d5b-a54f-52874070537a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "208c29fa-b14d-4b20-8c2e-4cfbc76658c1": {"node_ids": ["78962a20-8d36-4f05-8fd0-b886d95a1ab1"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c58902b7-d175-49cc-b12e-e5d57bb46c0a": {"node_ids": ["1a164fab-96ca-46eb-9814-08452d18b867"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "5acc5950-7cb8-4531-910f-c539038168b4": {"node_ids": ["e63d0cfd-7b4b-4a0a-b5b1-1a3f856b75d5"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "a94512db-7ba1-4546-96c5-46c118179f66": {"node_ids": ["6ff857f1-973d-43dd-8b89-960224fdb0d1"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "42247bef-29bf-488e-9c35-cfbde445f7c2": {"node_ids": ["bebea504-4f0c-43b7-9b4a-7ae822f8033b"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "7a5223ad-8618-4c77-8174-a0aa8c67cbad": {"node_ids": ["722b1b8b-a4c6-4266-bd9b-adb38c05e779"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "9198039c-fe34-4d2d-90c9-dc39b8a80fc4": {"node_ids": ["ebb78474-a429-4968-9c44-9ffd62980a32"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "91ea4229-4514-4e32-9db5-c1b1c4643864": {"node_ids": ["6129bcca-6dca-4c47-9abe-fef3ad391a92"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "8b4d949b-1c03-4f6d-b762-181d5bb8aaee": {"node_ids": ["8585ac52-3bee-4b6e-ad4e-42950a64eac3"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "7b31efe2-ee89-4579-b759-61dbb22030a7": {"node_ids": ["46a697fe-c86c-47dc-8671-bbf42a63fd10"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6c261d99-e848-4553-920f-ba01e4a108ab": {"node_ids": ["b45d6705-cd5a-46b6-95bf-fc2590ceae85"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "490a1ee7-85e9-4f30-b09a-3b5156bde184": {"node_ids": ["455bda67-681a-4c2c-b3f1-a46656284212"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c0b93724-2c51-48ea-881d-a675e7b84f73": {"node_ids": ["eaa38dc3-16d5-4fc1-bfc4-8bc5201ef35a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "80cfdd44-fcd3-4767-9605-e28c5672c4ac": {"node_ids": ["e4397436-7339-45ad-b584-1eaafff7c407"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "5ec31165-dffd-4cf1-a2d8-43fc9def9a40": {"node_ids": ["eb86d96f-7552-402f-9542-3eaad70ad36e"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "9767c140-225f-4161-a0f6-2009754c94c8": {"node_ids": ["eba67ed7-ccd8-454e-950d-0b2daf8be6ce"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "947c0910-1b00-4ba5-9046-be95eb1f44b0": {"node_ids": ["1b154b3f-58e2-48d9-bb8b-072729a01454"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "87f281d4-5221-4688-91fd-022e020b9131": {"node_ids": ["9b8022da-08b4-4471-bcba-100c6996adea"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "7afba3f6-4616-4a9f-a8dc-77603366355a": {"node_ids": ["9e49aa4f-872f-4e52-b4d8-2d427dd64a6a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "275b9a1c-df4e-4a13-b66d-aa0d91623187": {"node_ids": ["5cf4292a-f5f9-4d89-954f-d622498eb7c8"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "7030ba58-c661-4098-a404-e8982afc283f": {"node_ids": ["a5e7ea33-3ab1-40d6-bd11-65f09aee9b12"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "dfdf4f76-0f19-41fc-ac76-c1885dba6401": {"node_ids": ["7696e8f3-bd2b-4bee-8522-e042718e1223"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "9cd1c731-02a5-4eb9-a77a-c2c47a97fde0": {"node_ids": ["1b4e2318-b2e7-49fe-8557-fd1eb3335a2d"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2fb81f50-58ea-4f20-9d89-f9b46d015d60": {"node_ids": ["f74db465-fd34-4fbf-8c47-54ebe58055bd"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "0f9e27a5-ff6c-4fc2-aa7f-7fee480f1057": {"node_ids": ["e256bf26-9f69-4769-9b27-936bc70c69f6"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "738137b4-f8a0-4cf8-93ca-a82448c99510": {"node_ids": ["39e5dd2f-279d-4c90-92ee-31588e96d480"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "1bf1a1eb-4f3a-43bf-bc0d-eeec6740e5b6": {"node_ids": ["e48ede79-a022-4c5f-be16-db06f3238807"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "dd468da5-f245-409c-925a-5fcf27cf380e": {"node_ids": ["3f2092cf-0e96-43d8-97eb-48a58384e898"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "26406906-933e-4c1d-95d3-e9ed1e19e876": {"node_ids": ["8ec4eccb-5a2d-453d-bc1e-f9f5d9d33d4f"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "7ee82b10-a89f-43b8-8114-aa631e2d60bd": {"node_ids": ["735fba49-276e-4e4e-83ea-4ab6bcd8a376"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "de3923b4-ebd1-447c-8bca-07ac4828682d": {"node_ids": ["ae9188c0-56fb-4efb-9736-b8f2e655514d"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "ee18039d-52dc-45e9-a0b4-ead228bdff51": {"node_ids": ["f58d65a3-c321-4cc5-93aa-8755f30356a3"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "70c76525-7e7d-4049-b5d8-3f63a012f784": {"node_ids": ["a368c95a-3a65-4ab4-83cc-6fdcbe6aa03a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "85fcb5e9-b1d9-4123-82e6-2817dc6ffc41": {"node_ids": ["7ee064be-b859-467d-81ec-33fdfc3b1016"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "ad85347d-56b3-4b9e-b525-1c68bb3af2b4": {"node_ids": ["8ae7c165-538d-433e-accb-f72376223d00"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "056228b5-64c0-406c-a793-4a764ea7c966": {"node_ids": ["35dbef31-7560-4bb0-ab3f-c4d089df63a1"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "433c2ddc-f2fc-4fe6-81bc-857d2c867fbb": {"node_ids": ["274c2e90-294f-4632-9529-8d1bd8dc38f5"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "93449ef4-22f0-4dd2-b16c-4eff22225a23": {"node_ids": ["a7cd0404-ee8f-413a-9f2e-9fd9a855cd2b"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "39e04556-8133-46da-82af-b94eaaf9246c": {"node_ids": ["1c4e4b47-60d0-4d35-9030-d35f408ecd8a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "62b84c1a-fc21-4f5a-9a62-3c2112825822": {"node_ids": ["bb15903b-c9ed-411a-abd0-37decf346589"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "71f82895-2605-4b82-95f3-b5868d02c89a": {"node_ids": ["9f318eb7-ae4a-4c0b-bf22-060331433447"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "9d95ad51-9696-49da-a394-e7c7ba6a42cd": {"node_ids": ["36d84cd6-4742-4b94-b645-8ca424991552"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6ef4f03a-25c7-42ed-832e-f02835e75036": {"node_ids": ["08668273-877f-4994-85a5-08c17e6dd48e"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "8a74fd72-a112-47ff-b2b4-c9b2234f04e2": {"node_ids": ["7e80d414-ee7e-4470-97b7-d57a69c98c1a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2f04de43-4fc8-4069-8263-547ae79352ce": {"node_ids": ["fa263542-a122-4cef-bd74-22d3f1420fd0"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c0559dd5-4c70-4267-8023-0d08aad51e56": {"node_ids": ["20908338-4015-4269-832f-e3e1dcf71509"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2c076cb7-fcef-430c-8641-30f6ed41c927": {"node_ids": ["943bae3c-558e-443b-b22b-86c12dbe2d23"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "fa6bc619-a56b-43fd-865c-6472c19bc6ba": {"node_ids": ["25b03630-eb7c-4900-93a9-4cc07507cb3a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "b1f77d73-ca31-4d05-886d-1ac6a8d9b504": {"node_ids": ["2cdc37cd-553d-49d6-b41b-8b244d45b0f0"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "b970750f-1675-40ba-b19d-4d2f957a5c50": {"node_ids": ["4761f7e5-b053-4411-b9e2-7ba8378c77d7"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "8e44d0f1-9c4b-411a-8fbe-5bc482d4d881": {"node_ids": ["447ce0d5-b648-48c4-9ced-6122888a42c3"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "02190c46-16c5-40a9-a186-d5a23f7b61da": {"node_ids": ["6edaf77a-8894-4be9-9942-1a1015d8b7f3"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "98dce572-7468-41d5-addb-f2a32905a70a": {"node_ids": ["6e0158cf-eced-4e52-8cf0-6241543215cc"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "b8cbd1c3-2bf7-4f46-ad77-ca7a8303e3be": {"node_ids": ["f788c73e-fc82-41f7-a154-785bc298ed01"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "81341fc4-5c06-4e33-a5b8-7c2e955c5caf": {"node_ids": ["a02eecf2-3ca5-4f3c-a71d-b33c01f5ce9e"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "3cc395af-f75c-4492-a756-c967a6b6284b": {"node_ids": ["bfe37647-1bd7-4ac1-b6da-c1ef5086a9bc"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "b84ad7be-dc5a-42d0-9a66-24f4f26179fb": {"node_ids": ["9391479d-6527-4890-8bab-ecffb1ce806b"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c9c4d5ce-90db-4058-a256-709bfd81e7fa": {"node_ids": ["987c20df-db1d-448f-9db4-24ea8d0f5d77"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "4a354c2f-6277-44de-98c5-e384b3ae276a": {"node_ids": ["958e505b-c16c-4776-bd32-24d1724a1fb2"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "786e4627-7138-4261-abf2-d6e78d2eb035": {"node_ids": ["e94b0750-5dfb-482f-82d7-9f1b5715c82c"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "65b12f50-b533-45c2-bca4-b35ff946d9a6": {"node_ids": ["89e965f1-da2d-4990-8fe5-c8cbbb6af07e"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "44935100-ebd2-4717-a006-836d1d4588a5": {"node_ids": ["760edde3-6283-4fe1-bf3f-de2b24d32a08"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "d0918ce4-809f-4013-a000-a014386408d3": {"node_ids": ["4d32fa53-2eda-4b24-8864-169bed3f4d4d"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "a76f9c33-a3e3-4d08-8f60-36cdc658e598": {"node_ids": ["9f1d5414-b59d-45b5-a11f-d0aaa4c9cb05"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "b2470960-5eca-4cc8-97e1-50f28c3bed68": {"node_ids": ["1e57889f-94f4-4957-8032-01b263707951"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "3c378130-152a-4b34-b40c-2c5f5ff5fcfb": {"node_ids": ["8d2a4862-6f0f-417f-8629-86b8221847de"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "d4c1d5b3-4e70-47a6-8200-e01c1da468cc": {"node_ids": ["a365e57e-2d37-490a-82f3-304ec91656c2"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "7502d682-0968-41fa-b55d-5819eacd8d62": {"node_ids": ["19bae759-6c89-4b62-b3b9-b7906d2e5f26", "e0570867-358c-441c-9040-508c6c446a13"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "054a4d03-49f9-488e-a175-d02a58d43684": {"node_ids": ["06201254-cb72-4eb1-8b64-97e0868f3d04"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "19b4116c-3dcd-4ac5-b3cc-1698f683978c": {"node_ids": ["d8ac4e0e-87b5-4865-a5c3-5892761f4a62"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "22e1b81d-b8ab-445f-a1dc-cdb48180e8d0": {"node_ids": ["fe1b8578-c937-469c-9795-a670e7574baa"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c3a5fde2-555a-4d11-8ebc-a55b5a25bf74": {"node_ids": ["209a9f86-d422-4a7e-b0d3-3eca082315d0"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "1313a23b-3cfe-46aa-a8c0-b25a18daf5d4": {"node_ids": ["99082fad-0df8-4057-bf02-a7769a2cc2b5"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "0602591e-396f-465a-9c22-d5c36a90d6cc": {"node_ids": ["a5dc03a3-2f1d-42ad-8166-55156a8edb8a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "ebc0feff-aaf6-4ffc-ac64-2982fef76e83": {"node_ids": ["a1cdd82d-9202-4797-a40b-8caaa7fc936d"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "31a4e240-38b8-456d-a455-3d5248c6e1a0": {"node_ids": ["1271b4fc-c0a0-4b0a-a77e-2c2244945e94"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "b7f5453b-2915-46a6-ae88-7942b1b94adf": {"node_ids": ["b053faf0-1df3-474e-b3de-d99871c100e0"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2e42ee72-4454-4064-a16a-2eba745e40d8": {"node_ids": ["7a173dbf-e717-4e76-905a-c068c7fc5405"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "cb272b09-7494-49ae-9d3d-1bd5094576ea": {"node_ids": ["979c7dfb-e1e5-43b2-98a9-d2cba83f8b32"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "74a1f56a-7bcb-4762-85ac-f6af487535ea": {"node_ids": ["dad2ce53-e8f4-4253-81e1-b73105b59874"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "de0fa9ea-7a5d-4b63-bbbe-1a31b5f1985a": {"node_ids": ["b48d96b3-3329-4b95-9a4f-eb6c3e048f2d"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "a21839e3-b820-439b-b5da-b5d43688d75d": {"node_ids": ["971d2f6e-0ced-4f90-b8c4-34720d7fe693"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "0ee51a65-8fcc-4525-9c0c-78d5067a5322": {"node_ids": ["555b90fe-9611-49b2-98cc-fda44a97ac67"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "125e959a-cb4b-4a7c-9b73-5f80b61a74ca": {"node_ids": ["e6dd0714-06a1-468f-adfd-30da4147296a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2047cd2d-605a-40ce-8b89-ec793a70d05b": {"node_ids": ["87b0c517-7c71-400f-a839-1abbb6cc213a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "54eb0dd2-0372-4480-8700-2b2ab5e05d29": {"node_ids": ["462ffaf5-b019-464f-a4e8-db5e5692995a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "4467e687-5999-4b63-9101-fe9d307cfc80": {"node_ids": ["80cee061-8b84-4a7f-a486-268b776615b1"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6b6772b3-9022-4a46-bc80-adfe89c9accb": {"node_ids": ["4d36a5e1-62e2-4e01-8197-035f4ad72dd3"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "40fbc029-2ad0-402e-81cd-8c0efe287788": {"node_ids": ["4437d5d8-8c75-42cc-9cac-3efc7d7c1dab"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "58c66e14-f22b-4a36-ab1f-9f57d4b818f9": {"node_ids": ["f7a6a9f5-c3d3-4eb2-831b-6b62b1f68842"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "30483c99-d763-4ad5-b049-71ea752763cd": {"node_ids": ["fec09d0b-e735-417c-b5b5-a8955669bcd0"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6a51f9e0-f740-49ba-a5fb-21f5a4664960": {"node_ids": ["848bbcae-08b8-44a8-8134-f50329851c68"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "bd21fc9f-2e9d-4dae-9aa1-0127bd7991b0": {"node_ids": ["9207d7fd-cc90-4a7b-852e-ac3f0ca9849c"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "ed55d837-9d25-42b2-9f2f-0988305f31b9": {"node_ids": ["9aa12637-db34-4d7a-9784-ef31ac8a269b"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "4669cc34-fabd-4371-afd9-07fc961fb99c": {"node_ids": ["86f775c7-90ef-43f2-9908-db52c8a86cb0"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "0c453eb8-561b-4931-abe3-ea257e314b77": {"node_ids": ["d9f734fc-3226-4b81-babc-93d496d33951"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "a5eb5759-6fcd-4fba-a0ce-2d697baf268d": {"node_ids": ["6601d651-4e32-43fa-a001-7f1af2ed50a5"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "4a760229-465c-427e-aa06-ee9c11b9d741": {"node_ids": ["ddcbe981-2b7a-44be-af60-bcf555433f0b"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "5fa5cbaf-0f35-4b9d-adff-e85c226123ee": {"node_ids": ["e0b0b4a4-8b9a-4bfa-a123-93385461cdd5"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "47fea022-bdde-408e-884b-15d4b71026b9": {"node_ids": ["ecea9bbd-03e7-48bb-a9f9-5336c4334872"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "801c7121-6498-45f9-9982-5ac4493b7d5c": {"node_ids": ["ba98213b-5769-456f-a73c-9548722f822c"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "7770cd55-5f3b-4e8e-aee9-ecf39b046832": {"node_ids": ["a64438d1-9e57-4325-8a98-99fc03559c27"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2de75324-dbdf-4dfd-b349-8d4646785a32": {"node_ids": ["24c3a50c-42cd-4c3e-8001-e7332dccb190"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "771c14ae-b222-4117-b39d-2faea750ee5c": {"node_ids": ["e2cb319e-b352-4d4b-8f53-a8aa3675baf9"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "fdabded4-fe83-400b-bec1-ce4c30cf9b1f": {"node_ids": ["6469cac0-fee6-4b34-8ea5-9073e683c617"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6505cecf-677c-4d91-bc21-4c3a911f2ac0": {"node_ids": ["d2653b40-5996-4076-a42f-f531ece9bd7f"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "453763d3-5a2c-4186-8f6a-d9f423a3c22e": {"node_ids": ["9b41fc0e-a810-4ca3-95cc-e21c280031b0"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "dcc12e56-bbb1-48dd-90f1-330686f8779d": {"node_ids": ["b45f890e-3c4c-44b2-bf62-87f14ac48e9a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2228b889-4a61-4d0e-ba33-07c97eed0389": {"node_ids": ["b238dc51-f74a-4dc9-a980-bb6f2d0facca"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "78c46e43-b93a-4000-991b-de6110b1ed12": {"node_ids": ["92e2dace-0784-4955-a484-939c74711ce2"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "e9f123f7-660d-4d8d-95f8-5e0bd024443c": {"node_ids": ["3b1dd7c8-d7bf-4ac0-9d6f-6b21ed196e4e"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "abf11ad1-2619-4914-abcd-4ecc455d6b8c": {"node_ids": ["d8453891-ae22-412c-888d-98e7f50c361e"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "5044523e-0216-4f21-8097-9a0e34005ebc": {"node_ids": ["641f39eb-43fb-4f67-9f85-b27979fdcf89"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "ff71afa6-6817-4c42-ab3e-c84632ee6845": {"node_ids": ["06ff69ea-ea3f-4e05-9702-a4f42083162c"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "b373300d-6b21-4b71-ba8b-5169cd22a3c3": {"node_ids": ["33862ba6-3d98-43a6-8b48-45d72ec0c9f7"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "43561dff-5a70-44c5-b85c-6b103665a579": {"node_ids": ["5105ccff-853c-4348-81c4-0d3619922165"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "006e6506-be88-4e19-b0f1-9558e4ad6ade": {"node_ids": ["243dfa73-42aa-4ac7-9d0f-dbfcfac806d8"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "219da5b9-f055-48e9-92b4-22fdcb947390": {"node_ids": ["50f9d152-9614-4f62-a600-ae7721e4f42c"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "9b86a7d9-96a2-4e58-8f7b-c20667c1ab1c": {"node_ids": ["d781fb74-e430-4e16-8ba3-33f40cf8805c"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "5e5970cc-055f-4ad8-8118-51172040cc69": {"node_ids": ["7870deef-0ff7-4eb9-9177-ee611d122f6c"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "65049405-5ee7-41a3-8f7e-1f4afd67da15": {"node_ids": ["ba304024-cb3c-49af-a18e-f96ec2724457"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "16ec0902-93f5-4310-af1b-cd584e6ededb": {"node_ids": ["16351c56-0d44-4ada-864f-be7104ad6860"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "82077a3f-5db0-4220-969c-766bfbb80958": {"node_ids": ["a190cb27-9b4e-48b8-bad2-f21b21dce25b"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2e04468b-1a5f-41cb-870d-d63002ee17b0": {"node_ids": ["a2dde6cc-b223-4833-8123-12a80b223f28"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "0f936c7f-ea99-4cfd-b7a7-b526a15c0154": {"node_ids": ["162d8940-0b7f-4e87-8288-15ce58a4bd8e"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "cc638242-a014-4e20-8438-82fe9a902629": {"node_ids": ["fa854af0-f5b7-4f15-a27d-d77b60c06994"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "d1bf8d3f-e168-4b22-9b78-5697e1d92ff0": {"node_ids": ["fc5e1b2a-c2f2-49c8-9d43-24afd4a22563"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "dcfe059d-adf4-4efe-8a11-0f5df04bf137": {"node_ids": ["62c57601-3a00-4f38-9001-f1b1657519b8"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "4827f7da-38d2-48b3-a83b-74a0ae6b0dc1": {"node_ids": ["861da732-4fdc-4aab-bc7b-b047963943e3"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "a8b9a87d-c8c2-48bb-8c79-a7e914af3279": {"node_ids": ["9db76110-8d6d-4a95-9577-2aa0cc178cf7"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "1c34a6ee-41fb-4374-bddc-50a460a096bd": {"node_ids": ["65c8408d-f050-4ca4-8e98-8aa07163ca2e"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "d7cd9798-cf09-4395-ad0c-405565c47cf3": {"node_ids": ["e3cb6921-36b2-446b-9f44-ae0a4c18259d"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "dac92a66-6742-42fa-9bc8-7aba5d6e50fe": {"node_ids": ["01bd11b6-0227-43fd-8602-e65d1d744483"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c619de16-f76a-405a-b8f5-a3ffbd2dc920": {"node_ids": ["de0c6866-6a44-4fa7-a7a5-ee1b0012029a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "ba32a073-fa17-4a8c-a508-de75fbbeb558": {"node_ids": ["4f10ff3c-7482-4bc9-a624-fc899e30e624"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "53f8a2c4-7e3e-4024-994f-05438c19456f": {"node_ids": ["bdcedd02-6321-4aee-8c5c-0f55495e7891"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c504291f-7c6d-44d7-9988-612a6d4258f9": {"node_ids": ["04d8a208-e98b-4ecb-9c7f-4b74a830cdef"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2118b02b-9f5f-4dd7-9770-dadd54219e2c": {"node_ids": ["48b7809f-a0f3-462d-ba49-63a3cede58fe"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "79714208-495e-475b-82be-9cfb3eb94965": {"node_ids": ["3cd472fa-0cb2-4f47-9860-1b70b88253aa"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "ec9808bd-3e73-4956-a1ac-0c8c8a442f16": {"node_ids": ["649de324-ef4f-4f4f-815c-44528769a291"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6a35332e-c12b-4487-89cd-76da8b0f779b": {"node_ids": ["78064cf5-b52a-4edd-9eee-8b82841a7f73"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "1f82455d-8268-49b3-857e-ddabce1c25f3": {"node_ids": ["1d1fdcf4-00b9-4f7d-9638-c49924ef9e6f"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6c29536f-9969-4ac8-bac4-763b731a23dc": {"node_ids": ["ff1d1173-ef6f-4ce4-81fa-9ad5396ac4e9"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "506d8c87-e9c3-44ca-8327-d43785ff89cb": {"node_ids": ["7aadc5f9-ced8-475a-875a-a1a75899e994"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "e86330df-b5ff-4404-83f7-a532df4a699b": {"node_ids": ["27184572-28ce-4cef-9ede-e62d8421666f"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "93744a9c-4c8e-4e45-9656-52c8de55e605": {"node_ids": ["1f2df2b3-3b51-4e01-b2f1-202e5533caca"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "9b5fa849-f425-4f79-b3e3-398d7afaaad9": {"node_ids": ["e1ec47fd-eb6e-4dfb-b1c2-04372c1e62a1"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "a65e5de8-a726-46de-97d1-d345af0493a5": {"node_ids": ["516841c3-b9bb-452a-b495-eef19628220b"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "2eac5e37-3290-42aa-afea-3f7b49c5c4ef": {"node_ids": ["f63dde7b-d7c0-4369-a891-21770d563e50"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "1b37e028-4d89-4dc9-acda-2c74831dfb45": {"node_ids": ["2670e9bd-ad8f-401a-ad59-f7a03c799c99"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6fbcc5a1-f232-4cc2-829a-ceec375b222e": {"node_ids": ["cf8fc020-01e6-4470-b1db-70012eb2f822"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "1d433be7-3fee-40ad-9096-0cd30d082d5b": {"node_ids": ["bac0b557-4d29-45e4-9b97-7eb3d94059c6"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "3c19b45c-0bb6-41a7-a513-2779f900200d": {"node_ids": ["c4ccbd8d-84b6-47e6-8d29-6f09d42e5c60"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "bd4dfd55-fd52-4ad4-8f18-cd0eb92628bc": {"node_ids": ["15b3a0e9-c626-4ce0-a150-dc56e8976957"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "a65c6650-1424-4f55-aa5c-4fd7d807d0d0": {"node_ids": ["11b2fb3b-e597-4181-8ca3-65b93e3a1b8d"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "ca0210a6-bad3-4baa-9c51-0358f67c1f53": {"node_ids": ["8316afb5-7e18-42ba-b4b5-ece619876d13"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "612883d9-9db4-48e7-9fac-2123087fa821": {"node_ids": ["3ff58683-b241-4204-9422-74ca76500024"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "bb180876-b6e2-43a5-bcd4-0a64793d24f9": {"node_ids": ["26cac643-4e3f-40af-b6b3-198bf928e613"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c624a7a2-6d17-4bc8-b14b-41fdb271454b": {"node_ids": ["f8190573-17a2-4f48-96f5-e9de24a468a3"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "bc0eff0a-682f-40a9-8944-28d0548166ef": {"node_ids": ["3a9a2c52-c8f7-4d5e-8604-e2108925bcfe"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "8babc670-40c0-456e-a794-1e2adf262c9a": {"node_ids": ["391b30a4-a5c6-43ee-af92-3c4d3ffa9738"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "164a7700-9271-4c3d-8044-44e3699e41d0": {"node_ids": ["0dbde4c6-cc9a-4a2f-83d6-35a3602cd3bb"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "d724225e-4bc5-47dd-9c3b-2dc28ed0a986": {"node_ids": ["5672b081-5c8e-4df8-8072-0c57e5c54aa9"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "f850c619-c7d4-4836-9993-fdebbdbc4e72": {"node_ids": ["5051c91a-36b9-4537-bdeb-e45c056c8fdd"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "5447f475-1492-43a8-93d3-515de254e4b9": {"node_ids": ["bb531fb7-0cfe-469f-b092-b69c85d2f79a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "e50b4eae-c4b7-4d03-8794-6590c6f9515a": {"node_ids": ["471d678f-de01-4b01-9832-0d94cf7283f2"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "89c0f327-0181-4262-961c-712fa3bd3f5a": {"node_ids": ["75e58b01-d49c-4871-b2e6-5becf95f2bc0"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "bed8baab-41ea-443b-8c2a-2472e90c7933": {"node_ids": ["35fd07d3-ad65-405c-a284-275b10b83ed6"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "ed184b12-df96-457d-830a-cfbc3c39dc36": {"node_ids": ["4d427609-7a63-4636-b86c-76727ebedf3f"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "f9207ce3-2046-43ee-b074-875e1aec2213": {"node_ids": ["bac768a0-679a-4863-88d4-f7df15bfe00a"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "e195a8b7-9bd6-4243-b50e-99822347643e": {"node_ids": ["13501c1a-267c-4298-ab95-9de3805ae756"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "a79b72e8-af14-404f-ba34-9b8740f8428d": {"node_ids": ["d34e59b3-ec97-4a89-ace3-4c28022c21da"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6418bd1d-1814-45de-88d7-f307c2bd82ff": {"node_ids": ["a4477c28-d91e-441f-88aa-102e447aaebd"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "e2b5a1f2-ca1d-4174-bf53-0fbf97b69197": {"node_ids": ["03c4a4c8-80e4-4412-83d5-0564106e9a74"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "25ce72e4-5cad-4303-9831-a1dbb3eb2339": {"node_ids": ["f735b7d1-0aff-4c8f-8e09-9c2486cc4949"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "8d9bfff5-1578-4007-b762-1832b4a0c23b": {"node_ids": ["7acb23d6-e401-47fa-a476-ff9aa5ba5200"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "394a4f45-1d99-4702-9dc6-c9b89e15ec30": {"node_ids": ["5505bba0-169e-45cf-88e0-7a09d74e92dc"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "09c08890-5471-4e32-baa2-4ec0d3faf3f8": {"node_ids": ["dab4f4c5-4e06-4d59-8e8b-22d8153ed292"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "fc26abac-1325-4bd1-af3b-2facd5b378f5": {"node_ids": ["d976907e-6a1e-4f20-a138-407dc66ea34c"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "6aa69ebc-45f2-435e-bb1b-cad241b4fa23": {"node_ids": ["6857750c-2920-441f-86c6-11b2297886d1"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "c1abcc7f-2a36-4100-b728-fa8f385ba7dd": {"node_ids": ["9741e9f4-9cc0-4bca-867a-d61b7857ed14"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "a701e63b-aa68-4f04-bba9-c33ba763d6d5": {"node_ids": ["a461165b-12a8-4cee-a663-10cc11edf05b"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "420c3b95-a64c-4c5a-af4a-709f7826fc14": {"node_ids": ["ff97433b-069f-4fc9-96fd-581cb92c35d6"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "4751bee8-539f-4dfb-9718-f789534598d4": {"node_ids": ["5930c6f6-c291-4ea8-9a73-fc52b471a514"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "46eb1b61-a236-4070-b02d-965650d9309b": {"node_ids": ["8dd7b702-dd79-4264-91d7-53db1277a4f9"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "00cf25b1-8a6a-4f6f-a217-5e8331c3ff61": {"node_ids": ["946b2634-b6a6-4898-af3d-c155f54d24ac"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "7e5af48d-f5ff-4b60-b450-6aa543a5a171": {"node_ids": ["01bbea0e-ff7d-46f2-b3cc-e525913a67f2"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "9a04f9f7-e932-4822-8df6-ee97d6abb2b8": {"node_ids": ["d9d5d2fa-8f23-46b9-9fec-319cf204711c"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "5847202a-71f8-44f2-abde-5792dcab65e9": {"node_ids": ["3d16b8e5-afbf-47e4-a085-a1c8ec2c2d56"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}, "03671864-c2be-42ec-87da-4d24b70c26ab": {"node_ids": ["d59129b7-9f30-4524-906a-d141cfb4b90f"], "metadata": {"file_path": "data/python_api_219_docs.md", "file_name": "python_api_219_docs.md", "file_type": "text/markdown", "file_size": 353834, "creation_date": "2025-08-01", "last_modified_date": "2025-08-01"}}}}